<?xml version="1.0"?>
<!--This file was created automatically by html2xhtml-->
<!--from the HTML stylesheets.-->
<xsl:stylesheet xmlns="http://www.w3.org/1999/xhtml"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:ng="http://docbook.org/docbook-ng"
                xmlns:db="http://docbook.org/ns/docbook"
                xmlns:exsl="http://exslt.org/common"
                xmlns:exslt="http://exslt.org/common"
                xmlns:fm="http://freshmeat.net/projects/freshmeat-submit/"
                xmlns:sf="http://sourceforge.net/"
                xmlns:dyn="http://exslt.org/dynamic"
                xmlns:saxon="http://icl.com/saxon"
                xmlns:doc="http://nwalsh.com/xsl/documentation/1.0"
                xmlns:stbl="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.Table"
                xmlns:xtbl="xalan://com.nwalsh.xalan.Table"
                xmlns:lxslt="http://xml.apache.org/xslt"
                xmlns:ptbl="http://nwalsh.com/xslt/ext/xsltproc/python/Table"
                xmlns:sverb="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.Verbatim"
                xmlns:xverb="xalan://com.nwalsh.xalan.Verbatim"
                xmlns:suwl="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.UnwrapLinks"
                xmlns:xlink="http://www.w3.org/1999/xlink"
                xmlns:stext="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.TextFactory"
                xmlns:simg="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.ImageIntrinsics"
                xmlns:ximg="xalan://com.nwalsh.xalan.ImageIntrinsics"
                xmlns:xtext="xalan://com.nwalsh.xalan.Text"
                xmlns:date="http://exslt.org/dates-and-times"
                xmlns:l="http://docbook.sourceforge.net/xmlns/l10n/1.0"
                xmlns:mml="http://www.w3.org/1998/Math/MathML"
                xmlns:set="http://exslt.org/sets"
                xmlns:NodeInfo="http://org.apache.xalan.lib.NodeInfo"
                xmlns:redirect="http://xml.apache.org/xalan/redirect"
                xmlns:perl="urn:perl"
                exclude-result-prefixes="db doc dyn saxon ng exsl exslt stbl xtbl lxslt ptbl fm sf sverb xlink suwl xverb stext xtext simg l date mml set NodeInfo redirect ximg"
                extension-element-prefixes="perl stext xtext ptbl xtbl stbl"
                version="1.0">

    <xsl:output method="xml" indent="yes" encoding="UTF-8"/>

    <!-- ********************************************************************
     $Id: docbook.xsl 9605 2012-09-18 10:48:54Z tom_schr $
     ********************************************************************

     This file is part of the XSL DocBook Stylesheet distribution.
     See ../README or http://docbook.sf.net/release/xsl/current/ for
     copyright and other information.

     ******************************************************************** -->

    <!-- ==================================================================== -->

    <xsl:param name="publican.version">3.1.5</xsl:param>
    <xsl:param name="body.only" select="1"/>
    <xsl:param name="book.type" select="'book'"/>
    <xsl:param name="web.type" select="''"/>
    <xsl:param name="confidential" select="0"/>
    <xsl:param name="confidential.text">CONFIDENTIAL</xsl:param>
    <xsl:param name="embedtoc" select="'0'"/>
    <xsl:param name="tocpath" select="''"/>
    <xsl:param name="pop_prod" select="''"/>
    <xsl:param name="pop_ver" select="''"/>
    <xsl:param name="pop_name" select="''"/>
    <xsl:param name="brand" select="''"/>
    <xsl:param name="langpath" select="''"/>
    <xsl:param name="desktop" select="0"/>
    <xsl:param name="refentry.pagebreak">0</xsl:param>
    <xsl:param name="svg.object">1</xsl:param>
    <xsl:param name="package" select="''"/>
    <xsl:param name="html.longdesc.embed" select="1"/>
    <xsl:param name="chunker.output.quiet" select="0"/>
    <xsl:param name="class.prefix">docbook-</xsl:param>

    <xsl:param name="get"/>
    <xsl:param name="VERSION">1.78.1</xsl:param>
    <xsl:param name="Tag" select="concat('V',translate('1.78.1','.',''))"/>
    <xsl:param name="DistroTitle">XSL Stylesheets</xsl:param>
    <xsl:param name="sf-relid" select="0"/>
    <xsl:param name="DistroName">docbook-xsl</xsl:param>
    <xsl:param name="PreviousRelease">1.78.0</xsl:param>
    <xsl:param name="PreviousReleaseRevision">9696</xsl:param>
    <xsl:param name="Revision">$Revision: 9731 $</xsl:param>
    <xsl:param name="VersionFileURL">$URL: https://docbook.svn.sourceforge.net/svnroot/docbook/trunk/xsl/VERSION $
    </xsl:param>
    <xsl:strip-space elements="fm:*"/>
    <fm:project xmlns:fm="http://freshmeat.net/projects/freshmeat-submit/">
        <fm:Project>DocBook</fm:Project>
        <fm:Branch>XSL Stylesheets</fm:Branch>
        <!-- * set/keep fm:version as N.NN.N-pre except for official releases, -->
        <!-- * then after the release, revert it to N.NN.N-pre & check back in -->
        <fm:Version>1.78.1</fm:Version>
        <!--
  <fm:License>MIT/X Consortium License</fm:License>
-->
        <fm:Release-Focus>
            <!-- * Initial freshmeat announcement -->
            <!-- * Documentation -->
            <!-- * Code cleanup -->
            <!-- * Minor feature enhancements  -->
            * Major feature enhancements
            <!-- * Minor bugfixes  -->
            <!-- * Major bugfixes -->
            <!-- * Minor security fixes -->
            <!-- * Major security fixes -->
        </fm:Release-Focus>
        <fm:Home-Page-URL>http://sourceforge.net/projects/docbook/</fm:Home-Page-URL>
        <fm:Gzipped-Tar-URL>http://prdownloads.sourceforge.net/docbook/{DISTRONAME-VERSION}.tar.gz?download
        </fm:Gzipped-Tar-URL>
        <fm:Zipped-Tar-URL>http://prdownloads.sourceforge.net/docbook/{DISTRONAME-VERSION}.zip?download
        </fm:Zipped-Tar-URL>
        <fm:Bzipped-Tar-URL>http://prdownloads.sourceforge.net/docbook/{DISTRONAME-VERSION}.bz2?download
        </fm:Bzipped-Tar-URL>
        <fm:Changelog-URL>http://sourceforge.net/project/shownotes.php?release_id={SFRELID}</fm:Changelog-URL>
        <fm:CVS-URL>http://docbook.svn.sourceforge.net/viewvc/docbook/</fm:CVS-URL>
        <fm:Mailing-List-URL>http://lists.oasis-open.org/archives/docbook-apps/</fm:Mailing-List-URL>
        <fm:Changes>This is a release with bugfixes and some enhancements.</fm:Changes>
    </fm:project>
    <xsl:template match="/" priority="-100">
        <xsl:choose>
            <xsl:when test="$get = 'Tag'">
                <xsl:value-of select="$Tag"/>
            </xsl:when>
            <xsl:when test="$get = 'PreviousRelease'">
                <xsl:value-of select="$PreviousRelease"/>
            </xsl:when>
            <xsl:when test="$get = 'PreviousReleaseRevision'">
                <xsl:value-of select="$PreviousReleaseRevision"/>
            </xsl:when>
            <xsl:when test="$get = 'DistroTitle'">
                <xsl:value-of select="$DistroTitle"/>
            </xsl:when>
            <xsl:when test="$get = 'VERSION'">
                <xsl:value-of select="$VERSION"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:if test="$sf-relid = 0">
                    <xsl:message terminate="yes">
                        <xsl:text>You must specify the sf-relid as a parameter.</xsl:text>
                    </xsl:message>
                </xsl:if>
                <xsl:apply-templates select="//fm:project"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="fm:project">
        <xsl:apply-templates/>
  <xsl:text>
</xsl:text>
        <xsl:apply-templates select="fm:Changes" mode="text"/>
    </xsl:template>
    <xsl:template match="fm:Changes"/>
    <xsl:template match="fm:Gzipped-Tar-URL|fm:Zipped-Tar-URL|fm:Bzipped-Tar-URL">
        <xsl:value-of select="local-name(.)"/>
        <xsl:text>: </xsl:text>
        <xsl:value-of select="substring-before(., '{DISTRONAME-VERSION}')"/>
        <xsl:value-of select="concat($DistroName, '-', $VERSION)"/>
        <xsl:value-of select="substring-after(., '{DISTRONAME-VERSION}')"/>
  <xsl:text>
</xsl:text>
    </xsl:template>
    <xsl:template match="fm:Changelog-URL">
        <xsl:value-of select="local-name(.)"/>
        <xsl:text>: </xsl:text>
        <xsl:value-of select="substring-before(., '{SFRELID}')"/>
        <xsl:value-of select="$sf-relid"/>
        <xsl:value-of select="substring-after(., '{SFRELID}')"/>
  <xsl:text>
</xsl:text>
    </xsl:template>
    <xsl:template match="fm:*">
        <xsl:value-of select="local-name(.)"/>
        <xsl:text>: </xsl:text>
        <xsl:value-of select="normalize-space(.)"/>
  <xsl:text>
</xsl:text>
    </xsl:template>
    <xsl:param name="abstract.notitle.enabled" select="0"/>
    <xsl:param name="activate.external.olinks" select="1"/>
    <xsl:param name="admon.graphics.extension">.png</xsl:param>
    <xsl:param name="admon.graphics" select="1"/>
    <xsl:param name="admon.graphics.path">
        <xsl:choose>
            <xsl:when test="$embedtoc != 0">
                <xsl:value-of select="concat($tocpath, '/../', $brand, '/', $langpath, '/images')"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>images/</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:param>
    <xsl:param name="admon.style" select="''"/>
    <xsl:param name="admon.textlabel" select="1"/>
    <xsl:param name="annotate.toc" select="1"/>
    <xsl:param name="annotation.css">
        /* ======================================================================
        Annotations
        */

        div.annotation-list { visibility: hidden;
        }

        div.annotation-nocss { position: absolute;
        visibility: hidden;
        }

        div.annotation-popup { position: absolute;
        z-index: 4;
        visibility: hidden;
        padding: 0px;
        margin: 2px;
        border-style: solid;
        border-width: 1px;
        width: 200px;
        background-color: white;
        }

        div.annotation-title { padding: 1px;
        font-weight: bold;
        border-bottom-style: solid;
        border-bottom-width: 1px;
        color: white;
        background-color: black;
        }

        div.annotation-body { padding: 2px;
        }

        div.annotation-body p { margin-top: 0px;
        padding-top: 0px;
        }

        div.annotation-close { position: absolute;
        top: 2px;
        right: 2px;
        }
    </xsl:param>
    <xsl:param name="annotation.graphic.close">
        http://docbook.sourceforge.net/release/images/annot-close.png
    </xsl:param>
    <xsl:param name="annotation.graphic.open">http://docbook.sourceforge.net/release/images/annot-open.png</xsl:param>
    <xsl:param name="annotation.js">
        <xsl:text>http://docbook.sourceforge.net/release/script/AnchorPosition.js http://docbook.sourceforge.net/release/script/PopupWindow.js</xsl:text>
    </xsl:param>
    <xsl:param name="annotation.support" select="0"/>
    <xsl:param name="appendix.autolabel">A</xsl:param>
    <xsl:param name="author.othername.in.middle" select="1"/>
    <xsl:param name="autotoc.label.in.hyperlink" select="1"/>
    <xsl:param name="autotoc.label.separator">.</xsl:param>
    <xsl:param name="base.dir"/>
    <xsl:param name="biblioentry.item.separator">.</xsl:param>
    <xsl:param name="bibliography.collection">http://docbook.sourceforge.net/release/bibliography/bibliography.xml
    </xsl:param>
    <xsl:param name="bibliography.numbered" select="0"/>
    <xsl:param name="bibliography.style">normal</xsl:param>
    <xsl:param name="blurb.on.titlepage.enabled" select="0"/>
    <xsl:param name="bridgehead.in.toc" select="0"/>
    <xsl:param name="callout.defaultcolumn">60</xsl:param>
    <xsl:param name="callout.graphics.extension">.png</xsl:param>
    <xsl:param name="callout.graphics" select="1"/>
    <xsl:param name="callout.graphics.number.limit">15</xsl:param>
    <xsl:param name="callout.graphics.path">
        <xsl:value-of select="$admon.graphics.path"/>
    </xsl:param>
    <xsl:param name="callout.list.table" select="1"/>
    <xsl:param name="callout.unicode" select="0"/>
    <xsl:param name="callout.unicode.number.limit">10</xsl:param>
    <xsl:param name="callout.unicode.start.character">10102</xsl:param>
    <xsl:param name="callouts.extension" select="1"/>
    <xsl:param name="chapter.autolabel" select="1"/>
    <xsl:param name="chunk.append"/>
    <xsl:param name="chunk.first.sections" select="1"/>
    <xsl:param name="chunk.quietly" select="0"/>
    <xsl:param name="chunk.section.depth" select="4"/>
    <xsl:param name="chunk.separate.lots" select="0"/>
    <xsl:param name="chunk.toc" select="''"/>
    <xsl:param name="chunk.tocs.and.lots" select="0"/>
    <xsl:param name="chunk.tocs.and.lots.has.title" select="1"/>
    <xsl:param name="chunked.filename.prefix"/>
    <xsl:param name="citerefentry.link" select="0"/>
    <xsl:param name="collect.xref.targets">no</xsl:param>
    <xsl:param name="component.label.includes.part.label" select="0"/>
    <xsl:param name="contrib.inline.enabled">1</xsl:param>
    <xsl:param name="css.decoration" select="0"/>
    <xsl:param name="current.docid"/>
    <xsl:param name="custom.css"/>
    <xsl:param name="custom.css.filename"/>
    <xsl:param name="default.float.class">
        <xsl:choose>
            <xsl:when test="contains($stylesheet.result.type,'html')">left</xsl:when>
            <xsl:otherwise>before</xsl:otherwise>
        </xsl:choose>
    </xsl:param>
    <xsl:param name="default.image.width"/>
    <xsl:param name="default.table.frame">all</xsl:param>
    <xsl:param name="default.table.width"/>
    <xsl:param name="docbook.css.link" select="1"/>
    <xsl:param name="docbook.css">
        /********************************/
        /* start of styles in block.xsl */

        .formalpara-title {
        font-weight: bold;
        }

        div.blockquote-title {
        font-weight: bold;
        margin-top: 1em;
        margin-bottom: 1em;
        }

        span.msgmain-title {
        font-weight: bold;
        }

        span.msgsub-title {
        font-weight: bold;
        }

        span.msgrel-title {
        font-weight: bold;
        }

        div.msglevel, div.msgorig, div.msgaud {
        margin-top: 1em;
        margin-bottom: 1em;
        }

        span.msglevel-title, span.msgorig-title, span.msgaud-title {
        font-weight: bold;
        }

        div.msgexplan {
        margin-top: 1em;
        margin-bottom: 1em;
        }

        span.msgexplan-title {
        font-weight: bold;
        }

        /* end of styles in block.xsl */
        /********************************/

        /********************************/
        /* start of styles in autotoc.xsl */


        /* end of styles in autotoc.xsl */
        /********************************/

        /********************************/
        /* start of styles in formal.xsl */

        div.figure-title {
        font-weight: bold;
        }

        div.example-title {
        font-weight: bold;
        }

        div.equation-title {
        font-weight: bold;
        }

        div.table-title {
        font-weight: bold;
        }

        div.sidebar-title {
        font-weight: bold;
        }


        /* end of styles in formal.xsl */
        /********************************/

        /********************************/
        /* start of styles in verbatim.xsl */

        div.programlisting {
        white-space: pre;
        font-family: monospace;
        }

        div.screen {
        white-space: pre;
        font-family: monospace;
        }
    </xsl:param>
    <xsl:param name="docbook.css.filename">docbook.css</xsl:param>
    <xsl:param name="draft.mode">maybe</xsl:param>
    <xsl:param name="draft.watermark.image">images/draft.png</xsl:param>
    <xsl:param name="ebnf.assignment">
        <code>::=</code>
    </xsl:param>
    <xsl:param name="ebnf.statement.terminator"/>
    <xsl:param name="ebnf.table.bgcolor">#F5DCB3</xsl:param>
    <xsl:param name="ebnf.table.border" select="1"/>
    <xsl:param name="eclipse.autolabel" select="0"/>
    <xsl:param name="eclipse.plugin.id">com.example.help</xsl:param>
    <xsl:param name="eclipse.plugin.name">DocBook Online Help Sample</xsl:param>
    <xsl:param name="eclipse.plugin.provider">Example provider</xsl:param>
    <xsl:param name="editedby.enabled">1</xsl:param>
    <xsl:param name="email.delimiters.enabled" select="0"/>
    <xsl:param name="emphasis.propagates.style" select="1"/>
    <xsl:param name="entry.propagates.style" select="1"/>
    <xsl:param name="exsl.node.set.available">
        <xsl:choose>
            <xsl:when exsl:foo=""
                      test="function-available('exsl:node-set') or                        contains(system-property('xsl:vendor'),                          'Apache Software Foundation')">
                1
            </xsl:when>
            <xsl:otherwise>0</xsl:otherwise>
        </xsl:choose>
    </xsl:param>
    <xsl:param name="firstterm.only.link" select="0"/>
    <xsl:param name="footer.rule" select="0"/>
    <xsl:param name="footnote.number.format">1</xsl:param>
    <xsl:param name="footnote.number.symbols"/>
    <xsl:param name="formal.procedures" select="1"/>
    <xsl:param name="formal.title.placement">
        figure after
        example before
        equation before
        table before
        procedure before
    </xsl:param>
    <xsl:param name="funcsynopsis.decoration" select="1"/>
    <xsl:param name="funcsynopsis.style">ansi</xsl:param>
    <xsl:param name="function.parens" select="0"/>
    <xsl:param name="generate.consistent.ids" select="0"/>
    <xsl:param name="generate.css.header" select="0"/>
    <xsl:param name="generate.id.attributes" select="0"/>
    <xsl:param name="generate.index" select="1"/>
    <xsl:param name="generate.legalnotice.link" select="0"/>
    <xsl:param name="generate.manifest" select="0"/>
    <xsl:param name="generate.meta.abstract" select="1"/>
    <xsl:param name="generate.revhistory.link" select="0"/>
    <xsl:param name="generate.section.toc.level" select="0"/>
    <xsl:param name="generate.toc">
        set toc
        book toc
        article nop
        chapter toc
        qandadiv toc
        qandaset toc
        sect1 nop
        sect2 nop
        sect3 nop
        sect4 nop
        sect5 nop
        section toc
        part toc
    </xsl:param>
    <xsl:param name="glossary.collection"/>
    <xsl:param name="glossary.sort" select="1"/>
    <xsl:param name="glossentry.show.acronym">no</xsl:param>
    <xsl:param name="glossterm.auto.link" select="0"/>
    <xsl:param name="graphic.default.extension"/>
    <xsl:param name="graphicsize.extension" select="1"/>
    <xsl:param name="graphicsize.use.img.src.path" select="0"/>
    <xsl:param name="header.rule" select="0"/>
    <xsl:param name="highlight.default.language"/>
    <xsl:param name="highlight.source" select="1"/>
    <xsl:param name="highlight.xslthl.config"/>
    <xsl:param name="html.append"/>
    <xsl:param name="html.base"/>
    <xsl:param name="html.cellpadding"/>
    <xsl:param name="html.cellspacing"/>
    <xsl:param name="html.cleanup" select="0"/>
    <xsl:param name="html.ext">.html</xsl:param>
    <xsl:param name="html.extra.head.links" select="0"/>
    <xsl:param name="html.head.legalnotice.link.multiple" select="1"/>
    <xsl:param name="html.head.legalnotice.link.types">copyright</xsl:param>
    <xsl:param name="html.longdesc" select="0"/>
    <xsl:param name="html.longdesc.link" select="0"/>
    <xsl:param name="html.script"/>
    <xsl:param name="html.script.type">text/javascript</xsl:param>
    <xsl:param name="html.stylesheet">
        <xsl:if test="$embedtoc = 0 ">css/default.css</xsl:if>
    </xsl:param>
    <xsl:param name="html.stylesheet.type">text/css</xsl:param>
    <xsl:param name="html.stylesheet.print">
        <xsl:if test="$embedtoc = 0 ">css/print.css</xsl:if>
    </xsl:param>
    <xsl:param name="htmlhelp.alias.file">alias.h</xsl:param>
    <xsl:param name="htmlhelp.autolabel" select="0"/>
    <xsl:param name="htmlhelp.button.back" select="1"/>
    <xsl:param name="htmlhelp.button.forward" select="0"/>
    <xsl:param name="htmlhelp.button.hideshow" select="1"/>
    <xsl:param name="htmlhelp.button.home" select="0"/>
    <xsl:param name="htmlhelp.button.home.url"/>
    <xsl:param name="htmlhelp.button.jump1" select="0"/>
    <xsl:param name="htmlhelp.button.jump1.title">User1</xsl:param>
    <xsl:param name="htmlhelp.button.jump1.url"/>
    <xsl:param name="htmlhelp.button.jump2" select="0"/>
    <xsl:param name="htmlhelp.button.jump2.title">User2</xsl:param>
    <xsl:param name="htmlhelp.button.jump2.url"/>
    <xsl:param name="htmlhelp.button.locate" select="0"/>
    <xsl:param name="htmlhelp.button.next" select="1"/>
    <xsl:param name="htmlhelp.button.options" select="1"/>
    <xsl:param name="htmlhelp.button.prev" select="1"/>
    <xsl:param name="htmlhelp.button.print" select="1"/>
    <xsl:param name="htmlhelp.button.refresh" select="0"/>
    <xsl:param name="htmlhelp.button.stop" select="0"/>
    <xsl:param name="htmlhelp.button.zoom" select="0"/>
    <xsl:param name="htmlhelp.chm">htmlhelp.chm</xsl:param>
    <xsl:param name="htmlhelp.default.topic"/>
    <xsl:param name="htmlhelp.display.progress" select="1"/>
    <xsl:param name="htmlhelp.encoding">iso-8859-1</xsl:param>
    <xsl:param name="htmlhelp.enhanced.decompilation" select="0"/>
    <xsl:param name="htmlhelp.enumerate.images" select="0"/>
    <xsl:param name="htmlhelp.force.map.and.alias" select="0"/>
    <xsl:param name="htmlhelp.hhc.binary" select="1"/>
    <xsl:param name="htmlhelp.hhc.folders.instead.books" select="1"/>
    <xsl:param name="htmlhelp.hhc">toc.hhc</xsl:param>
    <xsl:param name="htmlhelp.hhc.section.depth">5</xsl:param>
    <xsl:param name="htmlhelp.hhc.show.root" select="1"/>
    <xsl:param name="htmlhelp.hhc.width"/>
    <xsl:param name="htmlhelp.hhk">index.hhk</xsl:param>
    <xsl:param name="htmlhelp.hhp">htmlhelp.hhp</xsl:param>
    <xsl:param name="htmlhelp.hhp.tail"/>
    <xsl:param name="htmlhelp.hhp.window">Main</xsl:param>
    <xsl:param name="htmlhelp.hhp.windows"/>
    <xsl:param name="htmlhelp.map.file">context.h</xsl:param>
    <xsl:param name="htmlhelp.only" select="0"/>
    <xsl:param name="htmlhelp.remember.window.position" select="0"/>
    <xsl:param name="htmlhelp.show.advanced.search" select="0"/>
    <xsl:param name="htmlhelp.show.favorities" select="0"/>
    <xsl:param name="htmlhelp.show.menu" select="0"/>
    <xsl:param name="htmlhelp.show.toolbar.text" select="1"/>
    <xsl:param name="htmlhelp.title"/>
    <xsl:param name="htmlhelp.use.hhk" select="0"/>
    <xsl:param name="htmlhelp.window.geometry"/>
    <xsl:param name="id.warnings" select="0"/>
    <xsl:param name="ignore.image.scaling" select="0"/>
    <xsl:param name="img.src.path"/>
    <xsl:param name="index.links.to.section" select="1"/>
    <xsl:param name="index.method">basic</xsl:param>
    <xsl:param name="index.number.separator"/>
    <xsl:param name="index.on.role" select="0"/>
    <xsl:param name="index.on.type" select="0"/>
    <xsl:param name="index.prefer.titleabbrev" select="0"/>
    <xsl:param name="index.range.separator"/>
    <xsl:param name="index.term.separator"/>
    <xsl:param name="inherit.keywords" select="1"/>
    <xsl:param name="insert.olink.page.number">no</xsl:param>
    <xsl:param name="insert.olink.pdf.frag" select="0"/>
    <xsl:param name="insert.xref.page.number">no</xsl:param>
    <xsl:param name="javahelp.encoding">iso-8859-1</xsl:param>
    <xsl:param name="keep.relative.image.uris" select="1"/>
    <xsl:param name="l10n.gentext.default.language">en</xsl:param>
    <xsl:param name="l10n.gentext.language"/>
    <xsl:param name="l10n.gentext.use.xref.language" select="0"/>
    <xsl:param name="l10n.lang.value.rfc.compliant" select="1"/>
    <xsl:param name="label.from.part" select="0"/>
    <xsl:param name="linenumbering.everyNth">5</xsl:param>
    <xsl:param name="linenumbering.extension" select="1"/>
    <xsl:param name="linenumbering.separator">
        <xsl:text> </xsl:text>
    </xsl:param>
    <xsl:param name="linenumbering.width">3</xsl:param>
    <xsl:param name="link.mailto.url"/>
    <xsl:param name="make.clean.html" select="0"/>
    <xsl:param name="make.graphic.viewport" select="0"/>
    <xsl:param name="make.single.year.ranges" select="0"/>
    <xsl:param name="make.valid.html" select="1"/>
    <xsl:param name="make.year.ranges" select="0"/>
    <xsl:param name="manifest">HTML.manifest</xsl:param>
    <xsl:param name="manifest.in.base.dir" select="0"/>
    <xsl:param name="manual.toc"/>
    <xsl:param name="menuchoice.menu.separator">→</xsl:param>
    <xsl:param name="menuchoice.separator">+</xsl:param>
    <xsl:param name="navig.graphics.extension">.gif</xsl:param>
    <xsl:param name="navig.graphics" select="0"/>
    <xsl:param name="navig.graphics.path">images/</xsl:param>
    <xsl:param name="navig.showtitles">1</xsl:param>
    <xsl:param name="nominal.image.depth" select="4 * $pixels.per.inch"/>
    <xsl:param name="nominal.image.width" select="6 * $pixels.per.inch"/>
    <xsl:param name="nominal.table.width">6in</xsl:param>
    <xsl:param name="olink.base.uri"/>
    <xsl:param name="olink.debug" select="0"/>
    <xsl:param name="olink.doctitle">no</xsl:param>
    <xsl:param name="olink.lang.fallback.sequence"/>
    <xsl:attribute-set name="olink.properties">
        <xsl:attribute name="show-destination">replace</xsl:attribute>
    </xsl:attribute-set>
    <xsl:param name="othercredit.like.author.enabled">0</xsl:param>
    <xsl:param name="para.propagates.style" select="1"/>
    <xsl:param name="part.autolabel">I</xsl:param>
    <xsl:param name="phrase.propagates.style" select="1"/>
    <xsl:param name="pixels.per.inch">90</xsl:param>
    <xsl:param name="points.per.em">10</xsl:param>
    <xsl:param name="preface.autolabel" select="0"/>
    <xsl:param name="prefer.internal.olink" select="0"/>
    <xsl:param name="preferred.mediaobject.role"/>
    <xsl:param name="process.empty.source.toc" select="0"/>
    <xsl:param name="process.source.toc" select="0"/>
    <xsl:param name="profile.arch"/>
    <xsl:param name="profile.attribute"/>
    <xsl:param name="profile.audience"/>
    <xsl:param name="profile.condition"/>
    <xsl:param name="profile.conformance"/>
    <xsl:param name="profile.lang"/>
    <xsl:param name="profile.os"/>
    <xsl:param name="profile.revision"/>
    <xsl:param name="profile.revisionflag"/>
    <xsl:param name="profile.role"/>
    <xsl:param name="profile.security"/>
    <xsl:param name="profile.separator">;</xsl:param>
    <xsl:param name="profile.status"/>
    <xsl:param name="profile.userlevel"/>
    <xsl:param name="profile.value"/>
    <xsl:param name="profile.vendor"/>
    <xsl:param name="profile.wordsize"/>
    <xsl:param name="punct.honorific">.</xsl:param>
    <xsl:param name="qanda.defaultlabel">qanda</xsl:param>
    <xsl:param name="qanda.in.toc" select="0"/>
    <xsl:param name="qanda.inherit.numeration" select="1"/>
    <xsl:param name="qanda.nested.in.toc" select="0"/>
    <xsl:param name="qandadiv.autolabel" select="1"/>
    <xsl:param name="refclass.suppress" select="0"/>
    <xsl:param name="refentry.generate.name" select="1"/>
    <xsl:param name="refentry.generate.title" select="0"/>
    <xsl:param name="refentry.separator" select="1"/>
    <xsl:param name="refentry.xref.manvolnum" select="1"/>
    <xsl:param name="reference.autolabel">I</xsl:param>
    <xsl:param name="root.filename">index</xsl:param>
    <xsl:param name="rootid"/>
    <xsl:param name="runinhead.default.title.end.punct">.</xsl:param>
    <xsl:param name="runinhead.title.end.punct">.!?:</xsl:param>
    <xsl:param name="section.autolabel" select="1"/>
    <xsl:param name="section.autolabel.max.depth">8</xsl:param>
    <xsl:param name="section.label.includes.component.label" select="1"/>
    <xsl:param name="segmentedlist.as.table" select="1"/>
    <xsl:param name="shade.verbatim" select="0"/>
    <xsl:attribute-set name="shade.verbatim.style">
        <xsl:attribute name="border">0</xsl:attribute>
        <xsl:attribute name="bgcolor">#E0E0E0</xsl:attribute>
    </xsl:attribute-set>
    <xsl:param name="show.comments" select="0"/>
    <xsl:param name="show.revisionflag" select="0"/>
    <xsl:param name="simplesect.in.toc" select="0"/>
    <xsl:param name="spacing.paras" select="0"/>
    <xsl:param name="suppress.footer.navigation">
        <xsl:value-of select="$embedtoc"/>
    </xsl:param>
    <xsl:param name="suppress.header.navigation" select="0"/>
    <xsl:param name="suppress.navigation" select="0"/>
    <xsl:param name="table.borders.with.css" select="0"/>
    <xsl:param name="table.cell.border.color"/>
    <xsl:param name="table.cell.border.style"/>
    <xsl:param name="table.cell.border.thickness">0.5pt</xsl:param>
    <xsl:param name="table.footnote.number.format">a</xsl:param>
    <xsl:param name="table.footnote.number.symbols"/>
    <xsl:param name="table.frame.border.color"/>
    <xsl:param name="table.frame.border.style">solid</xsl:param>
    <xsl:param name="table.frame.border.thickness">0.5pt</xsl:param>
    <xsl:param name="tablecolumns.extension" select="0"/>
    <xsl:param name="target.database.document">olinkdb.xml</xsl:param>
    <xsl:param name="targets.filename">target.db</xsl:param>
    <xsl:param name="tex.math.delims" select="1"/>
    <xsl:param name="tex.math.file">tex-math-equations.tex</xsl:param>
    <xsl:param name="tex.math.in.alt"/>
    <xsl:param name="textdata.default.encoding"/>
    <xsl:param name="textinsert.extension" select="1"/>
    <xsl:param name="toc.list.type">dl</xsl:param>
    <xsl:param name="toc.max.depth">8</xsl:param>
    <xsl:param name="toc.section.depth">2</xsl:param>
    <xsl:param name="ulink.target"/>
    <xsl:param name="use.embed.for.svg" select="0"/>
    <xsl:param name="use.extensions" select="1"/>
    <xsl:param name="use.id.as.filename" select="1"/>
    <xsl:param name="use.local.olink.style" select="0"/>
    <xsl:param name="use.role.as.xrefstyle" select="1"/>
    <xsl:param name="use.role.for.mediaobject" select="1"/>
    <xsl:param name="use.svg" select="1"/>
    <xsl:param name="variablelist.as.table" select="0"/>
    <xsl:param name="variablelist.term.break.after">0</xsl:param>
    <xsl:param name="variablelist.term.separator">,</xsl:param>
    <xsl:param name="webhelp.autolabel">0</xsl:param>
    <xsl:param name="webhelp.base.dir">docs</xsl:param>
    <xsl:param name="webhelp.common.dir">../common/</xsl:param>
    <xsl:param name="webhelp.default.topic">index.html</xsl:param>
    <xsl:param name="webhelp.include.search.tab">1</xsl:param>
    <xsl:param name="webhelp.indexer.language">en</xsl:param>
    <xsl:param name="webhelp.start.filename">index.html</xsl:param>
    <xsl:param name="webhelp.tree.cookie.id" select="concat( 'treeview-', count(//node()) )"/>
    <xsl:param name="writing.mode">
        <xsl:call-template name="gentext">
            <xsl:with-param name="key">writing-mode</xsl:with-param>
            <xsl:with-param name="lang">
                <xsl:call-template name="l10n.language">
                    <xsl:with-param name="target" select="/*[1]"/>
                </xsl:call-template>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:param>
    <xsl:param name="xref.label-page.separator">
        <xsl:text> </xsl:text>
    </xsl:param>
    <xsl:param name="xref.label-title.separator">:</xsl:param>
    <xsl:param name="xref.title-page.separator">
        <xsl:text> </xsl:text>
    </xsl:param>
    <xsl:param name="xref.with.number.and.title" select="1"/>
    <xsl:template name="dot.count">
        <!-- Returns the number of "." characters in a string -->
        <xsl:param name="string"/>
        <xsl:param name="count" select="0"/>
        <xsl:choose>
            <xsl:when test="contains($string, '.')">
                <xsl:call-template name="dot.count">
                    <xsl:with-param name="string" select="substring-after($string, '.')"/>
                    <xsl:with-param name="count" select="$count+1"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$count"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="copy-string">
        <!-- returns 'count' copies of 'string' -->
        <xsl:param name="string"/>
        <xsl:param name="count" select="0"/>
        <xsl:param name="result"/>

        <xsl:choose>
            <xsl:when test="$count&gt;0">
                <xsl:call-template name="copy-string">
                    <xsl:with-param name="string" select="$string"/>
                    <xsl:with-param name="count" select="$count - 1"/>
                    <xsl:with-param name="result">
                        <xsl:value-of select="$result"/>
                        <xsl:value-of select="$string"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$result"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="string.subst">
        <xsl:param name="string"/>
        <xsl:param name="target"/>
        <xsl:param name="replacement"/>

        <xsl:choose>
            <xsl:when test="contains($string, $target)">
                <xsl:variable name="rest">
                    <xsl:call-template name="string.subst">
                        <xsl:with-param name="string" select="substring-after($string, $target)"/>
                        <xsl:with-param name="target" select="$target"/>
                        <xsl:with-param name="replacement" select="$replacement"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:value-of
                        select="concat(substring-before($string, $target),                                    $replacement,                                    $rest)"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$string"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="xpointer.idref">
        <xsl:param name="xpointer">http://...</xsl:param>
        <xsl:choose>
            <xsl:when test="starts-with($xpointer, '#xpointer(id(')">
                <xsl:variable name="rest" select="substring-after($xpointer, '#xpointer(id(')"/>
                <xsl:variable name="quote" select="substring($rest, 1, 1)"/>
                <xsl:value-of select="substring-before(substring-after($xpointer, $quote), $quote)"/>
            </xsl:when>
            <xsl:when test="starts-with($xpointer, '#')">
                <xsl:value-of select="substring-after($xpointer, '#')"/>
            </xsl:when>
            <!-- otherwise it's a pointer to some other document -->
        </xsl:choose>
    </xsl:template>
    <xsl:template name="length-magnitude">
        <xsl:param name="length" select="'0pt'"/>

        <xsl:choose>
            <xsl:when test="string-length($length) = 0"/>
            <xsl:when
                    test="substring($length,1,1) = '0'                     or substring($length,1,1) = '1'                     or substring($length,1,1) = '2'                     or substring($length,1,1) = '3'                     or substring($length,1,1) = '4'                     or substring($length,1,1) = '5'                     or substring($length,1,1) = '6'                     or substring($length,1,1) = '7'                     or substring($length,1,1) = '8'                     or substring($length,1,1) = '9'                     or substring($length,1,1) = '.'">
                <xsl:value-of select="substring($length,1,1)"/>
                <xsl:call-template name="length-magnitude">
                    <xsl:with-param name="length" select="substring($length,2)"/>
                </xsl:call-template>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="length-units">
        <xsl:param name="length" select="'0pt'"/>
        <xsl:param name="default.units" select="'px'"/>
        <xsl:variable name="magnitude">
            <xsl:call-template name="length-magnitude">
                <xsl:with-param name="length" select="$length"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="units">
            <xsl:value-of select="substring($length, string-length($magnitude)+1)"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$units = ''">
                <xsl:value-of select="$default.units"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$units"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="length-spec">
        <xsl:param name="length" select="'0pt'"/>
        <xsl:param name="default.units" select="'px'"/>

        <xsl:variable name="magnitude">
            <xsl:call-template name="length-magnitude">
                <xsl:with-param name="length" select="$length"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="units">
            <xsl:value-of select="substring($length, string-length($magnitude)+1)"/>
        </xsl:variable>

        <xsl:value-of select="$magnitude"/>
        <xsl:choose>
            <xsl:when
                    test="$units='cm'                     or $units='mm'                     or $units='in'                     or $units='pt'                     or $units='pc'                     or $units='px'                     or $units='em'">
                <xsl:value-of select="$units"/>
            </xsl:when>
            <xsl:when test="$units = ''">
                <xsl:value-of select="$default.units"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>
                    <xsl:text>Unrecognized unit of measure: </xsl:text>
                    <xsl:value-of select="$units"/>
                    <xsl:text>.</xsl:text>
                </xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="length-in-points">
        <xsl:param name="length" select="'0pt'"/>
        <xsl:param name="em.size" select="10"/>
        <xsl:param name="pixels.per.inch" select="90"/>

        <xsl:variable name="magnitude">
            <xsl:call-template name="length-magnitude">
                <xsl:with-param name="length" select="$length"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="units">
            <xsl:value-of select="substring($length, string-length($magnitude)+1)"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$units = 'pt'">
                <xsl:value-of select="$magnitude"/>
            </xsl:when>
            <xsl:when test="$units = 'cm'">
                <xsl:value-of select="$magnitude div 2.54 * 72.0"/>
            </xsl:when>
            <xsl:when test="$units = 'mm'">
                <xsl:value-of select="$magnitude div 25.4 * 72.0"/>
            </xsl:when>
            <xsl:when test="$units = 'in'">
                <xsl:value-of select="$magnitude * 72.0"/>
            </xsl:when>
            <xsl:when test="$units = 'pc'">
                <xsl:value-of select="$magnitude * 12.0"/>
            </xsl:when>
            <xsl:when test="$units = 'px'">
                <xsl:value-of select="$magnitude div $pixels.per.inch * 72.0"/>
            </xsl:when>
            <xsl:when test="$units = 'em'">
                <xsl:value-of select="$magnitude * $em.size"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>
                    <xsl:text>Unrecognized unit of measure: </xsl:text>
                    <xsl:value-of select="$units"/>
                    <xsl:text>.</xsl:text>
                </xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="pi-attribute">
        <xsl:param name="pis" select="processing-instruction('BOGUS_PI')"/>
        <xsl:param name="attribute">filename</xsl:param>
        <xsl:param name="count">1</xsl:param>

        <xsl:choose>
            <xsl:when test="$count&gt;count($pis)">
                <!-- not found -->
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="pi">
                    <xsl:value-of select="$pis[$count]"/>
                </xsl:variable>
                <xsl:variable name="pivalue">
                    <xsl:value-of select="concat(' ', normalize-space($pi))"/>
                </xsl:variable>
                <xsl:choose>
                    <xsl:when test="contains($pivalue,concat(' ', $attribute, '='))">
                        <xsl:variable name="rest" select="substring-after($pivalue,concat(' ', $attribute,'='))"/>
                        <xsl:variable name="quote" select="substring($rest,1,1)"/>
                        <xsl:value-of select="substring-before(substring($rest,2),$quote)"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="pi-attribute">
                            <xsl:with-param name="pis" select="$pis"/>
                            <xsl:with-param name="attribute" select="$attribute"/>
                            <xsl:with-param name="count" select="$count + 1"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="lookup.key">
        <xsl:param name="key" select="''"/>
        <xsl:param name="table" select="''"/>

        <xsl:if test="contains($table, ' ')">
            <xsl:choose>
                <xsl:when test="substring-before($table, ' ') = $key">
                    <xsl:variable name="rest" select="substring-after($table, ' ')"/>
                    <xsl:choose>
                        <xsl:when test="contains($rest, ' ')">
                            <xsl:value-of select="substring-before($rest, ' ')"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$rest"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="lookup.key">
                        <xsl:with-param name="key" select="$key"/>
                        <xsl:with-param name="table" select="substring-after(substring-after($table,' '), ' ')"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
    </xsl:template>
    <xsl:template name="xpath.location">
        <xsl:param name="node" select="."/>
        <xsl:param name="path" select="''"/>

        <xsl:variable name="next.path">
            <xsl:value-of select="local-name($node)"/>
            <xsl:if test="$path != ''">/</xsl:if>
            <xsl:value-of select="$path"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$node/parent::*">
                <xsl:call-template name="xpath.location">
                    <xsl:with-param name="node" select="$node/parent::*"/>
                    <xsl:with-param name="path" select="$next.path"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>/</xsl:text>
                <xsl:value-of select="$next.path"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="comment-escape-string">
        <xsl:param name="string" select="''"/>

        <xsl:if test="starts-with($string, '-')">
            <xsl:text> </xsl:text>
        </xsl:if>

        <xsl:call-template name="comment-escape-string.recursive">
            <xsl:with-param name="string" select="$string"/>
        </xsl:call-template>

        <xsl:if test="substring($string, string-length($string), 1) = '-'">
            <xsl:text> </xsl:text>
        </xsl:if>
    </xsl:template>
    <xsl:template name="comment-escape-string.recursive">
        <xsl:param name="string" select="''"/>
        <xsl:choose>
            <xsl:when test="contains($string, '--')">
                <xsl:value-of select="substring-before($string, '--')"/>
                <xsl:value-of select="'- -'"/>
                <xsl:call-template name="comment-escape-string.recursive">
                    <xsl:with-param name="string" select="substring-after($string, '--')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$string"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="str.tokenize.keep.delimiters">
        <xsl:param name="string" select="''"/>
        <xsl:param name="delimiters" select="' '"/>
        <xsl:choose>
            <xsl:when test="not($string)"/>
            <xsl:when test="not($delimiters)">
                <xsl:call-template name="str.tokenize.keep.delimiters-characters">
                    <xsl:with-param name="string" select="$string"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="str.tokenize.keep.delimiters-delimiters">
                    <xsl:with-param name="string" select="$string"/>
                    <xsl:with-param name="delimiters" select="$delimiters"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="str.tokenize.keep.delimiters-characters">
        <xsl:param name="string"/>
        <xsl:if test="$string">
            <ssb:token xmlns:ssb="http://sideshowbarker.net/ns">
                <xsl:value-of select="substring($string, 1, 1)"/>
            </ssb:token>
            <xsl:call-template name="str.tokenize.keep.delimiters-characters">
                <xsl:with-param name="string" select="substring($string, 2)"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template name="str.tokenize.keep.delimiters-delimiters">
        <xsl:param name="string"/>
        <xsl:param name="delimiters"/>
        <xsl:variable name="delimiter" select="substring($delimiters, 1, 1)"/>
        <xsl:choose>
            <xsl:when test="not($delimiter)">
                <ssb:token xmlns:ssb="http://sideshowbarker.net/ns">
                    <xsl:value-of select="$string"/>
                </ssb:token>
            </xsl:when>
            <xsl:when test="contains($string, $delimiter)">
                <xsl:if test="not(starts-with($string, $delimiter))">
                    <xsl:call-template name="str.tokenize.keep.delimiters-delimiters">
                        <xsl:with-param name="string" select="substring-before($string, $delimiter)"/>
                        <xsl:with-param name="delimiters" select="substring($delimiters, 2)"/>
                    </xsl:call-template>
                </xsl:if>
                <!-- output each delimiter -->
                <xsl:value-of select="$delimiter"/>
                <xsl:call-template name="str.tokenize.keep.delimiters-delimiters">
                    <xsl:with-param name="string" select="substring-after($string, $delimiter)"/>
                    <xsl:with-param name="delimiters" select="$delimiters"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="str.tokenize.keep.delimiters-delimiters">
                    <xsl:with-param name="string" select="$string"/>
                    <xsl:with-param name="delimiters" select="substring($delimiters, 2)"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="apply-string-subst-map">
        <xsl:param name="content"/>
        <xsl:param name="map.contents"/>
        <xsl:variable name="replaced_text">
            <xsl:call-template name="string.subst">
                <xsl:with-param name="string" select="$content"/>
                <xsl:with-param name="target" select="$map.contents[1]/@oldstring"/>
                <xsl:with-param name="replacement" select="$map.contents[1]/@newstring"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$map.contents[2]">
                <xsl:call-template name="apply-string-subst-map">
                    <xsl:with-param name="content" select="$replaced_text"/>
                    <xsl:with-param name="map.contents" select="$map.contents[position() &gt; 1]"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$replaced_text"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="count.uri.path.depth">
        <xsl:param name="filename" select="''"/>
        <xsl:param name="count" select="0"/>

        <xsl:choose>
            <xsl:when test="contains($filename, '/')">
                <xsl:call-template name="count.uri.path.depth">
                    <xsl:with-param name="filename" select="substring-after($filename, '/')"/>
                    <xsl:with-param name="count" select="$count + 1"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$count"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="trim.common.uri.paths">
        <xsl:param name="uriA" select="''"/>
        <xsl:param name="uriB" select="''"/>
        <xsl:param name="return" select="'A'"/>

        <!-- Resolve any ../ in the path -->
        <xsl:variable name="trimmed.uriA">
            <xsl:call-template name="resolve.path">
                <xsl:with-param name="filename" select="$uriA"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="trimmed.uriB">
            <xsl:call-template name="resolve.path">
                <xsl:with-param name="filename" select="$uriB"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
            <xsl:when
                    test="contains($trimmed.uriA, '/') and contains($trimmed.uriB, '/')                     and substring-before($trimmed.uriA, '/') = substring-before($trimmed.uriB, '/')">
                <xsl:call-template name="trim.common.uri.paths">
                    <xsl:with-param name="uriA" select="substring-after($trimmed.uriA, '/')"/>
                    <xsl:with-param name="uriB" select="substring-after($trimmed.uriB, '/')"/>
                    <xsl:with-param name="return" select="$return"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="$return = 'A'">
                        <xsl:value-of select="$trimmed.uriA"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$trimmed.uriB"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="resolve.path">
        <xsl:param name="filename" select="''"/>
        <xsl:choose>
            <!-- Leading .. are not eliminated -->
            <xsl:when test="starts-with($filename, '../')">
                <xsl:value-of select="'../'"/>
                <xsl:call-template name="resolve.path">
                    <xsl:with-param name="filename" select="substring-after($filename, '../')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="contains($filename, '/../')">
                <xsl:call-template name="resolve.path">
                    <xsl:with-param name="filename">
                        <xsl:call-template name="dirname">
                            <xsl:with-param name="filename" select="substring-before($filename, '/../')"/>
                        </xsl:call-template>
                        <xsl:value-of select="substring-after($filename, '/../')"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$filename"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="dirname">
        <xsl:param name="filename" select="''"/>
        <xsl:if test="contains($filename, '/')">
            <xsl:value-of select="substring-before($filename, '/')"/>
            <xsl:text>/</xsl:text>
            <xsl:call-template name="dirname">
                <xsl:with-param name="filename" select="substring-after($filename, '/')"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template name="trim.text">
        <xsl:param name="contents" select="."/>
        <xsl:variable name="contents-left-trimmed">
            <xsl:call-template name="trim-left">
                <xsl:with-param name="contents" select="$contents"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="contents-trimmed">
            <xsl:call-template name="trim-right">
                <xsl:with-param name="contents" select="$contents-left-trimmed"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="$contents-trimmed"/>
    </xsl:template>
    <xsl:template name="trim-left">
        <xsl:param name="contents"/>
        <xsl:choose>
            <xsl:when
                    test="starts-with($contents,'&#10;') or                       starts-with($contents,'&#13;') or                       starts-with($contents,' ') or                       starts-with($contents,'&#9;')">
                <xsl:call-template name="trim-left">
                    <xsl:with-param name="contents" select="substring($contents, 2)"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$contents"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="trim-right">
        <xsl:param name="contents"/>
        <xsl:variable name="last-char">
            <xsl:value-of select="substring($contents, string-length($contents), 1)"/>
        </xsl:variable>
        <xsl:choose>
            <xsl:when
                    test="($last-char = '&#10;') or                       ($last-char = '&#13;') or                       ($last-char = ' ') or                       ($last-char = '&#9;')">
                <xsl:call-template name="trim-right">
                    <xsl:with-param name="contents" select="substring($contents, 1, string-length($contents) - 1)"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$contents"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="l10n.language">
        <xsl:param name="target" select="."/>
        <xsl:param name="xref-context" select="false()"/>

        <xsl:variable name="mc-language">
            <xsl:choose>
                <xsl:when test="$l10n.gentext.language != ''">
                    <xsl:value-of select="$l10n.gentext.language"/>
                </xsl:when>

                <xsl:when test="$xref-context or $l10n.gentext.use.xref.language != 0">
                    <!-- can't do this one step: attributes are unordered! -->
                    <xsl:variable name="lang-scope"
                                  select="$target/ancestor-or-self::*                               [@lang or @xml:lang][1]"/>
                    <xsl:variable name="lang-attr" select="($lang-scope/@lang | $lang-scope/@xml:lang)[1]"/>
                    <xsl:choose>
                        <xsl:when test="string($lang-attr) = ''">
                            <xsl:value-of select="$l10n.gentext.default.language"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$lang-attr"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>

                <xsl:otherwise>
                    <!-- can't do this one step: attributes are unordered! -->
                    <xsl:variable name="lang-scope"
                                  select="$target/ancestor-or-self::*                               [@lang or @xml:lang][1]"/>
                    <xsl:variable name="lang-attr" select="($lang-scope/@lang | $lang-scope/@xml:lang)[1]"/>

                    <xsl:choose>
                        <xsl:when test="string($lang-attr) = ''">
                            <xsl:value-of select="$l10n.gentext.default.language"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$lang-attr"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="language"
                      select="translate($mc-language,                                         'ABCDEFGHIJKLMNOPQRSTUVWXYZ-',                                         'abcdefghijklmnopqrstuvwxyz_')"/>
    </xsl:template>

    <xsl:template name="l10n.language.name">
        <xsl:text>English</xsl:text>
    </xsl:template>

    <xsl:template name="language.attribute">
        <xsl:param name="node" select="."/>

        <xsl:variable name="language">
            <xsl:choose>
                <xsl:when test="$l10n.gentext.language != ''">
                    <xsl:value-of select="$l10n.gentext.language"/>
                </xsl:when>

                <xsl:otherwise>
                    <!-- can't do this one step: attributes are unordered! -->
                    <xsl:variable name="lang-scope"
                                  select="$node/ancestor-or-self::*                               [@lang or @xml:lang][1]"/>
                    <xsl:variable name="lang-attr" select="($lang-scope/@lang | $lang-scope/@xml:lang)[1]"/>

                    <xsl:choose>
                        <xsl:when test="string($lang-attr) = ''">
                            <xsl:value-of select="$l10n.gentext.default.language"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$lang-attr"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:if test="$language != ''">
            <xsl:attribute name="lang">
                <xsl:choose>
                    <xsl:when test="$l10n.lang.value.rfc.compliant != 0">
                        <xsl:value-of select="translate($language, '_', '-')"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$language"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:attribute>
        </xsl:if>

        <!-- FIXME: This is sort of hack, but it was the easiest way to add at least partial support for dir attribute -->
        <xsl:copy-of select="ancestor-or-self::*[@dir][1]/@dir"/>
    </xsl:template>

    <xsl:template name="xml.language.attribute">
        <xsl:param name="node" select="."/>

        <xsl:variable name="language">
            <xsl:choose>
                <xsl:when test="$l10n.gentext.language != ''">
                    <xsl:value-of select="$l10n.gentext.language"/>
                </xsl:when>

                <xsl:otherwise>
                    <!-- can't do this one step: attributes are unordered! -->
                    <xsl:variable name="lang-scope"
                                  select="$node/ancestor-or-self::*                               [@lang or @xml:lang][1]"/>
                    <xsl:variable name="lang-attr" select="($lang-scope/@lang | $lang-scope/@xml:lang)[1]"/>

                    <xsl:choose>
                        <xsl:when test="string($lang-attr) = ''">
                            <xsl:value-of select="$l10n.gentext.default.language"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$lang-attr"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:if test="$language != ''">
            <xsl:attribute name="xml:lang">
                <xsl:choose>
                    <xsl:when test="$l10n.lang.value.rfc.compliant != 0">
                        <xsl:value-of select="translate($language, '_', '-')"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$language"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:attribute>
        </xsl:if>

        <!-- FIXME: This is sort of hack, but it was the easiest way to add at least partial support for dir attribute -->
        <xsl:copy-of select="ancestor-or-self::*[@dir][1]/@dir"/>
    </xsl:template>

    <xsl:template name="gentext">
        <xsl:param name="key" select="local-name(.)"/>
        <xsl:param name="lang">
            <xsl:call-template name="l10n.language"/>
        </xsl:param>

        <xsl:choose>
            <xsl:when test="$key = 'Abstract'">
                <xsl:text>Abstract</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'abstract'">
                <xsl:text>Abstract</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Acknowledgements'">
                <xsl:text>Acknowledgements</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'acknowledgements'">
                <xsl:text>Acknowledgements</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Answer'">
                <xsl:text>A:</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'answer'">
                <xsl:text>A:</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Appendix'">
                <xsl:text>Appendix</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'appendix'">
                <xsl:text>Appendix</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Article'">
                <xsl:text>Article</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'article'">
                <xsl:text>Article</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Author'">
                <xsl:text>Author</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Bibliography'">
                <xsl:text>Bibliography</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'bibliography'">
                <xsl:text>Bibliography</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Book'">
                <xsl:text>Book</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'book'">
                <xsl:text>Book</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'CAUTION'">
                <xsl:text>CAUTION</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Caution'">
                <xsl:text>Caution</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'caution'">
                <xsl:text>Caution</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Chapter'">
                <xsl:text>Chapter</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'chapter'">
                <xsl:text>Chapter</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Colophon'">
                <xsl:text>Colophon</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'colophon'">
                <xsl:text>Colophon</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Copyright'">
                <xsl:text>Copyright</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'copyright'">
                <xsl:text>Copyright</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Dedication'">
                <xsl:text>Dedication</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'dedication'">
                <xsl:text>Dedication</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Edition'">
                <xsl:text>Edition</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'edition'">
                <xsl:text>Edition</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Editor'">
                <xsl:text>Editor</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Equation'">
                <xsl:text>Equation</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'equation'">
                <xsl:text>Equation</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Example'">
                <xsl:text>Example</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'example'">
                <xsl:text>Example</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Figure'">
                <xsl:text>Figure</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'figure'">
                <xsl:text>Figure</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Glossary'">
                <xsl:text>Glossary</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'glossary'">
                <xsl:text>Glossary</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'GlossSee'">
                <xsl:text>See</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'glosssee'">
                <xsl:text>See</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'GlossSeeAlso'">
                <xsl:text>See Also</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'glossseealso'">
                <xsl:text>See Also</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'IMPORTANT'">
                <xsl:text>IMPORTANT</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'important'">
                <xsl:text>Important</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Important'">
                <xsl:text>Important</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Index'">
                <xsl:text>Index</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'index'">
                <xsl:text>Index</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'ISBN'">
                <xsl:text>ISBN</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'isbn'">
                <xsl:text>ISBN</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'LegalNotice'">
                <xsl:text>Legal Notice</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'legalnotice'">
                <xsl:text>Legal Notice</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'MsgAud'">
                <xsl:text>Audience</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'msgaud'">
                <xsl:text>Audience</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'MsgLevel'">
                <xsl:text>Level</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'msglevel'">
                <xsl:text>Level</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'MsgOrig'">
                <xsl:text>Origin</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'msgorig'">
                <xsl:text>Origin</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'NOTE'">
                <xsl:text>NOTE</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Note'">
                <xsl:text>Note</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'note'">
                <xsl:text>Note</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Part'">
                <xsl:text>Part</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'part'">
                <xsl:text>Part</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Preface'">
                <xsl:text>Preface</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'preface'">
                <xsl:text>Preface</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Procedure'">
                <xsl:text>Procedure</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'procedure'">
                <xsl:text>Procedure</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'ProductionSet'">
                <xsl:text>Production</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'PubDate'">
                <xsl:text>Publication Date</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'pubdate'">
                <xsl:text>Publication date</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Published'">
                <xsl:text>Published</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'published'">
                <xsl:text>Published</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Publisher'">
                <xsl:text>Publisher</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Qandadiv'">
                <xsl:text>Q &amp; A</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'qandadiv'">
                <xsl:text>Q &amp; A</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'QandASet'">
                <xsl:text>Frequently Asked Questions</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Question'">
                <xsl:text>Q:</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'question'">
                <xsl:text>Q:</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'RefEntry'">
                <xsl:text></xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'refentry'">
                <xsl:text></xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Reference'">
                <xsl:text>Reference</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'reference'">
                <xsl:text>Reference</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'References'">
                <xsl:text>References</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'RefName'">
                <xsl:text>Name</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'refname'">
                <xsl:text>Name</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'RefSection'">
                <xsl:text></xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'refsection'">
                <xsl:text></xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'RefSynopsisDiv'">
                <xsl:text>Synopsis</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'refsynopsisdiv'">
                <xsl:text>Synopsis</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'RevHistory'">
                <xsl:text>Revision History</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'revhistory'">
                <xsl:text>Revision History</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'revision'">
                <xsl:text>Revision</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Revision'">
                <xsl:text>Revision</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'sect1'">
                <xsl:text>Section</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'sect2'">
                <xsl:text>Section</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'sect3'">
                <xsl:text>Section</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'sect4'">
                <xsl:text>Section</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'sect5'">
                <xsl:text>Section</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'section'">
                <xsl:text>Section</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Section'">
                <xsl:text>Section</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'see'">
                <xsl:text>see</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'See'">
                <xsl:text>See</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'seealso'">
                <xsl:text>see also</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Seealso'">
                <xsl:text>See also</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'SeeAlso'">
                <xsl:text>See Also</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'set'">
                <xsl:text>Set</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Set'">
                <xsl:text>Set</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'setindex'">
                <xsl:text>Set Index</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'SetIndex'">
                <xsl:text>Set Index</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Sidebar'">
                <xsl:text></xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'sidebar'">
                <xsl:text>sidebar</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'step'">
                <xsl:text>step</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Step'">
                <xsl:text>Step</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'table'">
                <xsl:text>Table</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Table'">
                <xsl:text>Table</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'task'">
                <xsl:text>Task</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Task'">
                <xsl:text>Task</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'tip'">
                <xsl:text>Tip</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'TIP'">
                <xsl:text>TIP</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Tip'">
                <xsl:text>Tip</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Warning'">
                <xsl:text>Warning</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'warning'">
                <xsl:text>Warning</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'WARNING'">
                <xsl:text>WARNING</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'and'">
                <xsl:text>and</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'or'">
                <xsl:text>or</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'by'">
                <xsl:text>by</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Edited'">
                <xsl:text>Edited</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'edited'">
                <xsl:text>Edited</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Editedby'">
                <xsl:text>Edited by</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'editedby'">
                <xsl:text>Edited by</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'in'">
                <xsl:text>in</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'lastlistcomma'">
                <xsl:text>,</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'listcomma'">
                <xsl:text>,</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'notes'">
                <xsl:text>Notes</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Notes'">
                <xsl:text>Notes</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Pgs'">
                <xsl:text>Pgs.</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'pgs'">
                <xsl:text>Pgs.</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Revisedby'">
                <xsl:text>Revised by: </xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'revisedby'">
                <xsl:text>Revised by: </xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'TableNotes'">
                <xsl:text>Notes</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'tablenotes'">
                <xsl:text>Notes</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'TableofContents'">
                <xsl:text>Table of Contents</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'tableofcontents'">
                <xsl:text>Table of Contents</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'unexpectedelementname'">
                <xsl:text>Unexpected element name</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'unsupported'">
                <xsl:text>unsupported</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'xrefto'">
                <xsl:text>xref to</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Authors'">
                <xsl:text>Authors</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'copyeditor'">
                <xsl:text>Copy Editor</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'graphicdesigner'">
                <xsl:text>Graphic Designer</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'productioneditor'">
                <xsl:text>Production Editor</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'technicaleditor'">
                <xsl:text>Technical Editor</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'translator'">
                <xsl:text>Translator</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'listofequations'">
                <xsl:text>List of Equations</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'ListofEquations'">
                <xsl:text>List of Equations</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'ListofExamples'">
                <xsl:text>List of Examples</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'listofexamples'">
                <xsl:text>List of Examples</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'ListofFigures'">
                <xsl:text>List of Figures</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'listoffigures'">
                <xsl:text>List of Figures</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'ListofProcedures'">
                <xsl:text>List of Procedures</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'listofprocedures'">
                <xsl:text>List of Procedures</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'listoftables'">
                <xsl:text>List of Tables</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'ListofTables'">
                <xsl:text>List of Tables</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'ListofUnknown'">
                <xsl:text>List of Unknown</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'listofunknown'">
                <xsl:text>List of Unknown</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'nav-home'">
                <xsl:text>Home</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'nav-next'">
                <xsl:text>Next</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'nav-next-sibling'">
                <xsl:text>Fast Forward</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'nav-prev'">
                <xsl:text>Prev</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'nav-prev-sibling'">
                <xsl:text>Fast Backward</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'nav-up'">
                <xsl:text>Up</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'nav-toc'">
                <xsl:text>ToC</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'Draft'">
                <xsl:text>Draft</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'above'">
                <xsl:text>above</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'below'">
                <xsl:text>below</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'sectioncalled'">
                <xsl:text>the section called</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'index symbols'">
                <xsl:text>Symbols</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'writing-mode'">
                <xsl:text>lr-tb</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'lowercase.alpha'">
                <xsl:text>abcdefghijklmnopqrstuvwxyz</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'uppercase.alpha'">
                <xsl:text>ABCDEFGHIJKLMNOPQRSTUVWXYZ</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'normalize.sort.input'">
                <xsl:text>AaÀàÁáÂâÃãÄäÅåĀāĂăĄąǍǎǞǟǠǡǺǻȀȁȂȃȦȧḀḁẚẠạẢảẤấẦầẨẩẪẫẬậẮắẰằẲẳẴẵẶặBbƀƁɓƂƃḂḃḄḅḆḇCcÇçĆćĈĉĊċČčƇƈɕḈḉDdĎďĐđƊɗƋƌǅǲȡɖḊḋḌḍḎḏḐḑḒḓEeÈèÉéÊêËëĒēĔĕĖėĘęĚěȄȅȆȇȨȩḔḕḖḗḘḙḚḛḜḝẸẹẺẻẼẽẾếỀềỂểỄễỆệFfƑƒḞḟGgĜĝĞğĠġĢģƓɠǤǥǦǧǴǵḠḡHhĤĥĦħȞȟɦḢḣḤḥḦḧḨḩḪḫẖIiÌìÍíÎîÏïĨĩĪīĬĭĮįİƗɨǏǐȈȉȊȋḬḭḮḯỈỉỊịJjĴĵǰʝKkĶķƘƙǨǩḰḱḲḳḴḵLlĹĺĻļĽľĿŀŁłƚǈȴɫɬɭḶḷḸḹḺḻḼḽMmɱḾḿṀṁṂṃNnÑñŃńŅņŇňƝɲƞȠǋǸǹȵɳṄṅṆṇṈṉṊṋOoÒòÓóÔôÕõÖöØøŌōŎŏŐőƟƠơǑǒǪǫǬǭǾǿȌȍȎȏȪȫȬȭȮȯȰȱṌṍṎṏṐṑṒṓỌọỎỏỐốỒồỔổỖỗỘộỚớỜờỞởỠỡỢợPpƤƥṔṕṖṗQqʠRrŔŕŖŗŘřȐȑȒȓɼɽɾṘṙṚṛṜṝṞṟSsŚśŜŝŞşŠšȘșʂṠṡṢṣṤṥṦṧṨṩTtŢţŤťŦŧƫƬƭƮʈȚțȶṪṫṬṭṮṯṰṱẗUuÙùÚúÛûÜüŨũŪūŬŭŮůŰűŲųƯưǓǔǕǖǗǘǙǚǛǜȔȕȖȗṲṳṴṵṶṷṸṹṺṻỤụỦủỨứỪừỬửỮữỰựVvƲʋṼṽṾṿWwŴŵẀẁẂẃẄẅẆẇẈẉẘXxẊẋẌẍYyÝýÿŸŶŷƳƴȲȳẎẏẙỲỳỴỵỶỷỸỹZzŹźŻżŽžƵƶȤȥʐʑẐẑẒẓẔẕẕ</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'normalize.sort.output'">
                <xsl:text>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'hyphenation-character'">
                <xsl:text>-</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'hyphenation-push-character-count'">2</xsl:when>
            <xsl:when test="$key = 'hyphenation-remain-character-count'">2</xsl:when>
            <xsl:otherwise/>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="gentext.element.name">
        <xsl:param name="element.name" select="local-name(.)"/>
        <xsl:param name="lang">
            <xsl:call-template name="l10n.language"/>
        </xsl:param>

        <xsl:call-template name="gentext">
            <xsl:with-param name="key" select="$element.name"/>
            <xsl:with-param name="lang" select="$lang"/>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="gentext.space">
        <xsl:text> </xsl:text>
    </xsl:template>

    <xsl:template name="gentext.edited.by">
        <xsl:call-template name="gentext">
            <xsl:with-param name="key" select="'Editedby'"/>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="gentext.by">
        <xsl:call-template name="gentext">
            <xsl:with-param name="key" select="'by'"/>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="gentext.dingbat">
        <xsl:param name="dingbat">bullet</xsl:param>
        <xsl:param name="lang">
            <xsl:call-template name="l10n.language"/>
        </xsl:param>

        <xsl:choose>
            <xsl:when test="$key = 'startquote'">
                <xsl:text>“</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'endquote'">
                <xsl:text>”</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'nestedstartquote'">
                <xsl:text>‘</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'nestedendquote'">
                <xsl:text>’</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'singlestartquote'">
                <xsl:text>‘</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'singleendquote'">
                <xsl:text>’</xsl:text>
            </xsl:when>
            <xsl:when test="$key = 'bullet'">
                <xsl:text>•</xsl:text>
            </xsl:when>
            <xsl:otherwise/>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="gentext.startquote">
        <xsl:call-template name="gentext.dingbat">
            <xsl:with-param name="dingbat">startquote</xsl:with-param>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="gentext.endquote">
        <xsl:call-template name="gentext.dingbat">
            <xsl:with-param name="dingbat">endquote</xsl:with-param>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="gentext.nestedstartquote">
        <xsl:call-template name="gentext.dingbat">
            <xsl:with-param name="dingbat">nestedstartquote</xsl:with-param>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="gentext.nestedendquote">
        <xsl:call-template name="gentext.dingbat">
            <xsl:with-param name="dingbat">nestedendquote</xsl:with-param>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="gentext.nav.prev">
        <xsl:call-template name="gentext">
            <xsl:with-param name="key" select="'nav-prev'"/>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="gentext.nav.next">
        <xsl:call-template name="gentext">
            <xsl:with-param name="key" select="'nav-next'"/>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="gentext.nav.home">
        <xsl:call-template name="gentext">
            <xsl:with-param name="key" select="'nav-home'"/>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="gentext.nav.up">
        <xsl:call-template name="gentext">
            <xsl:with-param name="key" select="'nav-up'"/>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="gentext.template">
        <xsl:param name="context" select="'default'"/>
        <xsl:param name="name" select="'default'"/>
        <xsl:param name="origname" select="$name"/>
        <xsl:param name="purpose"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="referrer"/>
        <xsl:param name="lang">
            <xsl:call-template name="l10n.language"/>
        </xsl:param>
        <xsl:param name="verbose" select="1"/>

        <xsl:choose>
            <!-- keycap context -->
            <xsl:when test="$context = 'keycap' and $name = 'alt'">Alt</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'backspace'">&lt;—</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'command'">⌘</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'control'">Ctrl</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'delete'">Del</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'down'">↓</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'end'">End</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'enter'">Enter</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'escape'">Esc</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'home'">Home</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'insert'">Ins</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'left'">←</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'meta'">Meta</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'option'">???</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'pagedown'">Page ↓</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'pageup'">Page ↑</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'right'">→</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'shift'">Shift</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'space'">Space</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'tab'">→|</xsl:when>
            <xsl:when test="$context = 'keycap' and $name = 'up'">↑</xsl:when>

            <!-- webhelp context -->
            <xsl:when test="$context = 'webhelp' and $name = 'Search'">Search</xsl:when>
            <xsl:when test="$context = 'webhelp' and $name = 'Enter_a_term_and_click'">Enter a term and click</xsl:when>
            <xsl:when test="$context = 'webhelp' and $name = 'Go'">Go</xsl:when>
            <xsl:when test="$context = 'webhelp' and $name = 'to_perform_a_search'">to perform a search.</xsl:when>
            <xsl:when test="$context = 'webhelp' and $name = 'txt_filesfound'">Results</xsl:when>
            <xsl:when test="$context = 'webhelp' and $name = 'txt_enter_at_least_1_char'">You must enter at least one
                character.
            </xsl:when>
            <xsl:when test="$context = 'webhelp' and $name = 'txt_browser_not_supported'">JavaScript is disabled on your
                browser. Please enable JavaScript to enjoy all the features of this site.
            </xsl:when>
            <xsl:when test="$context = 'webhelp' and $name = 'txt_please_wait'">Please wait. Search in progress...
            </xsl:when>
            <xsl:when test="$context = 'webhelp' and $name = 'txt_results_for'">Results for:</xsl:when>
            <xsl:when test="$context = 'webhelp' and $name = 'TableofContents'">Contents</xsl:when>
            <xsl:when test="$context = 'webhelp' and $name = 'HighlightButton'">Toggle search result highlighting
            </xsl:when>
            <xsl:when test="$context = 'webhelp' and $name = 'Your_search_returned_no_results'">Your search returned no
                results.
            </xsl:when>

            <!-- styles context -->
            <xsl:when test="$context = 'styles' and $name = 'person-name'">first-last</xsl:when>

            <!-- title context -->
            <xsl:when test="$context = 'title' and $name = 'abstract'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'acknowledgements'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'answer'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'appendix'">Appendix %n. %t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'article'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'authorblurb'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'bibliodiv'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'biblioentry'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'bibliography'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'bibliolist'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'bibliomixed'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'bibliomset'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'biblioset'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'blockquote'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'book'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'calloutlist'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'caution'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'chapter'">Chapter %n. %t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'colophon'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'dedication'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'equation'">Equation %n. %t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'example'">Example %n. %t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'figure'">Figure %n. %t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'foil'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'foilgroup'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'formalpara'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'glossary'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'glossdiv'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'glosslist'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'glossentry'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'important'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'index'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'indexdiv'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'itemizedlist'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'legalnotice'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'listitem'"></xsl:when>
            <xsl:when test="$context = 'title' and $name = 'lot'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'msg'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'msgexplan'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'msgmain'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'msgrel'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'msgset'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'msgsub'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'note'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'orderedlist'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'part'">Part %n. %t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'partintro'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'preface'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'procedure'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'procedure.formal'">Procedure %n. %t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'productionset'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'productionset.formal'">Production %n</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'qandadiv'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'qandaentry'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'qandaset'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'question'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'refentry'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'reference'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'refsection'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'refsect1'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'refsect2'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'refsect3'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'refsynopsisdiv'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'refsynopsisdivinfo'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'screenshot'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'segmentedlist'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'set'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'setindex'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'sidebar'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'step'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'table'">Table %n. %t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'task'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'tasksummary'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'taskprerequisites'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'taskrelated'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'tip'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'toc'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'variablelist'">%t</xsl:when>
            <xsl:when test="$context = 'title' and $name = 'varlistentry'"></xsl:when>
            <xsl:when test="$context = 'title' and $name = 'warning'">%t</xsl:when>

            <!-- title-unnumbered context -->
            <xsl:when test="$context = 'title-unnumbered' and $name = 'appendix'">%t</xsl:when>
            <xsl:when test="$context = 'title-unnumbered' and $name = 'article/appendix'">%t</xsl:when>
            <xsl:when test="$context = 'title-unnumbered' and $name = 'bridgehead'">%t</xsl:when>
            <xsl:when test="$context = 'title-unnumbered' and $name = 'chapter'">%t</xsl:when>
            <xsl:when test="$context = 'title-unnumbered' and $name = 'sect1'">%t</xsl:when>
            <xsl:when test="$context = 'title-unnumbered' and $name = 'sect2'">%t</xsl:when>
            <xsl:when test="$context = 'title-unnumbered' and $name = 'sect3'">%t</xsl:when>
            <xsl:when test="$context = 'title-unnumbered' and $name = 'sect4'">%t</xsl:when>
            <xsl:when test="$context = 'title-unnumbered' and $name = 'sect5'">%t</xsl:when>
            <xsl:when test="$context = 'title-unnumbered' and $name = 'section'">%t</xsl:when>
            <xsl:when test="$context = 'title-unnumbered' and $name = 'simplesect'">%t</xsl:when>
            <xsl:when test="$context = 'title-unnumbered' and $name = 'topic'">%t</xsl:when>
            <xsl:when test="$context = 'title-unnumbered' and $name = 'part'">%t</xsl:when>

            <!-- title-numbered context -->
            <xsl:when test="$context = 'title-numbered' and $name = 'appendix'">Appendix %n. %t</xsl:when>
            <xsl:when test="$context = 'title-numbered' and $name = 'article/appendix'">%n. %t</xsl:when>
            <xsl:when test="$context = 'title-numbered' and $name = 'bridgehead'">%n. %t</xsl:when>
            <xsl:when test="$context = 'title-numbered' and $name = 'chapter'">Chapter %n. %t</xsl:when>
            <xsl:when test="$context = 'title-numbered' and $name = 'part'">Part %n. %t</xsl:when>
            <xsl:when test="$context = 'title-numbered' and $name = 'sect1'">%n. %t</xsl:when>
            <xsl:when test="$context = 'title-numbered' and $name = 'sect2'">%n. %t</xsl:when>
            <xsl:when test="$context = 'title-numbered' and $name = 'sect3'">%n. %t</xsl:when>
            <xsl:when test="$context = 'title-numbered' and $name = 'sect4'">%n. %t</xsl:when>
            <xsl:when test="$context = 'title-numbered' and $name = 'sect5'">%n. %t</xsl:when>
            <xsl:when test="$context = 'title-numbered' and $name = 'section'">%n. %t</xsl:when>
            <xsl:when test="$context = 'title-numbered' and $name = 'simplesect'">%t</xsl:when>
            <xsl:when test="$context = 'title-numbered' and $name = 'topic'">%t</xsl:when>

            <!-- subtitle context-->
            <xsl:when test="$context = 'subtitle' and $name = 'appendix'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'acknowledgements'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'article'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'bibliodiv'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'biblioentry'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'bibliography'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'bibliomixed'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'bibliomset'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'biblioset'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'book'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'chapter'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'colophon'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'dedication'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'glossary'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'glossdiv'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'index'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'indexdiv'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'lot'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'part'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'partintro'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'preface'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'refentry'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'reference'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'refsection'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'refsect1'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'refsect2'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'refsect3'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'refsynopsisdiv'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'sect1'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'sect2'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'sect3'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'sect4'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'sect5'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'section'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'set'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'setindex'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'sidebar'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'simplesect'">%s</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'topic'">%t</xsl:when>
            <xsl:when test="$context = 'subtitle' and $name = 'toc'">%s</xsl:when>

            <!-- xref context -->
            <xsl:when test="$context = 'xref' and $name = 'abstract'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'acknowledgements'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'answer'">A: %n</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'appendix'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'article'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'authorblurb'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'bibliodiv'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'bibliography'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'bibliomset'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'biblioset'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'blockquote'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'book'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'calloutlist'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'caution'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'chapter'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'colophon'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'constraintdef'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'dedication'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'equation'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'example'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'figure'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'foil'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'foilgroup'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'formalpara'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'glossary'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'glossdiv'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'important'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'index'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'indexdiv'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'itemizedlist'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'legalnotice'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'listitem'">%n</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'lot'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'msg'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'msgexplan'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'msgmain'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'msgrel'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'msgset'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'msgsub'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'note'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'orderedlist'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'part'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'partintro'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'preface'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'procedure'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'productionset'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'qandadiv'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'qandaentry'">Q: %n</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'qandaset'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'question'">Q: %n</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'reference'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'refsynopsisdiv'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'screenshot'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'segmentedlist'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'set'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'setindex'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'sidebar'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'table'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'task'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'tip'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'toc'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'variablelist'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'varlistentry'">%n</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'warning'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'olink.document.citation'">in %o</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'olink.page.citation'">(page %p)</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'page.citation'">[%p]</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'page'">(page %p)</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'docname'">in %o</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'docnamelong'">in the document titled %o</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'pageabbrev'">(p. %p)</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'Page'">Page %p</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'topic'">%t</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'bridgehead'">the section called “%t”</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'refsection'">the section called “%t”</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'refsect1'">the section called “%t”</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'refsect2'">the section called “%t”</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'refsect3'">the section called “%t”</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'sect1'">the section called “%t”</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'sect2'">the section called “%t”</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'sect3'">the section called “%t”</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'sect4'">the section called “%t”</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'sect5'">the section called “%t”</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'section'">the section called “%t”</xsl:when>
            <xsl:when test="$context = 'xref' and $name = 'simplesect'">the section called “%t”</xsl:when>

            <!-- xref-number context -->
            <xsl:when test="$context = 'xref-number' and $name = 'answer'">A: %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'appendix'">Appendix %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'bridgehead'">Section %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'chapter'">Chapter %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'equation'">Equation %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'example'">Example %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'figure'">Figure %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'part'">Part %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'procedure'">Procedure %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'productionset'">Production %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'qandadiv'">Q &amp; A %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'qandaentry'">Q: %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'question'">Q: %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'sect1'">Section %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'sect2'">Section %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'sect3'">Section %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'sect4'">Section %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'sect5'">Section %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'section'">Section %n</xsl:when>
            <xsl:when test="$context = 'xref-number' and $name = 'table'">Table %n</xsl:when>

            <!-- xref-number-and-title context -->
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'appendix'">Appendix %n, %t</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'bridgehead'">Section %n, “%t”</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'chapter'">Chapter %n, %t</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'equation'">Equation %n, “%t”</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'example'">Example %n, “%t”</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'figure'">Figure %n, “%t”</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'part'">Part %n, “%t”</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'procedure'">Procedure %n, “%t”</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'productionset'">Production %n, “%t”
            </xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'qandadiv'">Q &amp; A %n, “%t”</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'refsect1'">the section called “%t”
            </xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'refsect2'">the section called “%t”
            </xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'refsect3'">the section called “%t”
            </xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'refsection'">the section called “%t”
            </xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'sect1'">Section %n, “%t”</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'sect2'">Section %n, “%t”</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'sect3'">Section %n, “%t”</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'sect4'">Section %n, “%t”</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'sect5'">Section %n, “%t”</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'section'">Section %n, “%t”</xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'simplesect'">the section called “%t”
            </xsl:when>
            <xsl:when test="$context = 'xref-number-and-title' and $name = 'table'">Table %n, “%t”</xsl:when>

            <!-- authorgroup context -->
            <xsl:when test="$context = 'authorgroup' and $name = 'sep'">,</xsl:when>
            <xsl:when test="$context = 'authorgroup' and $name = 'sep2'">and</xsl:when>
            <xsl:when test="$context = 'authorgroup' and $name = 'seplast'">, and</xsl:when>

            <!-- glossary context -->
            <xsl:when test="$context = 'glossary' and $name = 'see'">See %t.</xsl:when>
            <xsl:when test="$context = 'glossary' and $name = 'seealso'">See Also %t.</xsl:when>
            <xsl:when test="$context = 'glossary' and $name = 'seealso-separator'">,</xsl:when>

            <!-- msgset context -->
            <xsl:when test="$context = 'msgset' and $name = 'MsgAud'">Audience:</xsl:when>
            <xsl:when test="$context = 'msgset' and $name = 'MsgLevel'">Level:</xsl:when>
            <xsl:when test="$context = 'msgset' and $name = 'MsgOrig'">Origin:</xsl:when>

            <!-- datetime context -->
            <xsl:when test="$context = 'datetime' and $name = 'format'">m/d/Y</xsl:when>

            <!-- termdef context -->
            <xsl:when test="$context = 'termdef' and $name = 'prefix'">[Definition:</xsl:when>
            <xsl:when test="$context = 'termdef' and $name = 'suffix'">]</xsl:when>

            <!-- datetime-full context -->
            <xsl:when test="$context = 'datetime-full' and $name = 'January'">January</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'February'">February</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'March'">March</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'April'">April</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'May'">May</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'June'">June</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'July'">July</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'August'">August</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'September'">September</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'October'">October</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'November'">November</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'December'">December</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'Monday'">Monday</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'Tuesday'">Tuesday</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'Wednesday'">Wednesday</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'Thursday'">Thursday</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'Friday'">Friday</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'Saturday'">Saturday</xsl:when>
            <xsl:when test="$context = 'datetime-full' and $name = 'Sunday'">Sunday</xsl:when>

            <!-- datetime-abbrev context -->
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Jan'">Jan</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Feb'">Feb</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Mar'">Mar</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Apr'">Apr</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'May'">May</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Jun'">Jun</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Jul'">Jul</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Aug'">Aug</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Sep'">Sep</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Oct'">Oct</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Nov'">Nov</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Dec'">Dec</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Mon'">Mon</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Tue'">Tue</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Wed'">Wed</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Thu'">Thu</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Fri'">Fri</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Sat'">Sat</xsl:when>
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'Sun'">Sun</xsl:when>

            <!-- htmlhelp context -->
            <xsl:when test="$context = 'datetime-abbrev' and $name = 'langcode'">0x0409 English (UNITED STATES)
            </xsl:when>

            <!-- index context -->
            <xsl:when test="$context = 'index' and $name = 'term-separator'">,</xsl:when>
            <xsl:when test="$context = 'index' and $name = 'number-separator'">,</xsl:when>
            <xsl:when test="$context = 'index' and $name = 'range-separator'">-</xsl:when>

            <!-- iso690 context -->
            <xsl:when test="$context = 'iso960' and $name = 'lastfirst.sep'">,</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'alt.person.two.sep'">–</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'alt.person.last.sep'">–</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'alt.person.more.sep'">–</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'primary.editor'">(ed.)</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'primary.many'">, et al.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'primary.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'submaintitle.sep'">:</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'title.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'othertitle.sep'">,</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'medium1'">[</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'medium2'">]</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'secondary.person.sep'">;</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'secondary.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'respons.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'edition.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'edition.serial.sep'">,</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'issuing.range'">-</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'issuing.div'">,</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'issuing.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'partnr.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'placepubl.sep'">:</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'publyear.sep'">,</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'pubinfo.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'spec.pubinfo.sep'">,</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'upd.sep'">,</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'datecit1'">[cited</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'datecit2'">]</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'extent.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'locs.sep'">,</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'location.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'serie.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'notice.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'access'">Available</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'acctoo'">Also available</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'onwww'">from World Wide Web</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'oninet'">from Internet</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'access.end'">:</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'link1'">&lt;</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'link2'">&gt;</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'access.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'isbn'">ISBN</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'issn'">ISSN</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'stdnum.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'patcountry.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'pattype.sep'">,</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'patnum.sep'">.</xsl:when>
            <xsl:when test="$context = 'iso960' and $name = 'patdate.sep'">.</xsl:when>

            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="contains($name, '/')">
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="context" select="$context"/>
                            <xsl:with-param name="name" select="substring-after($name, '/')"/>
                            <xsl:with-param name="origname" select="$origname"/>
                            <xsl:with-param name="purpose" select="$purpose"/>
                            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                            <xsl:with-param name="referrer" select="$referrer"/>
                            <xsl:with-param name="lang" select="$lang"/>
                            <xsl:with-param name="verbose" select="$verbose"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:when test="$verbose = 0">
                        <!-- silence -->
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message>
                            <xsl:text>No template for "</xsl:text>
                            <xsl:value-of select="$origname"/>
                            <xsl:text>" (or any of its leaves) exists in the context named "</xsl:text>
                            <xsl:value-of select="$context"/>
                            <xsl:text>" in the "</xsl:text>
                            <xsl:value-of select="$lang"/>
                            <xsl:text>" localization.</xsl:text>
                        </xsl:message>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="gentext.template.exists">
        <xsl:param name="context" select="'default'"/>
        <xsl:param name="name" select="'default'"/>
        <xsl:param name="origname" select="$name"/>
        <xsl:param name="purpose"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="referrer"/>
        <xsl:param name="lang">
            <xsl:call-template name="l10n.language"/>
        </xsl:param>

        <xsl:variable name="template">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="$context"/>
                <xsl:with-param name="name" select="$name"/>
                <xsl:with-param name="origname" select="$origname"/>
                <xsl:with-param name="purpose" select="$purpose"/>
                <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                <xsl:with-param name="referrer" select="$referrer"/>
                <xsl:with-param name="lang" select="$lang"/>
                <xsl:with-param name="verbose" select="0"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="string-length($template) != 0">1</xsl:when>
            <xsl:otherwise>0</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:reference xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" xml:id="base">
        <info>
            <title>Common » Base Template Reference</title>
            <releaseinfo role="meta">
                $Id: common.xsl 9347 2012-05-11 03:49:49Z bobstayton $
            </releaseinfo>
        </info>
        <!-- * yes, partintro is a valid child of a reference... -->
        <partintro xml:id="partintro">
            <title>Introduction</title>
            <para>This is technical reference documentation for the “base”
                set of common templates in the DocBook XSL Stylesheets.
            </para>
            <para>This is not intended to be user documentation. It is
                provided for developers writing customization layers for the
                stylesheets.
            </para>
        </partintro>
    </doc:reference>
    <xsl:preserve-space elements="*"/>
    <xsl:strip-space
            elements=" abstract affiliation anchor answer appendix area areaset areaspec artheader article audiodata audioobject author authorblurb authorgroup beginpage bibliodiv biblioentry bibliography biblioset blockquote book bookinfo callout calloutlist caption caution chapter citerefentry cmdsynopsis co collab colophon colspec confgroup copyright dedication docinfo editor entrytbl epigraph equation example figure footnote footnoteref formalpara funcprototype funcsynopsis glossary glossdef glossdiv glossentry glosslist graphicco group highlights imagedata imageobject imageobjectco important index indexdiv indexentry indexterm info informalequation informalexample informalfigure informaltable inlineequation inlinemediaobject itemizedlist itermset keycombo keywordset legalnotice listitem lot mediaobject mediaobjectco menuchoice msg msgentry msgexplan msginfo msgmain msgrel msgset msgsub msgtext note objectinfo orderedlist othercredit part partintro preface printhistory procedure programlistingco publisher qandadiv qandaentry qandaset question refentry reference refmeta refnamediv refsection refsect1 refsect1info refsect2 refsect2info refsect3 refsect3info refsynopsisdiv refsynopsisdivinfo revhistory revision row sbr screenco screenshot sect1 sect1info sect2 sect2info sect3 sect3info sect4 sect4info sect5 sect5info section sectioninfo seglistitem segmentedlist seriesinfo set setindex setinfo shortcut sidebar simplelist simplesect spanspec step subject subjectset substeps synopfragment table tbody textobject tfoot tgroup thead tip toc tocchap toclevel1 toclevel2 toclevel3 toclevel4 toclevel5 tocpart topic varargs variablelist varlistentry videodata videoobject void warning subjectset  classsynopsis constructorsynopsis destructorsynopsis fieldsynopsis methodparam methodsynopsis ooclass ooexception oointerface simplemsgentry manvolnum "/>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="is.component">
        <refpurpose>Tests if a given node is a component-level element</refpurpose>

        <refdescription id="is.component-desc">
            <para>This template returns '1' if the specified node is a component
                (Chapter, Appendix, etc.), and '0' otherwise.
            </para>
        </refdescription>

        <refparameter id="is.component-params">
            <variablelist>
                <varlistentry>
                    <term>node</term>
                    <listitem>
                        <para>The node which is to be tested.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>

        <refreturn id="is.component-returns">
            <para>This template returns '1' if the specified node is a component
                (Chapter, Appendix, etc.), and '0' otherwise.
            </para>
        </refreturn>
    </doc:template>
    <xsl:template name="is.component">
        <xsl:param name="node" select="."/>
        <xsl:choose>
            <xsl:when
                    test="local-name($node) = 'appendix'                     or local-name($node) = 'article'                     or local-name($node) = 'chapter'                     or local-name($node) = 'preface'                     or local-name($node) = 'bibliography'                     or local-name($node) = 'glossary'                     or local-name($node) = 'index'">
                1
            </xsl:when>
            <xsl:otherwise>0</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="is.section">
        <refpurpose>Tests if a given node is a section-level element</refpurpose>

        <refdescription id="is.section-desc">
            <para>This template returns '1' if the specified node is a section
                (Section, Sect1, Sect2, etc.), and '0' otherwise.
            </para>
        </refdescription>

        <refparameter id="is.section-params">
            <variablelist>
                <varlistentry>
                    <term>node</term>
                    <listitem>
                        <para>The node which is to be tested.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>

        <refreturn id="is.section-returns">
            <para>This template returns '1' if the specified node is a section
                (Section, Sect1, Sect2, etc.), and '0' otherwise.
            </para>
        </refreturn>
    </doc:template>
    <xsl:template name="is.section">
        <xsl:param name="node" select="."/>
        <xsl:choose>
            <xsl:when
                    test="local-name($node) = 'section'                     or local-name($node) = 'sect1'                     or local-name($node) = 'sect2'                     or local-name($node) = 'sect3'                     or local-name($node) = 'sect4'                     or local-name($node) = 'sect5'                     or local-name($node) = 'refsect1'                     or local-name($node) = 'refsect2'                     or local-name($node) = 'refsect3'                     or local-name($node) = 'simplesect'">
                1
            </xsl:when>
            <xsl:otherwise>0</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="section.level">
        <refpurpose>Returns the hierarchical level of a section</refpurpose>

        <refdescription id="section.level-desc">
            <para>This template calculates the hierarchical level of a section.
                The element
                <tag>sect1</tag>
                is at level 1,
                <tag>sect2</tag>
                is
                at level 2, etc.
            </para>

            <para>Recursive sections are calculated down to the fifth level.</para>
        </refdescription>

        <refparameter id="section.level-params">
            <variablelist>
                <varlistentry>
                    <term>node</term>
                    <listitem>
                        <para>The section node for which the level should be calculated.
                            Defaults to the context node.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>

        <refreturn id="section.level-returns">
            <para>The section level,<quote>1</quote>,<quote>2</quote>, etc.
            </para>
        </refreturn>
    </doc:template>
    <xsl:template name="section.level">
        <xsl:param name="node" select="."/>
        <xsl:choose>
            <xsl:when test="local-name($node)='sect1'">1</xsl:when>
            <xsl:when test="local-name($node)='sect2'">2</xsl:when>
            <xsl:when test="local-name($node)='sect3'">3</xsl:when>
            <xsl:when test="local-name($node)='sect4'">4</xsl:when>
            <xsl:when test="local-name($node)='sect5'">5</xsl:when>
            <xsl:when test="local-name($node)='section'">
                <xsl:choose>
                    <xsl:when test="$node/../../../../../../section">6</xsl:when>
                    <xsl:when test="$node/../../../../../section">5</xsl:when>
                    <xsl:when test="$node/../../../../section">4</xsl:when>
                    <xsl:when test="$node/../../../section">3</xsl:when>
                    <xsl:when test="$node/../../section">2</xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when
                    test="local-name($node)='refsect1' or                     local-name($node)='refsect2' or                     local-name($node)='refsect3' or                     local-name($node)='refsection' or                     local-name($node)='refsynopsisdiv'">
                <xsl:call-template name="refentry.section.level">
                    <xsl:with-param name="node" select="$node"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="local-name($node)='simplesect'">
                <xsl:choose>
                    <xsl:when test="$node/../../sect1">2</xsl:when>
                    <xsl:when test="$node/../../sect2">3</xsl:when>
                    <xsl:when test="$node/../../sect3">4</xsl:when>
                    <xsl:when test="$node/../../sect4">5</xsl:when>
                    <xsl:when test="$node/../../sect5">5</xsl:when>
                    <xsl:when test="$node/../../section">
                        <xsl:choose>
                            <xsl:when test="$node/../../../../../section">5</xsl:when>
                            <xsl:when test="$node/../../../../section">4</xsl:when>
                            <xsl:when test="$node/../../../section">3</xsl:when>
                            <xsl:otherwise>2</xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="qanda.section.level">
        <refpurpose>Returns the hierarchical level of a QandASet</refpurpose>

        <refdescription id="qanda.section.level-desc">
            <para>This template calculates the hierarchical level of a QandASet.
            </para>
        </refdescription>

        <refreturn id="qanda.section.level-returns">
            <para>The level,<quote>1</quote>,<quote>2</quote>, etc.
            </para>
        </refreturn>
    </doc:template>
    <xsl:template name="qanda.section.level">
        <xsl:variable name="section"
                      select="(ancestor::section                          |ancestor::simplesect                          |ancestor::sect5                          |ancestor::sect4                          |ancestor::sect3                          |ancestor::sect2                          |ancestor::sect1                          |ancestor::refsect3                          |ancestor::refsect2                          |ancestor::refsect1)[last()]"/>

        <xsl:choose>
            <xsl:when test="count($section) = '0'">1</xsl:when>
            <xsl:otherwise>
                <xsl:variable name="slevel">
                    <xsl:call-template name="section.level">
                        <xsl:with-param name="node" select="$section"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:value-of select="$slevel + 1"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="refentry.section.level">
        <xsl:param name="node" select="."/>

        <xsl:variable name="RElevel">
            <xsl:call-template name="refentry.level">
                <xsl:with-param name="node" select="$node/ancestor::refentry[1]"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="levelinRE">
            <xsl:choose>
                <xsl:when test="local-name($node)='refsynopsisdiv'">1</xsl:when>
                <xsl:when test="local-name($node)='refsect1'">1</xsl:when>
                <xsl:when test="local-name($node)='refsect2'">2</xsl:when>
                <xsl:when test="local-name($node)='refsect3'">3</xsl:when>
                <xsl:when test="local-name($node)='refsection'">
                    <xsl:choose>
                        <xsl:when test="$node/../../../../../refsection">5</xsl:when>
                        <xsl:when test="$node/../../../../refsection">4</xsl:when>
                        <xsl:when test="$node/../../../refsection">3</xsl:when>
                        <xsl:when test="$node/../../refsection">2</xsl:when>
                        <xsl:otherwise>1</xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:value-of select="$levelinRE + $RElevel"/>
    </xsl:template>
    <xsl:template name="refentry.level">
        <xsl:param name="node" select="."/>
        <xsl:variable name="container"
                      select="($node/ancestor::section |                         $node/ancestor::sect1 |                         $node/ancestor::sect2 |                         $node/ancestor::sect3 |                         $node/ancestor::sect4 |                         $node/ancestor::sect5)[last()]"/>

        <xsl:choose>
            <xsl:when test="$container">
                <xsl:variable name="slevel">
                    <xsl:call-template name="section.level">
                        <xsl:with-param name="node" select="$container"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:value-of select="$slevel + 1"/>
            </xsl:when>
            <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="qandadiv.section.level">
        <xsl:variable name="section.level">
            <xsl:call-template name="qanda.section.level"/>
        </xsl:variable>
        <xsl:variable name="anc.divs" select="ancestor::qandadiv"/>

        <xsl:value-of select="count($anc.divs) + number($section.level)"/>
    </xsl:template>
    <xsl:template name="question.answer.label">
        <xsl:variable name="deflabel">
            <xsl:choose>
                <xsl:when test="ancestor-or-self::*[@defaultlabel]">
                    <xsl:value-of
                            select="(ancestor-or-self::*[@defaultlabel])[last()]                               /@defaultlabel"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$qanda.defaultlabel"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="label" select="@label"/>

        <!--
 (hnr      (hierarchical-number-recursive (normalize "qandadiv") node))

         (parsect  (ancestor-member node (section-element-list)))

         (defnum   (if (and %qanda-inherit-numeration% 
                            %section-autolabel%)
                       (if (node-list-empty? parsect)
                           (section-autolabel-prefix node)
                           (section-autolabel parsect))
                       ""))

         (hnumber  (let loop ((numlist hnr) (number defnum) 
                              (sep (if (equal? defnum "") "" ".")))
                     (if (null? numlist)
                         number
                         (loop (cdr numlist) 
                               (string-append number
                                              sep
                                              (number->string (car numlist)))
                               "."))))
         (cnumber  (child-number (parent node)))
         (number   (string-append hnumber 
                                  (if (equal? hnumber "")
                                      ""
                                      ".")
                                  (number->string cnumber))))
-->

        <xsl:choose>
            <xsl:when test="$deflabel = 'qanda'">
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key">
                        <xsl:choose>
                            <xsl:when test="local-name(.) = 'question'">question</xsl:when>
                            <xsl:when test="local-name(.) = 'answer'">answer</xsl:when>
                            <xsl:when test="local-name(.) = 'qandadiv'">qandadiv</xsl:when>
                            <xsl:otherwise>qandaset</xsl:otherwise>
                        </xsl:choose>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="$deflabel = 'label'">
                <xsl:value-of select="$label"/>
            </xsl:when>
            <xsl:when test="$deflabel = 'number'                     and local-name(.) = 'question'">
                <xsl:apply-templates select="ancestor::qandaset[1]" mode="number"/>
                <xsl:choose>
                    <xsl:when test="ancestor::qandadiv">
                        <xsl:apply-templates select="ancestor::qandadiv[1]" mode="number"/>
                        <xsl:apply-templates select="ancestor::qandaentry" mode="number"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="ancestor::qandaentry" mode="number"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <!-- nothing -->
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="qandaset" mode="number">
        <!-- FIXME: -->
    </xsl:template>
    <xsl:template match="qandadiv" mode="number">
        <xsl:number level="multiple" from="qandaset" format="1."/>
    </xsl:template>
    <xsl:template match="qandaentry" mode="number">
        <xsl:choose>
            <xsl:when test="ancestor::qandadiv">
                <xsl:number level="single" from="qandadiv" format="1."/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:number level="single" from="qandaset" format="1."/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="object.id">
        <xsl:param name="object" select="."/>
        <xsl:choose>
            <xsl:when test="$object/@id">
                <xsl:value-of select="$object/@id"/>
            </xsl:when>
            <xsl:when test="$object/@xml:id">
                <xsl:value-of select="$object/@xml:id"/>
            </xsl:when>
            <xsl:when test="$generate.consistent.ids != 0">
                <!-- Make $object the current node -->
                <xsl:for-each select="$object">
                    <xsl:text>id-</xsl:text>
                    <xsl:number level="multiple" count="*"/>
                </xsl:for-each>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="generate-id($object)"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="person.name">
        <!-- Formats a personal name. Handles corpauthor as a special case. -->
        <xsl:param name="node" select="."/>

        <xsl:variable name="style">
            <xsl:choose>
                <xsl:when test="$node/@role">
                    <xsl:value-of select="$node/@role"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="gentext.template">
                        <xsl:with-param name="context" select="'styles'"/>
                        <xsl:with-param name="name" select="'person-name'"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:choose>
            <!-- the personname element is a specialcase -->
            <xsl:when test="$node/personname">
                <xsl:call-template name="person.name">
                    <xsl:with-param name="node" select="$node/personname"/>
                </xsl:call-template>
            </xsl:when>

            <!-- handle corpauthor as a special case...-->
            <!-- * MikeSmith 2007-06: I'm wondering if the person.name template -->
            <!-- * actually ever gets called to handle corpauthor.. maybe -->
            <!-- * we don't actually need to check for corpauthor here. -->
            <xsl:when test="local-name($node)='corpauthor'">
                <xsl:apply-templates select="$node"/>
            </xsl:when>

            <xsl:otherwise>
                <xsl:choose>
                    <!-- Handle case when personname contains only general markup (DocBook 5.0) -->
                    <xsl:when
                            test="$node/self::personname and not($node/firstname or $node/honorific or $node/lineage or $node/othername or $node/surname)">
                        <xsl:apply-templates select="$node/node()"/>
                    </xsl:when>
                    <xsl:when test="$style = 'family-given'">
                        <xsl:call-template name="person.name.family-given">
                            <xsl:with-param name="node" select="$node"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:when test="$style = 'last-first'">
                        <xsl:call-template name="person.name.last-first">
                            <xsl:with-param name="node" select="$node"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="person.name.first-last">
                            <xsl:with-param name="node" select="$node"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="person.name.family-given">
        <xsl:param name="node" select="."/>

        <!-- The family-given style applies a convention for identifying given -->
        <!-- and family names in locales where it may be ambiguous -->
        <xsl:apply-templates select="$node//surname[1]"/>

        <xsl:if test="$node//surname and $node//firstname">
            <xsl:text> </xsl:text>
        </xsl:if>

        <xsl:apply-templates select="$node//firstname[1]"/>

        <xsl:text> [FAMILY Given]</xsl:text>
    </xsl:template>
    <xsl:template name="person.name.last-first">
        <xsl:param name="node" select="."/>

        <xsl:apply-templates select="$node//surname[1]"/>

        <xsl:if test="$node//surname and $node//firstname">
            <xsl:text>, </xsl:text>
        </xsl:if>

        <xsl:apply-templates select="$node//firstname[1]"/>
    </xsl:template>
    <xsl:template name="person.name.first-last">
        <xsl:param name="node" select="."/>

        <xsl:if test="$node//honorific">
            <xsl:apply-templates select="$node//honorific[1]"/>
            <xsl:value-of select="$punct.honorific"/>
        </xsl:if>

        <xsl:if test="$node//firstname">
            <xsl:if test="$node//honorific">
                <xsl:text> </xsl:text>
            </xsl:if>
            <xsl:apply-templates select="$node//firstname[1]"/>
        </xsl:if>

        <xsl:if test="$node//othername and $author.othername.in.middle != 0">
            <xsl:if test="$node//honorific or $node//firstname">
                <xsl:text> </xsl:text>
            </xsl:if>
            <xsl:apply-templates select="$node//othername[1]"/>
        </xsl:if>

        <xsl:if test="$node//surname">
            <xsl:if test="$node//honorific or $node//firstname                   or ($node//othername and $author.othername.in.middle != 0)">
                <xsl:text> </xsl:text>
            </xsl:if>
            <xsl:apply-templates select="$node//surname[1]"/>
        </xsl:if>

        <xsl:if test="$node//lineage">
            <xsl:text>, </xsl:text>
            <xsl:apply-templates select="$node//lineage[1]"/>
        </xsl:if>
    </xsl:template>
    <xsl:template name="person.name.list">
        <!-- Return a formatted string representation of the contents of
       the current element. The current element must contain one or
       more AUTHORs, CORPAUTHORs, OTHERCREDITs, and/or EDITORs.

       John Doe
     or
       John Doe and Jane Doe
     or
       John Doe, Jane Doe, and A. Nonymous
  -->
        <xsl:param name="person.list" select="author|corpauthor|othercredit|editor"/>
        <xsl:param name="person.count" select="count($person.list)"/>
        <xsl:param name="count" select="1"/>

        <xsl:choose>
            <xsl:when test="$count &gt; $person.count"/>
            <xsl:otherwise>
                <xsl:call-template name="person.name">
                    <xsl:with-param name="node" select="$person.list[position()=$count]"/>
                </xsl:call-template>

                <xsl:choose>
                    <xsl:when test="$person.count = 2 and $count = 1">
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="context" select="'authorgroup'"/>
                            <xsl:with-param name="name" select="'sep2'"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:when test="$person.count &gt; 2 and $count+1 = $person.count">
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="context" select="'authorgroup'"/>
                            <xsl:with-param name="name" select="'seplast'"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:when test="$count &lt; $person.count">
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="context" select="'authorgroup'"/>
                            <xsl:with-param name="name" select="'sep'"/>
                        </xsl:call-template>
                    </xsl:when>
                </xsl:choose>

                <xsl:call-template name="person.name.list">
                    <xsl:with-param name="person.list" select="$person.list"/>
                    <xsl:with-param name="person.count" select="$person.count"/>
                    <xsl:with-param name="count" select="$count+1"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:param name="arg.choice.opt.open.str">[</xsl:param>
    <xsl:param name="arg.choice.opt.close.str">]</xsl:param>
    <xsl:param name="arg.choice.req.open.str">{</xsl:param>
    <xsl:param name="arg.choice.req.close.str">}</xsl:param>
    <xsl:param name="arg.choice.plain.open.str">
        <xsl:text> </xsl:text>
    </xsl:param>
    <xsl:param name="arg.choice.plain.close.str">
        <xsl:text> </xsl:text>
    </xsl:param>
    <xsl:param name="arg.choice.def.open.str">[</xsl:param>
    <xsl:param name="arg.choice.def.close.str">]</xsl:param>
    <xsl:param name="arg.rep.repeat.str">...</xsl:param>
    <xsl:param name="arg.rep.norepeat.str"/>
    <xsl:param name="arg.rep.def.str"/>
    <xsl:param name="arg.or.sep">|</xsl:param>
    <xsl:param name="cmdsynopsis.hanging.indent">4pi</xsl:param>
    <xsl:template name="filename-basename">
        <!-- We assume all filenames are really URIs and use "/" -->
        <xsl:param name="filename"/>
        <xsl:param name="recurse" select="false()"/>

        <xsl:choose>
            <xsl:when test="substring-after($filename, '/') != ''">
                <xsl:call-template name="filename-basename">
                    <xsl:with-param name="filename" select="substring-after($filename, '/')"/>
                    <xsl:with-param name="recurse" select="true()"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$filename"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="filename-extension">
        <xsl:param name="filename"/>
        <xsl:param name="recurse" select="false()"/>

        <!-- Make sure we only look at the base name... -->
        <xsl:variable name="basefn">
            <xsl:choose>
                <xsl:when test="$recurse">
                    <xsl:value-of select="$filename"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="filename-basename">
                        <xsl:with-param name="filename" select="$filename"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="substring-after($basefn, '.') != ''">
                <xsl:call-template name="filename-extension">
                    <xsl:with-param name="filename" select="substring-after($basefn, '.')"/>
                    <xsl:with-param name="recurse" select="true()"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="$recurse">
                <xsl:value-of select="$basefn"/>
            </xsl:when>
            <xsl:otherwise/>
        </xsl:choose>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="select.mediaobject">
        <refpurpose>Selects and processes an appropriate media object from a list</refpurpose>

        <refdescription id="select.mediaobject-desc">
            <para>This template takes a list of media objects (usually the
                children of a mediaobject or inlinemediaobject) and processes
                the "right" object.
            </para>

            <para>This template relies on a template named
                "select.mediaobject.index" to determine which object
                in the list is appropriate.
            </para>

            <para>If no acceptable object is located, nothing happens.</para>
        </refdescription>

        <refparameter id="select.mediaobject-params">
            <variablelist>
                <varlistentry>
                    <term>olist</term>
                    <listitem>
                        <para>The node list of potential objects to examine.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>

        <refreturn id="select.mediaobject-returns">
            <para>Calls &lt;xsl:apply-templates&gt; on the selected object.</para>
        </refreturn>
    </doc:template>
    <xsl:template name="select.mediaobject">
        <xsl:param name="olist"
                   select="imageobject|imageobjectco                      |videoobject|audioobject|textobject"/>

        <xsl:variable name="mediaobject.index">
            <xsl:call-template name="select.mediaobject.index">
                <xsl:with-param name="olist" select="$olist"/>
                <xsl:with-param name="count" select="1"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:if test="$mediaobject.index != ''">
            <xsl:apply-templates select="$olist[position() = $mediaobject.index]"/>
        </xsl:if>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="select.mediaobject.index">
        <refpurpose>Selects the position of the appropriate media object from a list</refpurpose>

        <refdescription id="select.mediaobject.index-desc">
            <para>This template takes a list of media objects (usually the
                children of a mediaobject or inlinemediaobject) and determines
                the "right" object. It returns the position of that object
                to be used by the calling template.
            </para>

            <para>If the parameter
                <parameter>use.role.for.mediaobject</parameter>
                is nonzero, then it first checks for an object with
                a role attribute of the appropriate value. It takes the first
                of those. Otherwise, it takes the first acceptable object
                through a recursive pass through the list.
            </para>

            <para>This template relies on a template named "is.acceptable.mediaobject"
                to determine if a given object is an acceptable graphic. The semantics
                of media objects is that the first acceptable graphic should be used.
            </para>

            <para>If no acceptable object is located, no index is returned.</para>
        </refdescription>

        <refparameter id="select.mediaobject.index-params">
            <variablelist>
                <varlistentry>
                    <term>olist</term>
                    <listitem>
                        <para>The node list of potential objects to examine.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>count</term>
                    <listitem>
                        <para>The position in the list currently being considered by the
                            recursive process.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>

        <refreturn id="select.mediaobject.index-returns">
            <para>Returns the position in the original list of the selected object.</para>
        </refreturn>
    </doc:template>
    <xsl:template name="select.mediaobject.index">
        <xsl:param name="olist"
                   select="imageobject|imageobjectco                      |videoobject|audioobject|textobject"/>
        <xsl:param name="count">1</xsl:param>

        <xsl:choose>
            <!-- Test for objects preferred by role -->
            <xsl:when
                    test="$use.role.for.mediaobject != 0                 and $preferred.mediaobject.role != ''                and $olist[@role = $preferred.mediaobject.role]">

                <!-- Get the first hit's position index -->
                <xsl:for-each select="$olist">
                    <xsl:if test="@role = $preferred.mediaobject.role and              not(preceding-sibling::*[@role = $preferred.mediaobject.role])">
                        <xsl:value-of select="position()"/>
                    </xsl:if>
                </xsl:for-each>
            </xsl:when>

            <xsl:when test="$use.role.for.mediaobject != 0                 and $olist[@role = $stylesheet.result.type]">
                <!-- Get the first hit's position index -->
                <xsl:for-each select="$olist">
                    <xsl:if test="@role = $stylesheet.result.type and                not(preceding-sibling::*[@role = $stylesheet.result.type])">
                        <xsl:value-of select="position()"/>
                    </xsl:if>
                </xsl:for-each>
            </xsl:when>
            <!-- Accept 'html' for $stylesheet.result.type = 'xhtml' -->
            <xsl:when
                    test="$use.role.for.mediaobject != 0                 and $stylesheet.result.type = 'xhtml'                and $olist[@role = 'html']">
                <!-- Get the first hit's position index -->
                <xsl:for-each select="$olist">
                    <xsl:if test="@role = 'html' and                not(preceding-sibling::*[@role = 'html'])">
                        <xsl:value-of select="position()"/>
                    </xsl:if>
                </xsl:for-each>
            </xsl:when>

            <!-- If no selection by role, and there is only one object, use it -->
            <xsl:when test="count($olist) = 1 and $count = 1">
                <xsl:value-of select="$count"/>
            </xsl:when>

            <xsl:otherwise>
                <!-- Otherwise select first acceptable object -->
                <xsl:if test="$count &lt;= count($olist)">
                    <xsl:variable name="object" select="$olist[position()=$count]"/>

                    <xsl:variable name="useobject">
                        <xsl:choose>
                            <!-- select videoobject or audioobject before textobject -->
                            <xsl:when test="local-name($object) = 'videoobject'">
                                <xsl:text>1</xsl:text>
                            </xsl:when>
                            <xsl:when test="local-name($object) = 'audioobject'">
                                <xsl:text>1</xsl:text>
                            </xsl:when>
                            <!-- skip textobject if also video, audio, or image out of order -->
                            <xsl:when
                                    test="local-name($object) = 'textobject' and                             ../imageobject or                             ../audioobject or                             ../videoobject">
                                <xsl:text>0</xsl:text>
                            </xsl:when>
                            <!-- The phrase is used only when contains TeX Math and output is FO -->
                            <xsl:when
                                    test="local-name($object)='textobject' and $object/phrase                             and $object/@role='tex' and $stylesheet.result.type = 'fo'                             and $tex.math.in.alt != ''">
                                <xsl:text>1</xsl:text>
                            </xsl:when>
                            <!-- The phrase is never used -->
                            <xsl:when test="local-name($object)='textobject' and $object/phrase">
                                <xsl:text>0</xsl:text>
                            </xsl:when>
                            <xsl:when
                                    test="local-name($object)='textobject'                             and $object/ancestor::equation ">
                                <!-- The first textobject is not a reasonable fallback
                 for equation image -->
                                <xsl:text>0</xsl:text>
                            </xsl:when>
                            <!-- The first textobject is a reasonable fallback -->
                            <xsl:when
                                    test="local-name($object)='textobject'                             and $object[not(@role) or @role!='tex']">
                                <xsl:text>1</xsl:text>
                            </xsl:when>
                            <!-- don't use graphic when output is FO, TeX Math is used 
                 and there is math in alt element -->
                            <xsl:when
                                    test="$object/ancestor::equation and                              $object/ancestor::equation/alt[@role='tex']                             and $stylesheet.result.type = 'fo'                             and $tex.math.in.alt != ''">
                                <xsl:text>0</xsl:text>
                            </xsl:when>
                            <!-- If there's only one object, use it -->
                            <xsl:when test="$count = 1 and count($olist) = 1">
                                <xsl:text>1</xsl:text>
                            </xsl:when>
                            <!-- Otherwise, see if this one is a useable graphic -->
                            <xsl:otherwise>
                                <xsl:choose>
                                    <!-- peek inside imageobjectco to simplify the test -->
                                    <xsl:when test="local-name($object) = 'imageobjectco'">
                                        <xsl:call-template name="is.acceptable.mediaobject">
                                            <xsl:with-param name="object" select="$object/imageobject"/>
                                        </xsl:call-template>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:call-template name="is.acceptable.mediaobject">
                                            <xsl:with-param name="object" select="$object"/>
                                        </xsl:call-template>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>

                    <xsl:choose>
                        <xsl:when test="$useobject='1'">
                            <xsl:value-of select="$count"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:call-template name="select.mediaobject.index">
                                <xsl:with-param name="olist" select="$olist"/>
                                <xsl:with-param name="count" select="$count + 1"/>
                            </xsl:call-template>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="is.acceptable.mediaobject">
        <refpurpose>Returns '1' if the specified media object is recognized</refpurpose>

        <refdescription id="is.acceptable.mediaobject-desc">
            <para>This template examines a media object and returns '1' if the
                object is recognized as a graphic.
            </para>
        </refdescription>

        <refparameter id="is.acceptable.mediaobject-params">
            <variablelist>
                <varlistentry>
                    <term>object</term>
                    <listitem>
                        <para>The media object to consider.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>

        <refreturn id="is.acceptable.mediaobject-returns">
            <para>0 or 1</para>
        </refreturn>
    </doc:template>
    <xsl:template name="is.acceptable.mediaobject">
        <xsl:param name="object"/>

        <xsl:variable name="filename">
            <xsl:call-template name="mediaobject.filename">
                <xsl:with-param name="object" select="$object"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="ext">
            <xsl:call-template name="filename-extension">
                <xsl:with-param name="filename" select="$filename"/>
            </xsl:call-template>
        </xsl:variable>

        <!-- there will only be one -->
        <xsl:variable name="data"
                      select="$object/videodata                                     |$object/imagedata                                     |$object/audiodata"/>

        <xsl:variable name="format" select="$data/@format"/>

        <xsl:variable name="graphic.format">
            <xsl:if test="$format">
                <xsl:call-template name="is.graphic.format">
                    <xsl:with-param name="format" select="$format"/>
                </xsl:call-template>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="graphic.ext">
            <xsl:if test="$ext">
                <xsl:call-template name="is.graphic.extension">
                    <xsl:with-param name="ext" select="$ext"/>
                </xsl:call-template>
            </xsl:if>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$use.svg = 0 and $format = 'SVG'">0</xsl:when>
            <xsl:when xmlns:svg="http://www.w3.org/2000/svg" test="$use.svg != 0 and $object/svg:*">1</xsl:when>
            <xsl:when test="$graphic.format = '1'">1</xsl:when>
            <xsl:when test="$graphic.ext = '1'">1</xsl:when>
            <xsl:otherwise>0</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="mediaobject.filename">
        <xsl:param name="object"/>

        <xsl:variable name="data"
                      select="$object/videodata                                     |$object/imagedata                                     |$object/audiodata                                     |$object"/>

        <xsl:variable name="filename">
            <xsl:choose>
                <xsl:when test="$data[@fileref]">
                    <xsl:apply-templates select="$data/@fileref"/>
                </xsl:when>
                <xsl:when test="$data[@entityref]">
                    <xsl:value-of select="unparsed-entity-uri($data/@entityref)"/>
                </xsl:when>
                <xsl:otherwise/>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="real.ext">
            <xsl:call-template name="filename-extension">
                <xsl:with-param name="filename" select="$filename"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="ext">
            <xsl:choose>
                <xsl:when test="$real.ext != ''">
                    <xsl:value-of select="$real.ext"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$graphic.default.extension"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="graphic.ext">
            <xsl:call-template name="is.graphic.extension">
                <xsl:with-param name="ext" select="$ext"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$real.ext = ''">
                <xsl:choose>
                    <xsl:when test="$ext != ''">
                        <xsl:value-of select="$filename"/>
                        <xsl:text>.</xsl:text>
                        <xsl:value-of select="$ext"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$filename"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="not($graphic.ext)">
                <xsl:choose>
                    <xsl:when test="$graphic.default.extension != ''">
                        <xsl:value-of select="$filename"/>
                        <xsl:text>.</xsl:text>
                        <xsl:value-of select="$graphic.default.extension"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$filename"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$filename"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="check.id.unique">
        <refpurpose>Warn users about references to non-unique IDs</refpurpose>
        <refdescription id="check.id.unique-desc">
            <para>If passed an ID in<varname>linkend</varname>,
                <function>check.id.unique</function>
                prints
                a warning message to the user if either the ID does not exist or
                the ID is not unique.
            </para>
        </refdescription>
    </doc:template>
    <xsl:template name="check.id.unique">
        <xsl:param name="linkend"/>
        <xsl:if test="$linkend != ''">
            <xsl:variable name="targets" select="key('id',$linkend)"/>
            <xsl:variable name="target" select="$targets[1]"/>

            <xsl:if test="count($targets)=0">
                <xsl:message>
                    <xsl:text>Error: no ID for constraint linkend: </xsl:text>
                    <xsl:value-of select="$linkend"/>
                    <xsl:text>.</xsl:text>
                </xsl:message>
                <!--
      <xsl:message>
        <xsl:text>If the ID exists in your document, did your </xsl:text>
        <xsl:text>XSLT Processor load the DTD?</xsl:text>
      </xsl:message>
      -->
            </xsl:if>

            <xsl:if test="count($targets)&gt;1">
                <xsl:message>
                    <xsl:text>Warning: multiple "IDs" for constraint linkend: </xsl:text>
                    <xsl:value-of select="$linkend"/>
                    <xsl:text>.</xsl:text>
                </xsl:message>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="check.idref.targets">
        <refpurpose>Warn users about incorrectly typed references</refpurpose>
        <refdescription id="check.idref.targets-desc">
            <para>If passed an ID in<varname>linkend</varname>,
                <function>check.idref.targets</function>
                makes sure that the element
                pointed to by the link is one of the elements listed in
                <varname>element-list</varname>
                and warns the user otherwise.
            </para>
        </refdescription>
    </doc:template>
    <xsl:template name="check.idref.targets">
        <xsl:param name="linkend"/>
        <xsl:param name="element-list"/>
        <xsl:if test="$linkend != ''">
            <xsl:variable name="targets" select="key('id',$linkend)"/>
            <xsl:variable name="target" select="$targets[1]"/>

            <xsl:if test="count($target) &gt; 0">
                <xsl:if test="not(contains(concat(' ', $element-list, ' '), local-name($target)))">
                    <xsl:message>
                        <xsl:text>Error: linkend (</xsl:text>
                        <xsl:value-of select="$linkend"/>
                        <xsl:text>) points to "</xsl:text>
                        <xsl:value-of select="local-name($target)"/>
                        <xsl:text>" not (one of): </xsl:text>
                        <xsl:value-of select="$element-list"/>
                    </xsl:message>
                </xsl:if>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    <xsl:param name="procedure.step.numeration.formats" select="'1aiAI'"/>
    <xsl:template name="procedure.step.numeration">
        <xsl:param name="context" select="."/>
        <xsl:variable name="format.length" select="string-length($procedure.step.numeration.formats)"/>
        <xsl:choose>
            <xsl:when test="local-name($context) = 'substeps'">
                <xsl:variable name="ssdepth" select="count($context/ancestor::substeps)"/>
                <xsl:variable name="sstype" select="($ssdepth mod $format.length)+2"/>
                <xsl:choose>
                    <xsl:when test="$sstype &gt; $format.length">
                        <xsl:value-of select="substring($procedure.step.numeration.formats,1,1)"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="substring($procedure.step.numeration.formats,$sstype,1)"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="local-name($context) = 'step'">
                <xsl:variable name="sdepth" select="count($context/ancestor::substeps)"/>
                <xsl:variable name="stype" select="($sdepth mod $format.length)+1"/>
                <xsl:value-of select="substring($procedure.step.numeration.formats,$stype,1)"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>
                    <xsl:text>Unexpected context in procedure.step.numeration: </xsl:text>
                    <xsl:value-of select="local-name($context)"/>
                </xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="step" mode="number">
        <xsl:param name="rest" select="''"/>
        <xsl:param name="recursive" select="1"/>
        <xsl:variable name="format">
            <xsl:call-template name="procedure.step.numeration"/>
        </xsl:variable>
        <xsl:variable name="num">
            <xsl:number count="step" format="{$format}"/>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$recursive != 0 and ancestor::step">
                <xsl:apply-templates select="ancestor::step[1]" mode="number">
                    <xsl:with-param name="rest" select="concat('.', $num, $rest)"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="concat($num, $rest)"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="output-orderedlist-starting-number">
        <xsl:param name="list"/>
        <xsl:param name="pi-start"/>
        <xsl:choose>
            <xsl:when test="not($list/@continuation = 'continues')">
                <xsl:choose>
                    <xsl:when test="$list/@startingnumber">
                        <xsl:value-of select="$list/@startingnumber"/>
                    </xsl:when>
                    <xsl:when test="$pi-start != ''">
                        <xsl:value-of select="$pi-start"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <!-- match on previous list at same nesting level -->
                <xsl:variable name="prevlist"
                              select="$list/preceding::orderedlist                 [count($list/ancestor::orderedlist) = count(ancestor::orderedlist)][1]"/>
                <xsl:choose>
                    <xsl:when test="count($prevlist) = 0">2</xsl:when>
                    <xsl:otherwise>
                        <xsl:variable name="prevlength" select="count($prevlist/listitem)"/>
                        <xsl:variable name="prevstart">
                            <xsl:call-template name="orderedlist-starting-number">
                                <xsl:with-param name="list" select="$prevlist"/>
                            </xsl:call-template>
                        </xsl:variable>
                        <xsl:value-of select="$prevstart + $prevlength"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="orderedlist-item-number">
        <!-- context node must be a listitem in an orderedlist -->
        <xsl:param name="node" select="."/>
        <xsl:choose>
            <xsl:when test="$node/@override">
                <xsl:value-of select="$node/@override"/>
            </xsl:when>
            <xsl:when test="$node/preceding-sibling::listitem">
                <xsl:variable name="pnum">
                    <xsl:call-template name="orderedlist-item-number">
                        <xsl:with-param name="node" select="$node/preceding-sibling::listitem[1]"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:value-of select="$pnum + 1"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="orderedlist-starting-number">
                    <xsl:with-param name="list" select="parent::*"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="next.numeration">
        <xsl:param name="numeration" select="'default'"/>
        <xsl:choose>
            <!-- Change this list if you want to change the order of numerations -->
            <xsl:when test="$numeration = 'arabic'">loweralpha</xsl:when>
            <xsl:when test="$numeration = 'loweralpha'">lowerroman</xsl:when>
            <xsl:when test="$numeration = 'lowerroman'">upperalpha</xsl:when>
            <xsl:when test="$numeration = 'upperalpha'">upperroman</xsl:when>
            <xsl:when test="$numeration = 'upperroman'">arabic</xsl:when>
            <xsl:otherwise>arabic</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="list.numeration">
        <xsl:param name="node" select="."/>

        <xsl:choose>
            <xsl:when test="$node/@numeration">
                <xsl:value-of select="$node/@numeration"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="$node/ancestor::orderedlist">
                        <xsl:call-template name="next.numeration">
                            <xsl:with-param name="numeration">
                                <xsl:call-template name="list.numeration">
                                    <xsl:with-param name="node" select="$node/ancestor::orderedlist[1]"/>
                                </xsl:call-template>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="next.numeration"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="orderedlist/listitem" mode="item-number">
        <xsl:variable name="numeration">
            <xsl:call-template name="list.numeration">
                <xsl:with-param name="node" select="parent::orderedlist"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="type">
            <xsl:choose>
                <xsl:when test="$numeration='arabic'">1.</xsl:when>
                <xsl:when test="$numeration='loweralpha'">a.</xsl:when>
                <xsl:when test="$numeration='lowerroman'">i.</xsl:when>
                <xsl:when test="$numeration='upperalpha'">A.</xsl:when>
                <xsl:when test="$numeration='upperroman'">I.</xsl:when>
                <!-- What!? This should never happen -->
                <xsl:otherwise>
                    <xsl:message>
                        <xsl:text>Unexpected numeration: </xsl:text>
                        <xsl:value-of select="$numeration"/>
                    </xsl:message>
                    <xsl:value-of select="1."/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="item-number">
            <xsl:call-template name="orderedlist-item-number"/>
        </xsl:variable>

        <xsl:if test="parent::orderedlist/@inheritnum='inherit'                 and ancestor::listitem[parent::orderedlist]">
            <xsl:apply-templates select="ancestor::listitem[parent::orderedlist][1]" mode="item-number"/>
        </xsl:if>

        <xsl:number value="$item-number" format="{$type}"/>
    </xsl:template>
    <xsl:template name="next.itemsymbol">
        <xsl:param name="itemsymbol" select="'default'"/>
        <xsl:choose>
            <!-- Change this list if you want to change the order of symbols -->
            <xsl:when test="$itemsymbol = 'disc'">circle</xsl:when>
            <xsl:when test="$itemsymbol = 'circle'">square</xsl:when>
            <xsl:otherwise>disc</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="list.itemsymbol">
        <xsl:param name="node" select="."/>

        <xsl:choose>
            <xsl:when test="@override">
                <xsl:value-of select="@override"/>
            </xsl:when>
            <xsl:when test="$node/@mark">
                <xsl:value-of select="$node/@mark"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="$node/ancestor::itemizedlist">
                        <xsl:call-template name="next.itemsymbol">
                            <xsl:with-param name="itemsymbol">
                                <xsl:call-template name="list.itemsymbol">
                                    <xsl:with-param name="node" select="$node/ancestor::itemizedlist[1]"/>
                                </xsl:call-template>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="next.itemsymbol"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="copyright.years">
        <refpurpose>Print a set of years with collapsed ranges</refpurpose>

        <refdescription id="copyright.years-desc">
            <para>This template prints a list of year elements with consecutive
                years printed as a range. In other words:
            </para>

            <screen>&lt;year&gt;1992&lt;/year&gt;
                &lt;year&gt;1993&lt;/year&gt;
                &lt;year&gt;1994&lt;/year&gt;</screen>

            <para>is printed<quote>1992-1994</quote>, whereas:
            </para>

            <screen>&lt;year&gt;1992&lt;/year&gt;
                &lt;year&gt;1994&lt;/year&gt;</screen>

            <para>is printed<quote>1992, 1994</quote>.
            </para>

            <para>This template assumes that all the year elements contain only
                decimal year numbers, that the elements are sorted in increasing
                numerical order, that there are no duplicates, and that all the years
                are expressed in full
                <quote>century+year</quote>
                (
                <quote>1999</quote>
                not<quote>99</quote>) notation.
            </para>
        </refdescription>

        <refparameter id="copyright.years-params">
            <variablelist>
                <varlistentry>
                    <term>years</term>
                    <listitem>
                        <para>The initial set of year elements.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>print.ranges</term>
                    <listitem>
                        <para>If non-zero, multi-year ranges are collapsed. If zero, all years
                            are printed discretely.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>single.year.ranges</term>
                    <listitem>
                        <para>If non-zero, two consecutive years will be printed as a range,
                            otherwise, they will be printed discretely. In other words, a single
                            year range is
                            <quote>1991-1992</quote>
                            but discretely it's
                            <quote>1991, 1992</quote>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>

        <refreturn id="copyright.years-returns">
            <para>This template returns the formatted list of years.</para>
        </refreturn>
    </doc:template>
    <xsl:template name="copyright.years">
        <xsl:param name="years"/>
        <xsl:param name="print.ranges" select="1"/>
        <xsl:param name="single.year.ranges" select="0"/>
        <xsl:param name="firstyear" select="0"/>
        <xsl:param name="nextyear" select="0"/>

        <!--
  <xsl:message terminate="no">
    <xsl:text>CY: </xsl:text>
    <xsl:value-of select="count($years)"/>
    <xsl:text>, </xsl:text>
    <xsl:value-of select="$firstyear"/>
    <xsl:text>, </xsl:text>
    <xsl:value-of select="$nextyear"/>
    <xsl:text>, </xsl:text>
    <xsl:value-of select="$print.ranges"/>
    <xsl:text>, </xsl:text>
    <xsl:value-of select="$single.year.ranges"/>
    <xsl:text> (</xsl:text>
    <xsl:value-of select="$years[1]"/>
    <xsl:text>)</xsl:text>
  </xsl:message>
  -->

        <xsl:choose>
            <xsl:when test="$print.ranges = 0 and count($years) &gt; 0">
                <xsl:choose>
                    <xsl:when test="count($years) = 1">
                        <xsl:apply-templates select="$years[1]" mode="titlepage.mode"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="$years[1]" mode="titlepage.mode"/>
                        <xsl:text>, </xsl:text>
                        <xsl:call-template name="copyright.years">
                            <xsl:with-param name="years" select="$years[position() &gt; 1]"/>
                            <xsl:with-param name="print.ranges" select="$print.ranges"/>
                            <xsl:with-param name="single.year.ranges" select="$single.year.ranges"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="count($years) = 0">
                <xsl:variable name="lastyear" select="$nextyear - 1"/>
                <xsl:choose>
                    <xsl:when test="$firstyear = 0">
                        <!-- there weren't any years at all -->
                    </xsl:when>
                    <!-- Just output a year with range in its text -->
                    <xsl:when test="contains($firstyear, '-') or contains($firstyear, ',')">
                        <xsl:value-of select="$firstyear"/>
                    </xsl:when>
                    <xsl:when test="$firstyear = $lastyear">
                        <xsl:value-of select="$firstyear"/>
                    </xsl:when>
                    <xsl:when test="$single.year.ranges = 0                         and $lastyear = $firstyear + 1">
                        <xsl:value-of select="$firstyear"/>
                        <xsl:text>, </xsl:text>
                        <xsl:value-of select="$lastyear"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$firstyear"/>
                        <xsl:text>-</xsl:text>
                        <xsl:value-of select="$lastyear"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="contains($firstyear, '-') or contains($firstyear, ',')">
                <!-- Just output a year with range in its text -->
                <xsl:value-of select="$firstyear"/>
                <xsl:if test="count($years) != 0">
                    <xsl:text>, </xsl:text>
                </xsl:if>
                <xsl:call-template name="copyright.years">
                    <xsl:with-param name="years" select="$years[position() &gt; 1]"/>
                    <xsl:with-param name="firstyear" select="$years[1]"/>
                    <xsl:with-param name="nextyear" select="$years[1] + 1"/>
                    <xsl:with-param name="print.ranges" select="$print.ranges"/>
                    <xsl:with-param name="single.year.ranges" select="$single.year.ranges"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="$firstyear = 0">
                <xsl:call-template name="copyright.years">
                    <xsl:with-param name="years" select="$years[position() &gt; 1]"/>
                    <xsl:with-param name="firstyear" select="$years[1]"/>
                    <xsl:with-param name="nextyear" select="$years[1] + 1"/>
                    <xsl:with-param name="print.ranges" select="$print.ranges"/>
                    <xsl:with-param name="single.year.ranges" select="$single.year.ranges"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="$nextyear = $years[1]">
                <xsl:call-template name="copyright.years">
                    <xsl:with-param name="years" select="$years[position() &gt; 1]"/>
                    <xsl:with-param name="firstyear" select="$firstyear"/>
                    <xsl:with-param name="nextyear" select="$nextyear + 1"/>
                    <xsl:with-param name="print.ranges" select="$print.ranges"/>
                    <xsl:with-param name="single.year.ranges" select="$single.year.ranges"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <!-- we have years left, but they aren't in the current range -->
                <xsl:choose>
                    <xsl:when test="$nextyear = $firstyear + 1">
                        <xsl:value-of select="$firstyear"/>
                        <xsl:text>, </xsl:text>
                    </xsl:when>
                    <xsl:when test="$single.year.ranges = 0                         and $nextyear = $firstyear + 2">
                        <xsl:value-of select="$firstyear"/>
                        <xsl:text>, </xsl:text>
                        <xsl:value-of select="$nextyear - 1"/>
                        <xsl:text>, </xsl:text>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$firstyear"/>
                        <xsl:text>-</xsl:text>
                        <xsl:value-of select="$nextyear - 1"/>
                        <xsl:text>, </xsl:text>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:call-template name="copyright.years">
                    <xsl:with-param name="years" select="$years[position() &gt; 1]"/>
                    <xsl:with-param name="firstyear" select="$years[1]"/>
                    <xsl:with-param name="nextyear" select="$years[1] + 1"/>
                    <xsl:with-param name="print.ranges" select="$print.ranges"/>
                    <xsl:with-param name="single.year.ranges" select="$single.year.ranges"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="find.path.params">
        <refpurpose>Search in a table for the "best" match for the node</refpurpose>

        <refdescription id="find.path.params-desc">
            <para>This template searches in a table for the value that most-closely
                (in the typical best-match sense of XSLT) matches the current (element)
                node location.
            </para>
        </refdescription>
    </doc:template>
    <xsl:template name="find.path.params">
        <xsl:param name="node" select="."/>
        <xsl:param name="table" select="''"/>
        <xsl:param name="location">
            <xsl:call-template name="xpath.location">
                <xsl:with-param name="node" select="$node"/>
            </xsl:call-template>
        </xsl:param>

        <xsl:variable name="value">
            <xsl:call-template name="lookup.key">
                <xsl:with-param name="key" select="$location"/>
                <xsl:with-param name="table" select="$table"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$value != ''">
                <xsl:value-of select="$value"/>
            </xsl:when>
            <xsl:when test="contains($location, '/')">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="node" select="$node"/>
                    <xsl:with-param name="table" select="$table"/>
                    <xsl:with-param name="location" select="substring-after($location, '/')"/>
                </xsl:call-template>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="relative-uri">
        <xsl:param name="filename" select="."/>
        <xsl:param name="destdir" select="''"/>

        <xsl:variable name="srcurl">
            <xsl:call-template name="strippath">
                <xsl:with-param name="filename">
                    <xsl:call-template name="xml.base.dirs">
                        <xsl:with-param name="base.elem"
                                        select="$filename/ancestor-or-self::*                                    [@xml:base != ''][1]"/>
                    </xsl:call-template>
                    <xsl:value-of select="$filename"/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="srcurl.trimmed">
            <xsl:call-template name="trim.common.uri.paths">
                <xsl:with-param name="uriA" select="$srcurl"/>
                <xsl:with-param name="uriB" select="$destdir"/>
                <xsl:with-param name="return" select="'A'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="destdir.trimmed">
            <xsl:call-template name="trim.common.uri.paths">
                <xsl:with-param name="uriA" select="$srcurl"/>
                <xsl:with-param name="uriB" select="$destdir"/>
                <xsl:with-param name="return" select="'B'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="depth">
            <xsl:call-template name="count.uri.path.depth">
                <xsl:with-param name="filename" select="$destdir.trimmed"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:call-template name="copy-string">
            <xsl:with-param name="string" select="'../'"/>
            <xsl:with-param name="count" select="$depth"/>
        </xsl:call-template>
        <xsl:value-of select="$srcurl.trimmed"/>

    </xsl:template>
    <xsl:template name="xml.base.dirs">
        <xsl:param name="base.elem" select="NONODE"/>

        <!-- Recursively resolve xml:base attributes, up to a 
       full path with : in uri -->
        <xsl:if test="$base.elem/ancestor::*[@xml:base != ''] and                 not(contains($base.elem/@xml:base, ':'))">
            <xsl:call-template name="xml.base.dirs">
                <xsl:with-param name="base.elem" select="$base.elem/ancestor::*[@xml:base != ''][1]"/>
            </xsl:call-template>
        </xsl:if>
        <xsl:call-template name="getdir">
            <xsl:with-param name="filename" select="$base.elem/@xml:base"/>
        </xsl:call-template>

    </xsl:template>
    <xsl:template name="strippath">
        <xsl:param name="filename" select="''"/>
        <xsl:choose>
            <!-- Leading .. are not eliminated -->
            <xsl:when test="starts-with($filename, '../')">
                <xsl:value-of select="'../'"/>
                <xsl:call-template name="strippath">
                    <xsl:with-param name="filename" select="substring-after($filename, '../')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="contains($filename, '/../')">
                <xsl:call-template name="strippath">
                    <xsl:with-param name="filename">
                        <xsl:call-template name="getdir">
                            <xsl:with-param name="filename" select="substring-before($filename, '/../')"/>
                        </xsl:call-template>
                        <xsl:value-of select="substring-after($filename, '/../')"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$filename"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="getdir">
        <xsl:param name="filename" select="''"/>
        <xsl:if test="contains($filename, '/')">
            <xsl:value-of select="substring-before($filename, '/')"/>
            <xsl:text>/</xsl:text>
            <xsl:call-template name="getdir">
                <xsl:with-param name="filename" select="substring-after($filename, '/')"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="string.upper">
        <refpurpose>Converts a string to all uppercase letters</refpurpose>

        <refdescription id="string.upper-desc">
            <para>Given a string, this template does a language-aware conversion
                of that string to all uppercase letters, based on the values of the
                <literal>lowercase.alpha</literal>
                and
                <literal>uppercase.alpha</literal>
                gentext keys for the current
                locale. It affects only those characters found in the values of
                <literal>lowercase.alpha</literal>
                and
                <literal>uppercase.alpha</literal>. All other characters are left
                unchanged.
            </para>
        </refdescription>

        <refparameter id="string.upper-params">
            <variablelist>
                <varlistentry>
                    <term>string</term>
                    <listitem>
                        <para>The string to convert to uppercase.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
    </doc:template>
    <xsl:template name="string.upper">
        <xsl:param name="string" select="''"/>
        <xsl:variable name="lowercase.alpha">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key" select="'lowercase.alpha'"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="uppercase.alpha">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key" select="'uppercase.alpha'"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="translate($string,$lowercase.alpha,$uppercase.alpha)"/>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="string.lower">
        <refpurpose>Converts a string to all lowercase letters</refpurpose>

        <refdescription id="string.lower-desc">
            <para>Given a string, this template does a language-aware conversion
                of that string to all lowercase letters, based on the values of the
                <literal>uppercase.alpha</literal>
                and
                <literal>lowercase.alpha</literal>
                gentext keys for the current
                locale. It affects only those characters found in the values of
                <literal>uppercase.alpha</literal>
                and
                <literal>lowercase.alpha</literal>. All other characters are left
                unchanged.
            </para>
        </refdescription>

        <refparameter id="string.lower-params">
            <variablelist>
                <varlistentry>
                    <term>string</term>
                    <listitem>
                        <para>The string to convert to lowercase.</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
    </doc:template>
    <xsl:template name="string.lower">
        <xsl:param name="string" select="''"/>
        <xsl:variable name="uppercase.alpha">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key" select="'uppercase.alpha'"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="lowercase.alpha">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key" select="'lowercase.alpha'"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:value-of select="translate($string,$uppercase.alpha,$lowercase.alpha)"/>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="select.choice.separator">
        <refpurpose>Returns localized choice separator</refpurpose>
        <refdescription id="select.choice.separator-desc">
            <para>This template enables auto-generation of an appropriate
                localized "choice" separator (for example, "and" or "or") before
                the final item in an inline list (though it could also be useful
                for generating choice separators for non-inline lists).
            </para>
            <para>It currently works by evaluating a processing instruction
                (PI) of the form &lt;?dbchoice choice="foo"?&gt; :
                <itemizedlist>
                    <listitem>
                        <simpara>if the value of the
                            <tag>choice</tag>
                            pseudo-attribute is "and" or "or", returns a localized "and"
                            or "or"
                        </simpara>
                    </listitem>
                    <listitem>
                        <simpara>otherwise returns the literal value of the
                            <tag>choice</tag>
                            pseudo-attribute
                        </simpara>
                    </listitem>
                </itemizedlist>
                The latter is provided only as a temporary workaround because the
                locale files do not currently have translations for the word
                <wordasword>or</wordasword>. So if you want to generate a a
                logical "or" separator in French (for example), you currently need
                to do this:
                <literallayout>&lt;?dbchoice choice="ou"?&gt;</literallayout>
            </para>
            <warning>
                <para>The
                    <tag>dbchoice</tag>
                    processing instruction is
                    an unfortunate hack; support for it may disappear in the future
                    (particularly if and when a more appropriate means for marking
                    up "choice" lists becomes available in DocBook).
                </para>
            </warning>
        </refdescription>
    </doc:template>
    <xsl:template name="select.choice.separator">
        <xsl:variable name="choice">
            <xsl:call-template name="pi.dbchoice_choice"/>
        </xsl:variable>
        <xsl:choose>
            <!-- if value of $choice is "and" or "or", translate to equivalent in -->
            <!-- current locale -->
            <xsl:when test="$choice = 'and' or $choice = 'or'">
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="$choice"/>
                </xsl:call-template>
            </xsl:when>
            <!--  otherwise, just output value of $choice, whatever it is -->
            <xsl:otherwise>
                <xsl:value-of select="$choice"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="evaluate.info.profile">
        <refpurpose>Evaluates an info profile</refpurpose>
        <refdescription id="evaluate.info.profile-desc">
            <para>This template evaluates an "info profile" matching the XPath
                expression given by the
                <parameter>profile</parameter>
                parameter. It relies on the XSLT
                <function>evaluate()</function>
                extension function.
            </para>

            <para>The value of the
                <parameter>profile</parameter>
                parameter
                can include the literal string<literal>$info</literal>. If found
                in the value of the
                <parameter>profile</parameter>
                parameter, the
                literal string
                <literal>$info</literal>
                string is replaced with
                the value of the
                <parameter>info</parameter>
                parameter, which
                should be a set of
                <replaceable>*info</replaceable>
                nodes; the
                expression is then evaluated using the XSLT
                <function>evaluate()</function>
                extension function.
            </para>
        </refdescription>
        <refparameter id="evaluate.info.profile-params">
            <variablelist>
                <varlistentry>
                    <term>profile</term>
                    <listitem>
                        <para>A string representing an XPath expression</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>info</term>
                    <listitem>
                        <para>A set of *info nodes</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>

        <refreturn id="evaluate.info.profile-returns">
            <para>Returns a node (the result of evaluating the
                <parameter>profile</parameter>
                parameter)
            </para>
        </refreturn>
    </doc:template>
    <xsl:template name="evaluate.info.profile">
        <xsl:param name="profile"/>
        <xsl:param name="info"/>
        <xsl:choose>
            <!-- * xsltproc and Xalan both support dyn:evaluate() -->
            <xsl:when test="function-available('dyn:evaluate')">
                <xsl:apply-templates select="dyn:evaluate($profile)" mode="get.refentry.metadata"/>
            </xsl:when>
            <!-- * Saxon has its own evaluate() & doesn't support dyn:evaluate() -->
            <xsl:when test="function-available('saxon:evaluate')">
                <xsl:apply-templates select="saxon:evaluate($profile)" mode="get.refentry.metadata"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="yes">
                    Error: The "info profiling" mechanism currently requires an XSLT
                    engine that supports the evaluate() XSLT extension function. Your XSLT
                    engine does not support it.
                </xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="graphic.format.content-type">
        <refpurpose>Returns mimetype for media format</refpurpose>
        <refdescription id="graphic.format.content-type-desc">
            <para>This takes as input a 'format' param and returns
                a mimetype string. It uses an xsl:choose after first
                converting the input to all uppercase.
            </para>
        </refdescription>
    </doc:template>
    <xsl:template name="graphic.format.content-type">
        <xsl:param name="format"/>
        <xsl:variable name="upperformat"
                      select="translate($format,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')"/>
        <xsl:choose>
            <xsl:when test="$upperformat = ''"/>
            <xsl:when test="$upperformat = 'linespecific'"/>
            <xsl:when test="$upperformat = 'PS'">application/postscript</xsl:when>
            <xsl:when test="$upperformat = 'PDF'">application/pdf</xsl:when>
            <xsl:when test="$upperformat = 'PNG'">image/png</xsl:when>
            <xsl:when test="$upperformat = 'SVG'">image/svg+xml</xsl:when>
            <xsl:when test="$upperformat = 'JPG'">image/jpeg</xsl:when>
            <xsl:when test="$upperformat = 'JPEG'">image/jpeg</xsl:when>
            <xsl:when test="$upperformat = 'GIF'">image/gif</xsl:when>
            <xsl:when test="$upperformat = 'GIF87A'">image/gif</xsl:when>
            <xsl:when test="$upperformat = 'GIF89A'">image/gif</xsl:when>
            <xsl:when test="$upperformat = 'ACC'">audio/acc</xsl:when>
            <xsl:when test="$upperformat = 'MPG'">audio/mpeg</xsl:when>
            <xsl:when test="$upperformat = 'MP1'">audio/mpeg</xsl:when>
            <xsl:when test="$upperformat = 'MP2'">audio/mpeg</xsl:when>
            <xsl:when test="$upperformat = 'MP3'">audio/mpeg</xsl:when>
            <xsl:when test="$upperformat = 'M4A'">audio/mp4</xsl:when>
            <xsl:when test="$upperformat = 'MPEG'">audio/mpeg</xsl:when>
            <xsl:when test="$upperformat = 'WAV'">audio/wav</xsl:when>
            <xsl:when test="$upperformat = 'MP4'">video/mp4</xsl:when>
            <xsl:when test="$upperformat = 'M4V'">video/mp4</xsl:when>
            <xsl:when test="$upperformat = 'OGV'">video/ogg</xsl:when>
            <xsl:when test="$upperformat = 'OGG'">video/ogg</xsl:when>
            <xsl:when test="$upperformat = 'WEBM'">video/webm</xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="concat('image/', $upperformat)"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:reference xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" xml:id="utility">
        <info>
            <title>Common » Utility Template Reference</title>
            <releaseinfo role="meta">
                $Id: utility.xsl 7101 2007-07-20 15:32:12Z xmldoc $
            </releaseinfo>
        </info>
        <!-- * yes, partintro is a valid child of a reference... -->
        <partintro id="partintro">
            <title>Introduction</title>
            <para>This is technical reference documentation for the
                miscellaneous utility templates in the DocBook XSL
                Stylesheets.
            </para>
            <note>
                <para>These templates are defined in a separate file from the set
                    of “common” templates because some of the common templates
                    reference DocBook XSL stylesheet parameters, requiring the
                    entire set of parameters to be imported/included in any
                    stylesheet that imports/includes the common templates.
                </para>
                <para>The utility templates don’t import or include any DocBook
                    XSL stylesheet parameters, so the utility templates can be used
                    without importing the whole set of parameters.
                </para>
            </note>
            <para>This is not intended to be user documentation. It is
                provided for developers writing customization layers for the
                stylesheets.
            </para>
        </partintro>
    </doc:reference>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="log.message">
        <refpurpose>Logs/emits formatted notes and warnings</refpurpose>

        <refdescription id="log.message-desc">
            <para>The
                <function>log.message</function>
                template is a utility
                template for logging/emitting formatted messages – that is,
                notes and warnings, along with a given log “level” and an
                identifier for the “source” that the message relates to.
            </para>
        </refdescription>

        <refparameter id="log.message-params">
            <variablelist>
                <varlistentry>
                    <term>level</term>
                    <listitem>
                        <para>Text to log/emit in the message-level field to
                            indicate the message level
                            (
                            <literal>Note</literal>
                            or
                            <literal>Warning</literal>)
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>source</term>
                    <listitem>
                        <para>Text to log/emit in the source field to identify the
                            “source” to which the notification/warning relates.
                            This can be any arbitrary string, but because the
                            message lacks line and column numbers to identify the
                            exact part of the source document to which it
                            relates, the intention is that the value you pass
                            into the
                            <literal>source</literal>
                            parameter should
                            give the user some way to identify the portion of
                            their source document on which to take potentially
                            take action in response to the log message (for
                            example, to edit, change, or add content).
                        </para>
                        <para>So the
                            <literal>source</literal>
                            value should be,
                            for example, an ID, book/chapter/article title, title
                            of some formal object, or even a string giving an
                            XPath expression.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>context-desc</term>
                    <listitem>
                        <para>Text to log/emit in the context-description field to
                            describe the context for the message.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>context-desc-field-length</term>
                    <listitem>
                        <para>Specifies length of the context-description field
                            (in characters); default is 12
                        </para>
                        <para>If the text specified by the
                            <literal>context-desc</literal>
                            parameter is longer
                            than the number of characters specified in
                            <literal>context-desc-field-length</literal>, it is
                            truncated to
                            <literal>context-desc-field-length</literal>
                            (12 characters by default).
                        </para>
                        <para>If the specified text is shorter than
                            <literal>context-desc-field-length</literal>,
                            it is right-padded out to
                            <literal>context-desc-field-length</literal>
                            (12 by
                            default).
                        </para>
                        <para>If no value has been specified for the
                            <literal>context-desc</literal>
                            parameter, the field is
                            left empty and the text of the log message begins with
                            the value of the
                            <literal>message</literal>
                            parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>message</term>
                    <listitem>
                        <para>Text to log/emit in the actual message field</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>message-field-length</term>
                    <listitem>
                        <para>Specifies length of the message
                            field (in characters); default is 45
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refreturn id="log.message-returns">
            <para>Outputs a message (generally, to standard error).</para>
        </refreturn>
    </doc:template>
    <xsl:template name="log.message">
        <xsl:param name="level"/>
        <xsl:param name="source"/>
        <xsl:param name="context-desc"/>
        <xsl:param name="context-desc-field-length">12</xsl:param>
        <xsl:param name="context-desc-padded">
            <xsl:if test="not($context-desc = '')">
                <xsl:call-template name="pad-string">
                    <xsl:with-param name="leftRight">right</xsl:with-param>
                    <xsl:with-param name="padVar" select="substring($context-desc, 1, $context-desc-field-length)"/>
                    <xsl:with-param name="length" select="$context-desc-field-length"/>
                </xsl:call-template>
            </xsl:if>
        </xsl:param>
        <xsl:param name="message"/>
        <xsl:param name="message-field-length" select="45"/>
        <xsl:param name="message-padded">
            <xsl:variable name="spaces-for-blank-level">
                <!-- * if the level field is blank, we'll need to pad out -->
                <!-- * the message field with spaces to compensate -->
                <xsl:choose>
                    <xsl:when test="$level = ''">
                        <xsl:value-of select="4 + 2"/>
                        <!-- * 4 = hard-coded length of comment text ("Note" or "Warn") -->
                        <!-- * + 2 = length of colon-plus-space separator ": " -->
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="0"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:variable name="spaces-for-blank-context-desc">
                <!-- * if the context-description field is blank, we'll need -->
                <!-- * to pad out the message field with spaces to compensate -->
                <xsl:choose>
                    <xsl:when test="$context-desc = ''">
                        <xsl:value-of select="$context-desc-field-length + 2"/>
                        <!-- * + 2 = length of colon-plus-space separator ": " -->
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="0"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:variable name="extra-spaces" select="$spaces-for-blank-level + $spaces-for-blank-context-desc"/>
            <xsl:call-template name="pad-string">
                <xsl:with-param name="leftRight">right</xsl:with-param>
                <xsl:with-param name="padVar" select="substring($message, 1, ($message-field-length + $extra-spaces))"/>
                <xsl:with-param name="length" select="$message-field-length + $extra-spaces"/>
            </xsl:call-template>
        </xsl:param>
        <!-- * emit the actual log message -->
        <xsl:message>
            <xsl:if test="not($level = '')">
                <xsl:value-of select="$level"/>
                <xsl:text>: </xsl:text>
            </xsl:if>
            <xsl:if test="not($context-desc = '')">
                <xsl:value-of select="$context-desc-padded"/>
                <xsl:text>: </xsl:text>
            </xsl:if>
            <xsl:value-of select="$message-padded"/>
            <xsl:text>  </xsl:text>
            <xsl:value-of select="$source"/>
        </xsl:message>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="get.doc.title">
        <refpurpose>Gets a title from the current document</refpurpose>
        <refdescription id="get.doc.title-desc">
            <para>The
                <function>get.doc.title</function>
                template is a
                utility template for returning the first title found in the
                current document.
            </para>
        </refdescription>
        <refreturn id="get.doc.title-returns">
            <para>Returns a string containing some identifying title for the
                current document .
            </para>
        </refreturn>
    </doc:template>
    <xsl:template name="get.doc.title">
        <xsl:choose>
            <xsl:when test="//*[local-name() = 'title'       or local-name() = 'refname']">
                <xsl:value-of select="//*[local-name() = 'title'         or local-name() = 'refname'][1]"/>
            </xsl:when>
            <xsl:when
                    test="substring(local-name(*[1]),       string-length(local-name(*[1])-3) = 'info')       and *[1]/*[local-name() = 'title']">
                <xsl:value-of select="*[1]/*[local-name() = 'title'][1]"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="pad-string">
        <refpurpose>Right-pads or left-pads a string out to a certain length</refpurpose>
        <refdescription id="pad-string-desc">
            <para>This function takes string
                <parameter>padVar</parameter>
                and
                pads it out in the direction
                <parameter>rightLeft</parameter>
                to
                the string-length<parameter>length</parameter>, using string
                <parameter>padChar</parameter>
                (a space character by default) as
                the padding string (note that
                <parameter>padChar</parameter>
                can
                be a string; it is not limited to just being a single
                character).
            </para>
            <note>
                <para>This function began as a copy of Nate Austin's
                    <function>prepend-pad</function>
                    function in the
                    <link xmlns:xlink="http://www.w3.org/1999/xlink"
                          xlink:href="http://www.dpawson.co.uk/xsl/sect2/padding.html">Padding
                        Content
                    </link>
                    section of Dave Pawson's<link xmlns:xlink="http://www.w3.org/1999/xlink"
                                                  xlink:href="http://www.dpawson.co.uk/xsl/index.html">XSLT
                        FAQ</link>.
                </para>
            </note>
        </refdescription>
        <refreturn id="pad-string-returns">
            <para>Returns a (padded) string.</para>
        </refreturn>
    </doc:template>
    <xsl:template name="pad-string">
        <!-- * recursive template to right/left pad the value with -->
        <!-- * whatever padChar is passed in -->
        <xsl:param name="padChar" select="' '"/>
        <xsl:param name="leftRight">left</xsl:param>
        <xsl:param name="padVar"/>
        <xsl:param name="length"/>
        <xsl:choose>
            <xsl:when test="string-length($padVar) &lt; $length">
                <xsl:call-template name="pad-string">
                    <xsl:with-param name="padChar" select="$padChar"/>
                    <xsl:with-param name="leftRight" select="$leftRight"/>
                    <xsl:with-param name="padVar">
                        <xsl:choose>
                            <!-- * determine whether string should be -->
                            <!-- * right- or left-padded -->
                            <xsl:when test="$leftRight = 'left'">
                                <!-- * pad it to left -->
                                <xsl:value-of select="concat($padChar,$padVar)"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <!-- * otherwise, right-pad the string -->
                                <xsl:value-of select="concat($padVar,$padChar)"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:with-param>
                    <xsl:with-param name="length" select="$length"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="substring($padVar,string-length($padVar) - $length + 1)"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:mode xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" mode="label.markup">
        <refpurpose>Provides access to element labels</refpurpose>
        <refdescription id="label.markup-desc">
            <para>Processing an element in the
                <literal role="mode">label.markup</literal>
                mode produces the
                element label.
            </para>
            <para>Trailing punctuation is not added to the label.
            </para>
        </refdescription>
    </doc:mode>
    <xsl:template match="*" mode="intralabel.punctuation">
        <xsl:text>.</xsl:text>
    </xsl:template>
    <xsl:template match="*" mode="label.markup">
        <xsl:param name="verbose" select="1"/>
        <xsl:if test="$verbose">
            <xsl:message>
                <xsl:text>Request for label of unexpected element: </xsl:text>
                <xsl:value-of select="local-name(.)"/>
            </xsl:message>
        </xsl:if>
    </xsl:template>
    <xsl:template match="set|book" mode="label.markup">
        <xsl:if test="@label">
            <xsl:value-of select="@label"/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="part" mode="label.markup">
        <xsl:choose>
            <xsl:when test="@label">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:when test="string($part.autolabel) != 0">
                <xsl:variable name="format">
                    <xsl:call-template name="autolabel.format">
                        <xsl:with-param name="format" select="$part.autolabel"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:number from="book" count="part" format="{$format}"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="partintro" mode="label.markup">
        <!-- no label -->
    </xsl:template>
    <xsl:template match="preface" mode="label.markup">
        <xsl:choose>
            <xsl:when test="@label">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:when test="string($preface.autolabel) != 0">
                <xsl:if test="$component.label.includes.part.label != 0 and                       ancestor::part">
                    <xsl:variable name="part.label">
                        <xsl:apply-templates select="ancestor::part" mode="label.markup"/>
                    </xsl:variable>
                    <xsl:if test="$part.label != ''">
                        <xsl:value-of select="$part.label"/>
                        <xsl:apply-templates select="ancestor::part" mode="intralabel.punctuation"/>
                    </xsl:if>
                </xsl:if>
                <xsl:variable name="format">
                    <xsl:call-template name="autolabel.format">
                        <xsl:with-param name="format" select="$preface.autolabel"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:choose>
                    <xsl:when test="$label.from.part != 0 and ancestor::part">
                        <xsl:number from="part" count="preface" format="{$format}" level="any"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:number from="book" count="preface" format="{$format}" level="any"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="chapter" mode="label.markup">
        <xsl:choose>
            <xsl:when test="@label">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:when test="string($chapter.autolabel) != 0">
                <xsl:if test="$component.label.includes.part.label != 0 and                       ancestor::part">
                    <xsl:variable name="part.label">
                        <xsl:apply-templates select="ancestor::part" mode="label.markup"/>
                    </xsl:variable>
                    <xsl:if test="$part.label != ''">
                        <xsl:value-of select="$part.label"/>
                        <xsl:apply-templates select="ancestor::part" mode="intralabel.punctuation"/>
                    </xsl:if>
                </xsl:if>
                <xsl:variable name="format">
                    <xsl:call-template name="autolabel.format">
                        <xsl:with-param name="format" select="$chapter.autolabel"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:choose>
                    <xsl:when test="$label.from.part != 0 and ancestor::part">
                        <xsl:number from="part" count="chapter" format="{$format}" level="any"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:number from="book" count="chapter" format="{$format}" level="any"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="appendix" mode="label.markup">
        <xsl:choose>
            <xsl:when test="@label">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:when test="string($appendix.autolabel) != 0">
                <xsl:if test="$component.label.includes.part.label != 0 and                       ancestor::part">
                    <xsl:variable name="part.label">
                        <xsl:apply-templates select="ancestor::part" mode="label.markup"/>
                    </xsl:variable>
                    <xsl:if test="$part.label != ''">
                        <xsl:value-of select="$part.label"/>
                        <xsl:apply-templates select="ancestor::part" mode="intralabel.punctuation"/>
                    </xsl:if>
                </xsl:if>
                <xsl:variable name="format">
                    <xsl:call-template name="autolabel.format">
                        <xsl:with-param name="format" select="$appendix.autolabel"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:choose>
                    <xsl:when test="$label.from.part != 0 and ancestor::part">
                        <xsl:number from="part" count="appendix" format="{$format}" level="any"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:number from="book|article" count="appendix" format="{$format}" level="any"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="article" mode="label.markup">
        <xsl:if test="@label">
            <xsl:value-of select="@label"/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="dedication|colophon" mode="label.markup">
        <xsl:if test="@label">
            <xsl:value-of select="@label"/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="reference" mode="label.markup">
        <xsl:choose>
            <xsl:when test="@label">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:when test="string($reference.autolabel) != 0">
                <xsl:if test="$component.label.includes.part.label != 0 and                       ancestor::part">
                    <xsl:variable name="part.label">
                        <xsl:apply-templates select="ancestor::part" mode="label.markup"/>
                    </xsl:variable>
                    <xsl:if test="$part.label != ''">
                        <xsl:value-of select="$part.label"/>
                        <xsl:apply-templates select="ancestor::part" mode="intralabel.punctuation"/>
                    </xsl:if>
                </xsl:if>
                <xsl:variable name="format">
                    <xsl:call-template name="autolabel.format">
                        <xsl:with-param name="format" select="$reference.autolabel"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:choose>
                    <xsl:when test="$label.from.part != 0 and ancestor::part">
                        <xsl:number from="part" count="reference" format="{$format}" level="any"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:number from="book" count="reference" format="{$format}" level="any"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="refentry" mode="label.markup">
        <xsl:if test="@label">
            <xsl:value-of select="@label"/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="section" mode="label.markup">
        <!-- if this is a nested section, label the parent -->
        <xsl:if test="local-name(..) = 'section'">
            <xsl:variable name="parent.section.label">
                <xsl:call-template name="label.this.section">
                    <xsl:with-param name="section" select=".."/>
                </xsl:call-template>
            </xsl:variable>
            <xsl:if test="$parent.section.label != '0'">
                <xsl:apply-templates select=".." mode="label.markup"/>
                <xsl:apply-templates select=".." mode="intralabel.punctuation"/>
            </xsl:if>
        </xsl:if>

        <!-- if the parent is a component, maybe label that too -->
        <xsl:variable name="parent.is.component">
            <xsl:call-template name="is.component">
                <xsl:with-param name="node" select=".."/>
            </xsl:call-template>
        </xsl:variable>

        <!-- does this section get labelled? -->
        <xsl:variable name="label">
            <xsl:call-template name="label.this.section">
                <xsl:with-param name="section" select="."/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:if test="$section.label.includes.component.label != 0                 and $parent.is.component != 0">
            <xsl:variable name="parent.label">
                <xsl:apply-templates select=".." mode="label.markup"/>
            </xsl:variable>
            <xsl:if test="$parent.label != ''">
                <xsl:apply-templates select=".." mode="label.markup"/>
                <xsl:apply-templates select=".." mode="intralabel.punctuation"/>
            </xsl:if>
        </xsl:if>

        <!--
  <xsl:message>
    test: <xsl:value-of select="$label"/>, <xsl:number count="section"/>
  </xsl:message>
-->

        <xsl:choose>
            <xsl:when test="@label">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:when test="$label != 0">
                <xsl:variable name="format">
                    <xsl:call-template name="autolabel.format">
                        <xsl:with-param name="format" select="$section.autolabel"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:number format="{$format}" count="section"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="sect1" mode="label.markup">
        <!-- if the parent is a component, maybe label that too -->
        <xsl:variable name="parent.is.component">
            <xsl:call-template name="is.component">
                <xsl:with-param name="node" select=".."/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="component.label">
            <xsl:if test="$section.label.includes.component.label != 0                   and $parent.is.component != 0">
                <xsl:variable name="parent.label">
                    <xsl:apply-templates select=".." mode="label.markup"/>
                </xsl:variable>
                <xsl:if test="$parent.label != ''">
                    <xsl:apply-templates select=".." mode="label.markup"/>
                    <xsl:apply-templates select=".." mode="intralabel.punctuation"/>
                </xsl:if>
            </xsl:if>
        </xsl:variable>


        <xsl:variable name="is.numbered">
            <xsl:call-template name="label.this.section"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="@label">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:when test="$is.numbered != 0">
                <xsl:variable name="format">
                    <xsl:call-template name="autolabel.format">
                        <xsl:with-param name="format" select="$section.autolabel"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:copy-of select="$component.label"/>
                <xsl:number format="{$format}" count="sect1"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="sect2|sect3|sect4|sect5" mode="label.markup">
        <!-- label the parent -->
        <xsl:variable name="parent.section.label">
            <xsl:call-template name="label.this.section">
                <xsl:with-param name="section" select=".."/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:if test="$parent.section.label != '0'">
            <xsl:apply-templates select=".." mode="label.markup"/>
            <xsl:apply-templates select=".." mode="intralabel.punctuation"/>
        </xsl:if>

        <xsl:variable name="is.numbered">
            <xsl:call-template name="label.this.section"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="@label">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:when test="$is.numbered != 0">
                <xsl:variable name="format">
                    <xsl:call-template name="autolabel.format">
                        <xsl:with-param name="format" select="$section.autolabel"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:choose>
                    <xsl:when test="local-name(.) = 'sect2'">
                        <xsl:number format="{$format}" count="sect2"/>
                    </xsl:when>
                    <xsl:when test="local-name(.) = 'sect3'">
                        <xsl:number format="{$format}" count="sect3"/>
                    </xsl:when>
                    <xsl:when test="local-name(.) = 'sect4'">
                        <xsl:number format="{$format}" count="sect4"/>
                    </xsl:when>
                    <xsl:when test="local-name(.) = 'sect5'">
                        <xsl:number format="{$format}" count="sect5"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message>label.markup: this can't happen!</xsl:message>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="bridgehead" mode="label.markup">
        <!-- bridgeheads are not normally numbered -->
    </xsl:template>
    <xsl:template match="refsect1" mode="label.markup">
        <xsl:choose>
            <xsl:when test="@label">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:when test="$section.autolabel != 0">
                <xsl:variable name="format">
                    <xsl:call-template name="autolabel.format">
                        <xsl:with-param name="format" select="$section.autolabel"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:number count="refsect1" format="{$format}"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="refsect2|refsect3" mode="label.markup">
        <!-- label the parent -->
        <xsl:variable name="parent.label">
            <xsl:apply-templates select=".." mode="label.markup"/>
        </xsl:variable>
        <xsl:if test="$parent.label != ''">
            <xsl:apply-templates select=".." mode="label.markup"/>
            <xsl:apply-templates select=".." mode="intralabel.punctuation"/>
        </xsl:if>

        <xsl:choose>
            <xsl:when test="@label">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:when test="$section.autolabel != 0">
                <xsl:variable name="format">
                    <xsl:call-template name="autolabel.format">
                        <xsl:with-param name="format" select="$section.autolabel"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:choose>
                    <xsl:when test="local-name(.) = 'refsect2'">
                        <xsl:number count="refsect2" format="{$format}"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:number count="refsect3" format="{$format}"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="simplesect" mode="label.markup">
        <!-- if this is a nested section, label the parent -->
        <xsl:if test="local-name(..) = 'section'                 or local-name(..) = 'sect1'                 or local-name(..) = 'sect2'                 or local-name(..) = 'sect3'                 or local-name(..) = 'sect4'                 or local-name(..) = 'sect5'">
            <xsl:variable name="parent.section.label">
                <xsl:apply-templates select=".." mode="label.markup"/>
            </xsl:variable>
            <xsl:if test="$parent.section.label != ''">
                <xsl:apply-templates select=".." mode="label.markup"/>
                <xsl:apply-templates select=".." mode="intralabel.punctuation"/>
            </xsl:if>
        </xsl:if>

        <!-- if the parent is a component, maybe label that too -->
        <xsl:variable name="parent.is.component">
            <xsl:call-template name="is.component">
                <xsl:with-param name="node" select=".."/>
            </xsl:call-template>
        </xsl:variable>

        <!-- does this section get labelled? -->
        <xsl:variable name="label">
            <xsl:call-template name="label.this.section">
                <xsl:with-param name="section" select="."/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:if test="$section.label.includes.component.label != 0                 and $parent.is.component != 0">
            <xsl:variable name="parent.label">
                <xsl:apply-templates select=".." mode="label.markup"/>
            </xsl:variable>
            <xsl:if test="$parent.label != ''">
                <xsl:apply-templates select=".." mode="label.markup"/>
                <xsl:apply-templates select=".." mode="intralabel.punctuation"/>
            </xsl:if>
        </xsl:if>

        <xsl:choose>
            <xsl:when test="@label">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:when test="$label != 0">
                <xsl:variable name="format">
                    <xsl:call-template name="autolabel.format">
                        <xsl:with-param name="format" select="$section.autolabel"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:number format="{$format}" count="simplesect"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="topic" mode="label.markup">
        <!-- topics are not numbered by default -->
    </xsl:template>
    <xsl:template match="qandadiv" mode="label.markup">
        <xsl:variable name="lparent"
                      select="(ancestor::set                                        |ancestor::book                                        |ancestor::chapter                                        |ancestor::appendix                                        |ancestor::preface                                        |ancestor::section                                        |ancestor::simplesect                                        |ancestor::sect1                                        |ancestor::sect2                                        |ancestor::sect3                                        |ancestor::sect4                                        |ancestor::sect5                                        |ancestor::refsect1                                        |ancestor::refsect2                                        |ancestor::refsect3)[last()]"/>

        <xsl:variable name="lparent.prefix">
            <xsl:apply-templates select="$lparent" mode="label.markup"/>
        </xsl:variable>

        <xsl:variable name="prefix">
            <xsl:if test="$qanda.inherit.numeration != 0">
                <xsl:if test="$lparent.prefix != ''">
                    <xsl:apply-templates select="$lparent" mode="label.markup"/>
                    <xsl:apply-templates select="$lparent" mode="intralabel.punctuation"/>
                </xsl:if>
            </xsl:if>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$qandadiv.autolabel != 0">
                <xsl:variable name="format">
                    <xsl:call-template name="autolabel.format">
                        <xsl:with-param name="format" select="$qandadiv.autolabel"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:value-of select="$prefix"/>
                <xsl:number level="multiple" count="qandadiv" format="{$format}"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="question|answer" mode="label.markup">
        <xsl:variable name="lparent"
                      select="(ancestor::set                                        |ancestor::book                                        |ancestor::chapter                                        |ancestor::appendix                                        |ancestor::preface                                        |ancestor::section                                        |ancestor::simplesect                                        |ancestor::sect1                                        |ancestor::sect2                                        |ancestor::sect3                                        |ancestor::sect4                                        |ancestor::sect5                                        |ancestor::refsect1                                        |ancestor::refsect2                                        |ancestor::refsect3)[last()]"/>

        <xsl:variable name="lparent.prefix">
            <xsl:apply-templates select="$lparent" mode="label.markup"/>
        </xsl:variable>

        <xsl:variable name="prefix">
            <xsl:if test="$qanda.inherit.numeration != 0">
                <xsl:choose>
                    <xsl:when test="ancestor::qandadiv">
                        <xsl:variable name="div.label">
                            <xsl:apply-templates select="ancestor::qandadiv[1]" mode="label.markup"/>
                        </xsl:variable>
                        <xsl:if test="string-length($div.label) != 0">
                            <xsl:copy-of select="$div.label"/>
                            <xsl:apply-templates select="ancestor::qandadiv[1]" mode="intralabel.punctuation"/>
                        </xsl:if>
                    </xsl:when>
                    <xsl:when test="$lparent.prefix != ''">
                        <xsl:apply-templates select="$lparent" mode="label.markup"/>
                        <xsl:apply-templates select="$lparent" mode="intralabel.punctuation"/>
                    </xsl:when>
                </xsl:choose>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="inhlabel" select="ancestor-or-self::qandaset/@defaultlabel[1]"/>

        <xsl:variable name="deflabel">
            <xsl:choose>
                <xsl:when test="$inhlabel != ''">
                    <xsl:value-of select="$inhlabel"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$qanda.defaultlabel"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="label" select="label"/>

        <xsl:choose>
            <xsl:when test="count($label)&gt;0">
                <xsl:apply-templates select="$label"/>
            </xsl:when>

            <xsl:when test="$deflabel = 'qanda' and self::question">
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'Question'"/>
                </xsl:call-template>
            </xsl:when>

            <xsl:when test="$deflabel = 'qanda' and self::answer">
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'Answer'"/>
                </xsl:call-template>
            </xsl:when>

            <xsl:when
                    test="($deflabel = 'qnumber' or                      $deflabel = 'qnumberanda') and self::question">
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'Question'"/>
                </xsl:call-template>
                <xsl:text> </xsl:text>
                <xsl:value-of select="$prefix"/>
                <xsl:number level="multiple" count="qandaentry" format="1"/>
            </xsl:when>

            <xsl:when test="$deflabel = 'qnumberanda' and self::answer">
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'Answer'"/>
                </xsl:call-template>
            </xsl:when>

            <xsl:when test="$deflabel = 'number' and self::question">
                <xsl:value-of select="$prefix"/>
                <xsl:number level="multiple" count="qandaentry" format="1"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="bibliography|glossary|                      qandaset|index|setindex" mode="label.markup">
        <xsl:if test="@label">
            <xsl:value-of select="@label"/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="figure|table|example" mode="label.markup">
        <xsl:variable name="pchap"
                      select="(ancestor::chapter                         |ancestor::appendix                         |ancestor::article[ancestor::book])[last()]"/>

        <xsl:variable name="prefix">
            <xsl:if test="count($pchap) &gt; 0">
                <xsl:apply-templates select="$pchap" mode="label.markup"/>
            </xsl:if>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="@label">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="$prefix != ''">
                        <xsl:apply-templates select="$pchap" mode="label.markup"/>
                        <xsl:apply-templates select="$pchap" mode="intralabel.punctuation"/>
                        <xsl:number format="1" from="chapter|appendix" level="any"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:number format="1" from="book|article|section" level="any"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="procedure" mode="label.markup">
        <xsl:variable name="pchap"
                      select="ancestor::chapter                         |ancestor::appendix                         |ancestor::article[ancestor::book]"/>

        <xsl:variable name="prefix">
            <xsl:if test="count($pchap) &gt; 0">
                <xsl:apply-templates select="$pchap" mode="label.markup"/>
            </xsl:if>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="@label">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:when test="$formal.procedures = 0">
                <!-- No label -->
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="count($pchap)&gt;0">
                        <xsl:if test="$prefix != ''">
                            <xsl:apply-templates select="$pchap" mode="label.markup"/>
                            <xsl:apply-templates select="$pchap" mode="intralabel.punctuation"/>
                        </xsl:if>
                        <xsl:number count="procedure[title]" format="1" from="chapter|appendix" level="any"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:number count="procedure[title]" format="1" from="book|article|section" level="any"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="equation" mode="label.markup">
        <xsl:variable name="pchap"
                      select="ancestor::chapter                         |ancestor::appendix                         |ancestor::article[ancestor::book]"/>

        <xsl:variable name="prefix">
            <xsl:if test="count($pchap) &gt; 0">
                <xsl:apply-templates select="$pchap" mode="label.markup"/>
            </xsl:if>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="@label">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="count($pchap)&gt;0">
                        <xsl:if test="$prefix != ''">
                            <xsl:apply-templates select="$pchap" mode="label.markup"/>
                            <xsl:apply-templates select="$pchap" mode="intralabel.punctuation"/>
                        </xsl:if>
                        <xsl:number format="1" count="equation" from="chapter|appendix" level="any"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:number format="1" count="equation" from="book|article|section" level="any"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="orderedlist/listitem" mode="label.markup">
        <xsl:variable name="numeration">
            <xsl:call-template name="list.numeration">
                <xsl:with-param name="node" select="parent::orderedlist"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="type">
            <xsl:choose>
                <xsl:when test="$numeration='arabic'">1</xsl:when>
                <xsl:when test="$numeration='loweralpha'">a</xsl:when>
                <xsl:when test="$numeration='lowerroman'">i</xsl:when>
                <xsl:when test="$numeration='upperalpha'">A</xsl:when>
                <xsl:when test="$numeration='upperroman'">I</xsl:when>
                <!-- What!? This should never happen -->
                <xsl:otherwise>
                    <xsl:message>
                        <xsl:text>Unexpected numeration: </xsl:text>
                        <xsl:value-of select="$numeration"/>
                    </xsl:message>
                    <xsl:value-of select="1."/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="item-number">
            <xsl:call-template name="orderedlist-item-number"/>
        </xsl:variable>

        <xsl:number value="$item-number" format="{$type}"/>
    </xsl:template>
    <xsl:template match="production" mode="label.markup">
        <xsl:number count="production" level="any"/>
    </xsl:template>
    <xsl:template match="abstract" mode="label.markup">
        <!-- nop -->
    </xsl:template>
    <xsl:template match="sidebar" mode="label.markup">
        <!-- nop -->
    </xsl:template>
    <xsl:template match="glossdiv|glosslist" mode="label.markup">
        <!-- nop -->
    </xsl:template>
    <xsl:template match="glossentry" mode="label.markup">
        <!-- nop -->
    </xsl:template>
    <xsl:template name="label.this.section">
        <xsl:param name="section" select="."/>

        <xsl:variable name="level">
            <xsl:call-template name="section.level"/>
        </xsl:variable>

        <xsl:choose>
            <!-- bridgeheads are not numbered -->
            <xsl:when test="$section/self::bridgehead">0</xsl:when>
            <xsl:when test="$level &lt;= $section.autolabel.max.depth">
                <xsl:value-of select="$section.autolabel"/>
            </xsl:when>
            <xsl:otherwise>0</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="label.this.section">
        <refpurpose>Returns true if $section should be labelled</refpurpose>
        <refdescription id="label.this.section-desc">
            <para>Returns true if the specified section should be labelled.
                By default, this template returns zero unless
                the section level is less than or equal to the value of the
                <literal>$section.autolabel.max.depth</literal>
                parameter, in
                which case it returns
                <literal>$section.autolabel</literal>.
                Custom stylesheets may override it to get more selective behavior.
            </para>
        </refdescription>
    </doc:template>
    <xsl:template name="default.autolabel.format">
        <xsl:param name="context" select="."/>
        <xsl:choose>
            <xsl:when test="local-name($context) = 'appendix'">
                <xsl:value-of select="'A'"/>
            </xsl:when>
            <xsl:when test="local-name($context) = 'part'">
                <xsl:value-of select="'I'"/>
            </xsl:when>
            <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="autolabel.format">
        <xsl:param name="context" select="."/>
        <xsl:param name="format"/>

        <xsl:choose>
            <xsl:when test="string($format) != 0">
                <xsl:choose>
                    <xsl:when test="string($format)='arabic' or $format='1'">1</xsl:when>
                    <xsl:when test="$format='loweralpha' or $format='a'">
                        <xsl:value-of select="'a'"/>
                    </xsl:when>
                    <xsl:when test="$format='lowerroman' or $format='i'">
                        <xsl:value-of select="'i'"/>
                    </xsl:when>
                    <xsl:when test="$format='upperalpha' or $format='A'">
                        <xsl:value-of select="'A'"/>
                    </xsl:when>
                    <xsl:when test="$format='upperroman' or $format='I'">
                        <xsl:value-of select="'I'"/>
                    </xsl:when>
                    <xsl:when test="$format='arabicindic' or $format='&#x661;'">
                        <xsl:value-of select="'&#x661;'"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message>
                            <xsl:text>Unexpected </xsl:text><xsl:value-of select="local-name(.)"/><xsl:text>.autolabel value: </xsl:text>
                            <xsl:value-of select="$format"/><xsl:text>; using default.</xsl:text>
                        </xsl:message>
                        <xsl:call-template name="default.autolabel.format"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="autolabel.format">
        <refpurpose>Returns format for autolabel parameters</refpurpose>
        <refdescription id="autolabel.format-desc">
            <para>Returns format passed as parameter if non zero. Supported
                format are 'arabic' or '1', 'loweralpha' or 'a', 'lowerroman' or 'i',
                'upperlapha' or 'A', 'upperroman' or 'I', 'arabicindic' or '١'.
                If its not one of these then
                returns the default format.
            </para>
        </refdescription>
    </doc:template>
    <doc:mode xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" mode="title.markup">
        <refpurpose>Provides access to element titles</refpurpose>
        <refdescription id="title.markup-desc">
            <para>Processing an element in the
                <literal role="mode">title.markup</literal>
                mode produces the
                title of the element. This does not include the label.
            </para>
        </refdescription>
    </doc:mode>
    <xsl:template match="*" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:param name="verbose" select="1"/>
        <xsl:choose>
            <!-- * FIXME: this should handle other *info elements as well -->
            <!-- * but this is good enough for now. -->
            <xsl:when test="title|info/title">
                <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:when test="local-name(.) = 'partintro'">
                <!-- partintro's don't have titles, use the parent (part or reference)
           title instead. -->
                <xsl:apply-templates select="parent::*" mode="title.markup"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:if test="$verbose != 0">
                    <xsl:message>
                        <xsl:text>Request for title of element with no title: </xsl:text>
                        <xsl:value-of select="local-name(.)"/>
                        <xsl:choose>
                            <xsl:when test="@id">
                                <xsl:text> (id="</xsl:text>
                                <xsl:value-of select="@id"/>
                                <xsl:text>")</xsl:text>
                            </xsl:when>
                            <xsl:when test="@xml:id">
                                <xsl:text> (xml:id="</xsl:text>
                                <xsl:value-of select="@xml:id"/>
                                <xsl:text>")</xsl:text>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:text> (contained in </xsl:text>
                                <xsl:value-of select="local-name(..)"/>
                                <xsl:if test="../@id or ../@xml:id">
                                    <xsl:text> with id </xsl:text>
                                    <xsl:value-of select="../@id | ../@xml:id"/>
                                </xsl:if>
                                <xsl:text>)</xsl:text>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:message>
                </xsl:if>
                <xsl:text>???TITLE???</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="title" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>

        <xsl:choose>
            <xsl:when test="$allow-anchors != 0">
                <xsl:apply-templates/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="no.anchor.mode"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="caption" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>

        <xsl:choose>
            <xsl:when test="$allow-anchors != 0">
                <xsl:apply-templates/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="no.anchor.mode"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="set" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:apply-templates select="(setinfo/title|info/title|title)[1]" mode="title.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="book" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:apply-templates select="(bookinfo/title|info/title|title)[1]" mode="title.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="part" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:apply-templates select="(partinfo/title|info/title|docinfo/title|title)[1]" mode="title.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="preface|chapter|appendix" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>

        <!--
  <xsl:message>
    <xsl:value-of select="local-name(.)"/>
    <xsl:text> </xsl:text>
    <xsl:value-of select="$allow-anchors"/>
  </xsl:message>
-->

        <xsl:variable name="title"
                      select="(docinfo/title                                       |info/title                                       |prefaceinfo/title                                       |chapterinfo/title                                       |appendixinfo/title                                       |title)[1]"/>
        <xsl:apply-templates select="$title" mode="title.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="dedication" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:choose>
            <xsl:when test="title|info/title">
                <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'Dedication'"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="acknowledgements" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:choose>
            <xsl:when test="title|info/title">
                <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'Acknowledgements'"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="colophon" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:choose>
            <xsl:when test="title|info/title">
                <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'Colophon'"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="article" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:variable name="title"
                      select="(artheader/title                                       |articleinfo/title                                       |info/title                                       |title)[1]"/>

        <xsl:apply-templates select="$title" mode="title.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="reference" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:apply-templates select="(referenceinfo/title|docinfo/title|info/title|title)[1]" mode="title.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="refentry" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:variable name="refmeta" select=".//refmeta"/>
        <xsl:variable name="refentrytitle" select="$refmeta//refentrytitle"/>
        <xsl:variable name="refnamediv" select=".//refnamediv"/>
        <xsl:variable name="refname" select="$refnamediv//refname"/>
        <xsl:variable name="refdesc" select="$refnamediv//refdescriptor"/>

        <xsl:variable name="title">
            <xsl:choose>
                <xsl:when test="$refentrytitle">
                    <xsl:apply-templates select="$refentrytitle[1]" mode="title.markup"/>
                </xsl:when>
                <xsl:when test="$refdesc">
                    <xsl:apply-templates select="$refdesc" mode="title.markup"/>
                </xsl:when>
                <xsl:when test="$refname">
                    <xsl:apply-templates select="$refname[1]" mode="title.markup"/>
                </xsl:when>
                <xsl:otherwise>REFENTRY WITHOUT TITLE???</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:copy-of select="$title"/>
    </xsl:template>
    <xsl:template match="refentrytitle|refname|refdescriptor" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:choose>
            <xsl:when test="$allow-anchors != 0">
                <xsl:apply-templates/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="no.anchor.mode"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template
            match="section                      |sect1|sect2|sect3|sect4|sect5                      |refsect1|refsect2|refsect3|refsection                      |topic                      |simplesect"
            mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:variable name="title"
                      select="(info/title                                       |sectioninfo/title                                       |sect1info/title                                       |sect2info/title                                       |sect3info/title                                       |sect4info/title                                       |sect5info/title                                       |refsect1info/title                                       |refsect2info/title                                       |refsect3info/title                                       |refsectioninfo/title                                       |title)[1]"/>

        <xsl:apply-templates select="$title" mode="title.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="bridgehead" mode="title.markup">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="refsynopsisdiv" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:choose>
            <xsl:when test="title|info/title">
                <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'RefSynopsisDiv'"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="bibliography" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:variable name="title" select="(bibliographyinfo/title|info/title|title)[1]"/>
        <xsl:choose>
            <xsl:when test="$title">
                <xsl:apply-templates select="$title" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'Bibliography'"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="glossary" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:variable name="title" select="(glossaryinfo/title|info/title|title)[1]"/>
        <xsl:choose>
            <xsl:when test="$title">
                <xsl:apply-templates select="$title" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext.element.name">
                    <xsl:with-param name="element.name" select="local-name(.)"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="glossdiv" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:variable name="title" select="(info/title|title)[1]"/>
        <xsl:choose>
            <xsl:when test="$title">
                <xsl:apply-templates select="$title" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>ERROR: glossdiv missing its required title</xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="glossentry" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:apply-templates select="glossterm" mode="title.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="glossterm|firstterm" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>

        <xsl:choose>
            <xsl:when test="$allow-anchors != 0">
                <xsl:apply-templates/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="no.anchor.mode"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="index" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:variable name="title" select="(indexinfo/title|info/title|title)[1]"/>
        <xsl:choose>
            <xsl:when test="$title">
                <xsl:apply-templates select="$title" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'Index'"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="setindex" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:variable name="title" select="(setindexinfo/title|info/title|title)[1]"/>
        <xsl:choose>
            <xsl:when test="$title">
                <xsl:apply-templates select="$title" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'SetIndex'"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="figure|example|equation" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="table" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:apply-templates select="(title|info/title|caption)[1]" mode="title.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="procedure" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="task" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="sidebar" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:apply-templates select="(info/title|sidebarinfo/title|title)[1]" mode="title.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="abstract" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:choose>
            <xsl:when test="title|info/title">
                <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'Abstract'"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="caution|tip|warning|important|note" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:variable name="title" select="(title|info/title)[1]"/>
        <xsl:choose>
            <xsl:when test="$title">
                <xsl:apply-templates select="$title" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key">
                        <xsl:choose>
                            <xsl:when test="local-name(.)='note'">Note</xsl:when>
                            <xsl:when test="local-name(.)='important'">Important</xsl:when>
                            <xsl:when test="local-name(.)='caution'">Caution</xsl:when>
                            <xsl:when test="local-name(.)='warning'">Warning</xsl:when>
                            <xsl:when test="local-name(.)='tip'">Tip</xsl:when>
                        </xsl:choose>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="question" mode="title.markup">
        <!-- questions don't have titles -->
        <xsl:text>Question</xsl:text>
    </xsl:template>
    <xsl:template match="answer" mode="title.markup">
        <!-- answers don't have titles -->
        <xsl:text>Answer</xsl:text>
    </xsl:template>
    <xsl:template match="qandaentry" mode="title.markup">
        <!-- qandaentrys are represented by the first question in them -->
        <xsl:text>Question</xsl:text>
    </xsl:template>
    <xsl:template match="qandaset" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:variable name="title"
                      select="(info/title|                                       blockinfo/title|                                       title)[1]"/>
        <xsl:choose>
            <xsl:when test="$title">
                <xsl:apply-templates select="$title" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'QandASet'"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="legalnotice" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:choose>
            <xsl:when test="title|info/title">
                <xsl:apply-templates select="(title|info/title)[1]" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'LegalNotice'"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="titleabbrev"/>
    <xsl:template match="*" mode="titleabbrev.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:choose>
            <xsl:when test="titleabbrev">
                <xsl:apply-templates select="titleabbrev[1]" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:when test="info/titleabbrev">
                <xsl:apply-templates select="info/titleabbrev[1]" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="." mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                    <xsl:with-param name="verbose" select="$verbose"/>
                </xsl:apply-templates>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="book|part|set|preface|chapter|appendix" mode="titleabbrev.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:variable name="titleabbrev"
                      select="(docinfo/titleabbrev                                            |bookinfo/titleabbrev                                            |info/titleabbrev                                            |prefaceinfo/titleabbrev                                            |setinfo/titleabbrev                                            |partinfo/titleabbrev                                            |chapterinfo/titleabbrev                                            |appendixinfo/titleabbrev                                            |titleabbrev)[1]"/>

        <xsl:choose>
            <xsl:when test="$titleabbrev">
                <xsl:apply-templates select="$titleabbrev" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="." mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                    <xsl:with-param name="verbose" select="$verbose"/>
                </xsl:apply-templates>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="article" mode="titleabbrev.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:variable name="titleabbrev"
                      select="(artheader/titleabbrev                                            |articleinfo/titleabbrev                                            |info/titleabbrev                                            |titleabbrev)[1]"/>

        <xsl:choose>
            <xsl:when test="$titleabbrev">
                <xsl:apply-templates select="$titleabbrev" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="." mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                    <xsl:with-param name="verbose" select="$verbose"/>
                </xsl:apply-templates>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template
            match="section                      |sect1|sect2|sect3|sect4|sect5                      |refsect1|refsect2|refsect3                      |topic                      |simplesect"
            mode="titleabbrev.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:variable name="titleabbrev"
                      select="(info/titleabbrev                                             |sectioninfo/titleabbrev                                             |sect1info/titleabbrev                                             |sect2info/titleabbrev                                             |sect3info/titleabbrev                                             |sect4info/titleabbrev                                             |sect5info/titleabbrev                                             |refsect1info/titleabbrev                                             |refsect2info/titleabbrev                                             |refsect3info/titleabbrev                                             |titleabbrev)[1]"/>

        <xsl:choose>
            <xsl:when test="$titleabbrev">
                <xsl:apply-templates select="$titleabbrev" mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="." mode="title.markup">
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                    <xsl:with-param name="verbose" select="$verbose"/>
                </xsl:apply-templates>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="titleabbrev" mode="title.markup">
        <xsl:param name="allow-anchors" select="0"/>

        <xsl:choose>
            <xsl:when test="$allow-anchors != 0">
                <xsl:apply-templates/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="no.anchor.mode"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*" mode="no.anchor.mode">
        <!-- Switch to normal mode if no links -->
        <xsl:choose>
            <xsl:when
                    test="descendant-or-self::footnote or                     descendant-or-self::anchor or                     descendant-or-self::ulink or                     descendant-or-self::link or                     descendant-or-self::olink or                     descendant-or-self::xref or                     descendant-or-self::indexterm or       (ancestor::title and (@id or @xml:id))">

                <xsl:apply-templates mode="no.anchor.mode"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="."/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="footnote" mode="no.anchor.mode">
        <!-- nop, suppressed -->
    </xsl:template>
    <xsl:template match="anchor" mode="no.anchor.mode">
        <!-- nop, suppressed -->
    </xsl:template>
    <xsl:template match="ulink" mode="no.anchor.mode">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="link" mode="no.anchor.mode">
        <xsl:choose>
            <xsl:when test="count(child::node()) &gt; 0">
                <!-- If it has content, use it -->
                <xsl:apply-templates/>
            </xsl:when>
            <!-- look for an endterm -->
            <xsl:when test="@endterm">
                <xsl:variable name="etargets" select="key('id',@endterm)"/>
                <xsl:variable name="etarget" select="$etargets[1]"/>
                <xsl:choose>
                    <xsl:when test="count($etarget) = 0">
                        <xsl:message>
                            <xsl:value-of select="count($etargets)"/>
                            <xsl:text>Endterm points to nonexistent ID: </xsl:text>
                            <xsl:value-of select="@endterm"/>
                        </xsl:message>
                        <xsl:text>???</xsl:text>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="$etarget" mode="endterm"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="olink" mode="no.anchor.mode">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="indexterm" mode="no.anchor.mode">
        <!-- nop, suppressed -->
    </xsl:template>
    <xsl:template match="xref" mode="no.anchor.mode">
        <xsl:variable name="targets" select="key('id',@linkend)|key('id',substring-after(@xlink:href,'#'))"/>
        <xsl:variable name="target" select="$targets[1]"/>
        <xsl:variable name="refelem" select="local-name($target)"/>

        <xsl:call-template name="check.id.unique">
            <xsl:with-param name="linkend" select="@linkend"/>
        </xsl:call-template>

        <xsl:choose>
            <xsl:when test="count($target) = 0">
                <xsl:message>
                    <xsl:text>XRef to nonexistent id: </xsl:text>
                    <xsl:value-of select="@linkend"/>
                    <xsl:value-of select="@xlink:href"/>
                </xsl:message>
                <xsl:text>???</xsl:text>
            </xsl:when>

            <xsl:when test="@endterm">
                <xsl:variable name="etargets" select="key('id',@endterm)"/>
                <xsl:variable name="etarget" select="$etargets[1]"/>
                <xsl:choose>
                    <xsl:when test="count($etarget) = 0">
                        <xsl:message>
                            <xsl:value-of select="count($etargets)"/>
                            <xsl:text>Endterm points to nonexistent ID: </xsl:text>
                            <xsl:value-of select="@endterm"/>
                        </xsl:message>
                        <xsl:text>???</xsl:text>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="$etarget" mode="endterm"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>

            <xsl:when test="$target/@xreflabel">
                <xsl:call-template name="xref.xreflabel">
                    <xsl:with-param name="target" select="$target"/>
                </xsl:call-template>
            </xsl:when>

            <xsl:otherwise>

                <xsl:choose>
                    <!-- Watch out for the case when there is a xref or link inside 
	     a title. See bugs #1811721 and #1838136. -->
                    <xsl:when test="not(ancestor::*[@id = $target/@id] or ancestor::*[@xml:id = $target/@xml:id])">

                        <xsl:apply-templates select="$target" mode="xref-to-prefix"/>

                        <xsl:apply-templates select="$target" mode="xref-to">

                            <xsl:with-param name="referrer" select="."/>
                            <xsl:with-param name="xrefstyle">
                                <xsl:choose>
                                    <xsl:when test="@role and not(@xrefstyle) and $use.role.as.xrefstyle != 0">
                                        <xsl:value-of select="@role"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:value-of select="@xrefstyle"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:with-param>
                        </xsl:apply-templates>

                        <xsl:apply-templates select="$target" mode="xref-to-suffix"/>
                    </xsl:when>

                    <xsl:otherwise>
                        <xsl:apply-templates/>
                    </xsl:otherwise>

                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>

    </xsl:template>
    <doc:mode xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" mode="subtitle.markup">
        <refpurpose>Provides access to element subtitles</refpurpose>
        <refdescription id="subtitle.markup-desc">
            <para>Processing an element in the
                <literal role="mode">subtitle.markup</literal>
                mode produces the
                subtitle of the element.
            </para>
        </refdescription>
    </doc:mode>
    <xsl:template match="*" mode="subtitle.markup">
        <xsl:param name="verbose" select="1"/>
        <xsl:if test="$verbose != 0">
            <xsl:message>
                <xsl:text>Request for subtitle of unexpected element: </xsl:text>
                <xsl:value-of select="local-name(.)"/>
            </xsl:message>
            <xsl:text>???SUBTITLE???</xsl:text>
        </xsl:if>
    </xsl:template>
    <xsl:template match="subtitle" mode="subtitle.markup">
        <xsl:param name="allow-anchors" select="'0'"/>
        <xsl:param name="verbose" select="1"/>
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="set" mode="subtitle.markup">
        <xsl:param name="allow-anchors" select="'0'"/>
        <xsl:param name="verbose" select="1"/>
        <xsl:apply-templates select="(setinfo/subtitle|info/subtitle|subtitle)[1]" mode="subtitle.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="book" mode="subtitle.markup">
        <xsl:param name="allow-anchors" select="'0'"/>
        <xsl:param name="verbose" select="1"/>
        <xsl:apply-templates select="(bookinfo/subtitle|info/subtitle|subtitle)[1]" mode="subtitle.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="part" mode="subtitle.markup">
        <xsl:param name="allow-anchors" select="'0'"/>
        <xsl:param name="verbose" select="1"/>
        <xsl:apply-templates
                select="(partinfo/subtitle                                 |docinfo/subtitle                                 |info/subtitle                                 |subtitle)[1]"
                mode="subtitle.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="preface|chapter|appendix" mode="subtitle.markup">
        <xsl:param name="allow-anchors" select="'0'"/>
        <xsl:param name="verbose" select="1"/>
        <xsl:apply-templates
                select="(docinfo/subtitle                                 |info/subtitle                                 |prefaceinfo/subtitle                                 |chapterinfo/subtitle                                 |appendixinfo/subtitle                                 |subtitle)[1]"
                mode="subtitle.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="article" mode="subtitle.markup">
        <xsl:param name="allow-anchors" select="'0'"/>
        <xsl:param name="verbose" select="1"/>
        <xsl:apply-templates
                select="(artheader/subtitle                                 |articleinfo/subtitle                                 |info/subtitle                                 |subtitle)[1]"
                mode="subtitle.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="dedication|colophon" mode="subtitle.markup">
        <xsl:param name="allow-anchors" select="'0'"/>
        <xsl:param name="verbose" select="1"/>
        <xsl:apply-templates select="(subtitle|info/subtitle)[1]" mode="subtitle.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="reference" mode="subtitle.markup">
        <xsl:param name="allow-anchors" select="'0'"/>
        <xsl:param name="verbose" select="1"/>
        <xsl:apply-templates
                select="(referenceinfo/subtitle                                 |docinfo/subtitle                                 |info/subtitle                                 |subtitle)[1]"
                mode="subtitle.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="qandaset" mode="subtitle.markup">
        <xsl:param name="allow-anchors" select="'0'"/>
        <xsl:param name="verbose" select="1"/>
        <xsl:apply-templates select="(blockinfo/subtitle|info/subtitle)[1]" mode="subtitle.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="refentry" mode="subtitle.markup">
        <xsl:param name="allow-anchors" select="'0'"/>
        <xsl:param name="verbose" select="1"/>
        <xsl:apply-templates
                select="(refentryinfo/subtitle                                 |info/subtitle                                 |docinfo/subtitle)[1]"
                mode="subtitle.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template
            match="section                      |sect1|sect2|sect3|sect4|sect5                      |refsect1|refsect2|refsect3                      |topic                      |simplesect"
            mode="subtitle.markup">
        <xsl:param name="allow-anchors" select="'0'"/>
        <xsl:param name="verbose" select="1"/>
        <xsl:apply-templates
                select="(info/subtitle                                 |sectioninfo/subtitle                                 |sect1info/subtitle                                 |sect2info/subtitle                                 |sect3info/subtitle                                 |sect4info/subtitle                                 |sect5info/subtitle                                 |refsect1info/subtitle                                 |refsect2info/subtitle                                 |refsect3info/subtitle                                 |subtitle)[1]"
                mode="subtitle.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="*" mode="object.title.template">
        <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="'title'"/>
            <xsl:with-param name="name">
                <xsl:call-template name="xpath.location"/>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="chapter" mode="object.title.template">
        <xsl:choose>
            <xsl:when test="string($chapter.autolabel) != 0">
                <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'title-numbered'"/>
                    <xsl:with-param name="name">
                        <xsl:call-template name="xpath.location"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'title-unnumbered'"/>
                    <xsl:with-param name="name">
                        <xsl:call-template name="xpath.location"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="appendix" mode="object.title.template">
        <xsl:choose>
            <xsl:when test="string($appendix.autolabel) != 0">
                <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'title-numbered'"/>
                    <xsl:with-param name="name">
                        <xsl:call-template name="xpath.location"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'title-unnumbered'"/>
                    <xsl:with-param name="name">
                        <xsl:call-template name="xpath.location"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="part" mode="object.title.template">
        <xsl:choose>
            <xsl:when test="string($part.autolabel) != 0">
                <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'title-numbered'"/>
                    <xsl:with-param name="name">
                        <xsl:call-template name="xpath.location"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'title-unnumbered'"/>
                    <xsl:with-param name="name">
                        <xsl:call-template name="xpath.location"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="section|sect1|sect2|sect3|sect4|sect5|simplesect                      |bridgehead|topic"
                  mode="object.title.template">
        <xsl:variable name="is.numbered">
            <xsl:call-template name="label.this.section"/>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$is.numbered != 0">
                <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'title-numbered'"/>
                    <xsl:with-param name="name">
                        <xsl:call-template name="xpath.location"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'title-unnumbered'"/>
                    <xsl:with-param name="name">
                        <xsl:call-template name="xpath.location"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="procedure" mode="object.title.template">
        <xsl:choose>
            <xsl:when test="$formal.procedures != 0 and title">
                <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'title'"/>
                    <xsl:with-param name="name">
                        <xsl:call-template name="xpath.location"/>
                        <xsl:text>.formal</xsl:text>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'title'"/>
                    <xsl:with-param name="name">
                        <xsl:call-template name="xpath.location"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*" mode="object.subtitle.template">
        <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="'subtitle'"/>
            <xsl:with-param name="name">
                <xsl:call-template name="xpath.location"/>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="*" mode="is.autonumber">
        <xsl:value-of select="'0'"/>
    </xsl:template>
    <xsl:template match="section|sect1|sect2|sect3|sect4|sect5" mode="is.autonumber">
        <xsl:call-template name="label.this.section"/>
    </xsl:template>
    <xsl:template match="figure|example|table|equation" mode="is.autonumber">
        <xsl:value-of select="'1'"/>
    </xsl:template>
    <xsl:template match="appendix" mode="is.autonumber">
        <xsl:value-of select="$appendix.autolabel"/>
    </xsl:template>
    <xsl:template match="chapter" mode="is.autonumber">
        <xsl:value-of select="$chapter.autolabel"/>
    </xsl:template>
    <xsl:template match="part" mode="is.autonumber">
        <xsl:value-of select="$part.autolabel"/>
    </xsl:template>
    <xsl:template match="preface" mode="is.autonumber">
        <xsl:value-of select="$preface.autolabel"/>
    </xsl:template>
    <xsl:template match="question|answer" mode="is.autonumber">
        <xsl:choose>
            <xsl:when test="$qanda.defaultlabel = 'number'                     and not(label)">
                <xsl:value-of select="'1'"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="'0'"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="qandadiv" mode="is.autonumber">
        <xsl:value-of select="$qandadiv.autolabel"/>
    </xsl:template>
    <xsl:template match="bridgehead" mode="is.autonumber">
        <!-- bridgeheads are not numbered -->
        <xsl:text>0</xsl:text>
    </xsl:template>
    <xsl:template match="procedure" mode="is.autonumber">
        <xsl:value-of select="$formal.procedures"/>
    </xsl:template>
    <xsl:template match="*" mode="object.xref.template">
        <xsl:param name="purpose"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="referrer"/>

        <!-- Is autonumbering on? -->
        <xsl:variable name="autonumber">
            <xsl:apply-templates select="." mode="is.autonumber"/>
        </xsl:variable>

        <xsl:variable name="number-and-title-template">
            <xsl:call-template name="gentext.template.exists">
                <xsl:with-param name="context" select="'xref-number-and-title'"/>
                <xsl:with-param name="name">
                    <xsl:call-template name="xpath.location"/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="number-template">
            <xsl:call-template name="gentext.template.exists">
                <xsl:with-param name="context" select="'xref-number'"/>
                <xsl:with-param name="name">
                    <xsl:call-template name="xpath.location"/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="context">
            <xsl:choose>
                <xsl:when test="self::equation and not(title) and not(info/title)">
                    <xsl:value-of select="'xref-number'"/>
                </xsl:when>
                <xsl:when
                        test="string($autonumber) != 0                        and $number-and-title-template != 0                       and $xref.with.number.and.title != 0">
                    <xsl:value-of select="'xref-number-and-title'"/>
                </xsl:when>
                <xsl:when test="string($autonumber) != 0                        and $number-template != 0">
                    <xsl:value-of select="'xref-number'"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="'xref'"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:call-template name="gentext.template">
            <xsl:with-param name="context" select="$context"/>
            <xsl:with-param name="name">
                <xsl:call-template name="xpath.location"/>
            </xsl:with-param>
            <xsl:with-param name="purpose" select="$purpose"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
        </xsl:call-template>

    </xsl:template>
    <xsl:template match="*" mode="object.title.markup">
        <xsl:param name="allow-anchors" select="0"/>
        <xsl:variable name="template">
            <xsl:apply-templates select="." mode="object.title.template"/>
        </xsl:variable>

        <!--
  <xsl:message>
    <xsl:text>object.title.markup: </xsl:text>
    <xsl:value-of select="local-name(.)"/>
    <xsl:text>: </xsl:text>
    <xsl:value-of select="$template"/>
  </xsl:message>
-->

        <xsl:call-template name="substitute-markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
            <xsl:with-param name="template" select="$template"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="*" mode="object.title.markup.textonly">
        <xsl:variable name="title">
            <xsl:apply-templates select="." mode="object.title.markup"/>
        </xsl:variable>
        <xsl:value-of select="normalize-space($title)"/>
    </xsl:template>
    <xsl:template match="*" mode="object.titleabbrev.markup">
        <xsl:param name="allow-anchors" select="0"/>

        <!-- Just for consistency in template naming -->

        <xsl:apply-templates select="." mode="titleabbrev.markup">
            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="*" mode="object.subtitle.markup">
        <xsl:variable name="template">
            <xsl:apply-templates select="." mode="object.subtitle.template"/>
        </xsl:variable>

        <xsl:call-template name="substitute-markup">
            <xsl:with-param name="template" select="$template"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="*" mode="object.xref.markup">
        <xsl:param name="purpose"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="referrer"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:variable name="template">
            <xsl:choose>
                <xsl:when test="starts-with(normalize-space($xrefstyle), 'select:')">
                    <xsl:call-template name="make.gentext.template">
                        <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                        <xsl:with-param name="purpose" select="$purpose"/>
                        <xsl:with-param name="referrer" select="$referrer"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="starts-with(normalize-space($xrefstyle), 'template:')">
                    <xsl:value-of select="substring-after(normalize-space($xrefstyle), 'template:')"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates select="." mode="object.xref.template">
                        <xsl:with-param name="purpose" select="$purpose"/>
                        <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                        <xsl:with-param name="referrer" select="$referrer"/>
                    </xsl:apply-templates>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <!-- 
  <xsl:message>
    <xsl:text>object.xref.markup: </xsl:text>
    <xsl:value-of select="local-name(.)"/>
    <xsl:text>(</xsl:text>
    <xsl:value-of select="$xrefstyle"/>
    <xsl:text>, </xsl:text>
    <xsl:value-of select="$purpose"/>
    <xsl:text>)</xsl:text>
    <xsl:text>: [</xsl:text>
    <xsl:value-of select="$template"/>
    <xsl:text>]</xsl:text>
  </xsl:message>
-->

        <xsl:if test="$template = '' and $verbose != 0">
            <xsl:message>
                <xsl:text>object.xref.markup: empty xref template</xsl:text>
                <xsl:text> for linkend="</xsl:text>
                <xsl:value-of select="@id|@xml:id"/>
                <xsl:text>" and @xrefstyle="</xsl:text>
                <xsl:value-of select="$xrefstyle"/>
                <xsl:text>"</xsl:text>
            </xsl:message>
        </xsl:if>

        <xsl:call-template name="substitute-markup">
            <xsl:with-param name="purpose" select="$purpose"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="template" select="$template"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="listitem" mode="object.xref.markup">
        <xsl:param name="verbose" select="1"/>

        <xsl:choose>
            <xsl:when test="parent::orderedlist">
                <xsl:variable name="template">
                    <xsl:apply-templates select="." mode="object.xref.template"/>
                </xsl:variable>
                <xsl:call-template name="substitute-markup">
                    <xsl:with-param name="template" select="$template"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="$verbose != 0">
                <xsl:message>
                    <xsl:text>Xref is only supported to listitems in an</xsl:text>
                    <xsl:text> orderedlist: </xsl:text>
                    <xsl:value-of select=".//@id|.//@xml:id"/>
                </xsl:message>
                <xsl:text>???</xsl:text>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="question" mode="object.xref.markup">
        <xsl:param name="purpose"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="referrer"/>

        <xsl:variable name="deflabel">
            <xsl:choose>
                <xsl:when test="ancestor-or-self::*[@defaultlabel]">
                    <xsl:value-of
                            select="(ancestor-or-self::*[@defaultlabel])[last()]                               /@defaultlabel"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$qanda.defaultlabel"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="template">
            <xsl:choose>
                <!-- This avoids double Q: Q: in xref when defaultlabel=qanda -->
                <xsl:when test="$deflabel = 'qanda' and not(label)">%n</xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates select="." mode="object.xref.template">
                        <xsl:with-param name="purpose" select="$purpose"/>
                        <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                        <xsl:with-param name="referrer" select="$referrer"/>
                    </xsl:apply-templates>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:call-template name="substitute-markup">
            <xsl:with-param name="purpose" select="$purpose"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="template" select="$template"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="substitute-markup">
        <xsl:param name="template" select="''"/>
        <xsl:param name="allow-anchors" select="'0'"/>
        <xsl:param name="title" select="''"/>
        <xsl:param name="subtitle" select="''"/>
        <xsl:param name="docname" select="''"/>
        <xsl:param name="label" select="''"/>
        <xsl:param name="pagenumber" select="''"/>
        <xsl:param name="purpose"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="referrer"/>
        <xsl:param name="verbose"/>

        <xsl:choose>
            <xsl:when test="contains($template, '%')">
                <xsl:value-of select="substring-before($template, '%')"/>
                <xsl:variable name="candidate" select="substring(substring-after($template, '%'), 1, 1)"/>
                <xsl:choose>
                    <xsl:when test="$candidate = 't'">
                        <xsl:apply-templates select="." mode="insert.title.markup">
                            <xsl:with-param name="purpose" select="$purpose"/>
                            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                            <xsl:with-param name="title">
                                <xsl:choose>
                                    <xsl:when test="$title != ''">
                                        <xsl:copy-of select="$title"/>
                                    </xsl:when>
                                    <xsl:when test="$purpose = 'xref'">
                                        <xsl:apply-templates select="." mode="titleabbrev.markup">
                                            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                                            <xsl:with-param name="verbose" select="$verbose"/>
                                        </xsl:apply-templates>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:apply-templates select="." mode="title.markup">
                                            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                                            <xsl:with-param name="verbose" select="$verbose"/>
                                        </xsl:apply-templates>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:with-param>
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:when test="$candidate = 's'">
                        <xsl:apply-templates select="." mode="insert.subtitle.markup">
                            <xsl:with-param name="purpose" select="$purpose"/>
                            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                            <xsl:with-param name="subtitle">
                                <xsl:choose>
                                    <xsl:when test="$subtitle != ''">
                                        <xsl:copy-of select="$subtitle"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:apply-templates select="." mode="subtitle.markup">
                                            <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                                        </xsl:apply-templates>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:with-param>
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:when test="$candidate = 'n'">
                        <xsl:apply-templates select="." mode="insert.label.markup">
                            <xsl:with-param name="purpose" select="$purpose"/>
                            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                            <xsl:with-param name="label">
                                <xsl:choose>
                                    <xsl:when test="$label != ''">
                                        <xsl:copy-of select="$label"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:apply-templates select="." mode="label.markup"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:with-param>
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:when test="$candidate = 'p'">
                        <xsl:apply-templates select="." mode="insert.pagenumber.markup">
                            <xsl:with-param name="purpose" select="$purpose"/>
                            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                            <xsl:with-param name="pagenumber">
                                <xsl:choose>
                                    <xsl:when test="$pagenumber != ''">
                                        <xsl:copy-of select="$pagenumber"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:apply-templates select="." mode="pagenumber.markup"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:with-param>
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:when test="$candidate = 'o'">
                        <!-- olink target document title -->
                        <xsl:apply-templates select="." mode="insert.olink.docname.markup">
                            <xsl:with-param name="purpose" select="$purpose"/>
                            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                            <xsl:with-param name="docname">
                                <xsl:choose>
                                    <xsl:when test="$docname != ''">
                                        <xsl:copy-of select="$docname"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:apply-templates select="." mode="olink.docname.markup"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:with-param>
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:when test="$candidate = 'd'">
                        <xsl:apply-templates select="." mode="insert.direction.markup">
                            <xsl:with-param name="purpose" select="$purpose"/>
                            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                            <xsl:with-param name="direction">
                                <xsl:choose>
                                    <xsl:when test="$referrer">
                                        <xsl:variable name="referent-is-below">
                                            <xsl:for-each select="preceding::xref">
                                                <xsl:if test="generate-id(.) = generate-id($referrer)">1</xsl:if>
                                            </xsl:for-each>
                                        </xsl:variable>
                                        <xsl:choose>
                                            <xsl:when test="$referent-is-below = ''">
                                                <xsl:call-template name="gentext">
                                                    <xsl:with-param name="key" select="'above'"/>
                                                </xsl:call-template>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:call-template name="gentext">
                                                    <xsl:with-param name="key" select="'below'"/>
                                                </xsl:call-template>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:message>Attempt to use %d in gentext with no referrer!</xsl:message>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:with-param>
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:when test="$candidate = '%' ">
                        <xsl:text>%</xsl:text>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text>%</xsl:text><xsl:value-of select="$candidate"/>
                    </xsl:otherwise>
                </xsl:choose>
                <!-- recurse with the rest of the template string -->
                <xsl:variable name="rest"
                              select="substring($template,             string-length(substring-before($template, '%'))+3)"/>
                <xsl:call-template name="substitute-markup">
                    <xsl:with-param name="template" select="$rest"/>
                    <xsl:with-param name="allow-anchors" select="$allow-anchors"/>
                    <xsl:with-param name="title" select="$title"/>
                    <xsl:with-param name="subtitle" select="$subtitle"/>
                    <xsl:with-param name="docname" select="$docname"/>
                    <xsl:with-param name="label" select="$label"/>
                    <xsl:with-param name="pagenumber" select="$pagenumber"/>
                    <xsl:with-param name="purpose" select="$purpose"/>
                    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                    <xsl:with-param name="referrer" select="$referrer"/>
                    <xsl:with-param name="verbose" select="$verbose"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$template"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="make.gentext.template">
        <xsl:param name="xrefstyle" select="''"/>
        <xsl:param name="purpose"/>
        <xsl:param name="referrer"/>
        <xsl:param name="lang">
            <xsl:call-template name="l10n.language"/>
        </xsl:param>
        <xsl:param name="target.elem" select="local-name(.)"/>

        <!-- parse xrefstyle to get parts -->
        <xsl:variable name="parts" select="substring-after(normalize-space($xrefstyle), 'select:')"/>

        <xsl:variable name="labeltype">
            <xsl:choose>
                <xsl:when test="contains($parts, 'labelnumber')">
                    <xsl:text>labelnumber</xsl:text>
                </xsl:when>
                <xsl:when test="contains($parts, 'labelname')">
                    <xsl:text>labelname</xsl:text>
                </xsl:when>
                <xsl:when test="contains($parts, 'label')">
                    <xsl:text>label</xsl:text>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="titletype">
            <xsl:choose>
                <xsl:when test="contains($parts, 'quotedtitle')">
                    <xsl:text>quotedtitle</xsl:text>
                </xsl:when>
                <xsl:when test="contains($parts, 'title')">
                    <xsl:text>title</xsl:text>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="pagetype">
            <xsl:choose>
                <xsl:when
                        test="$insert.olink.page.number = 'no' and                       local-name($referrer) = 'olink'">
                    <!-- suppress page numbers -->
                </xsl:when>
                <xsl:when
                        test="$insert.xref.page.number = 'no' and                       local-name($referrer) != 'olink'">
                    <!-- suppress page numbers -->
                </xsl:when>
                <xsl:when test="contains($parts, 'nopage')">
                    <xsl:text>nopage</xsl:text>
                </xsl:when>
                <xsl:when test="contains($parts, 'pagenumber')">
                    <xsl:text>pagenumber</xsl:text>
                </xsl:when>
                <xsl:when test="contains($parts, 'pageabbrev')">
                    <xsl:text>pageabbrev</xsl:text>
                </xsl:when>
                <xsl:when test="contains($parts, 'Page')">
                    <xsl:text>Page</xsl:text>
                </xsl:when>
                <xsl:when test="contains($parts, 'page')">
                    <xsl:text>page</xsl:text>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="docnametype">
            <xsl:choose>
                <xsl:when
                        test="($olink.doctitle = 0 or                        $olink.doctitle = 'no') and                       local-name($referrer) = 'olink'">
                    <!-- suppress docname -->
                </xsl:when>
                <xsl:when test="contains($parts, 'nodocname')">
                    <xsl:text>nodocname</xsl:text>
                </xsl:when>
                <xsl:when test="contains($parts, 'docnamelong')">
                    <xsl:text>docnamelong</xsl:text>
                </xsl:when>
                <xsl:when test="contains($parts, 'docname')">
                    <xsl:text>docname</xsl:text>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:if test="$labeltype != ''">
            <xsl:choose>
                <xsl:when test="$labeltype = 'labelname'">
                    <xsl:call-template name="gentext">
                        <xsl:with-param name="key">
                            <xsl:choose>
                                <xsl:when test="local-name($referrer) = 'olink'">
                                    <xsl:value-of select="$target.elem"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:value-of select="local-name(.)"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:with-param>
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="$labeltype = 'labelnumber'">
                    <xsl:text>%n</xsl:text>
                </xsl:when>
                <xsl:when test="$labeltype = 'label'">
                    <xsl:call-template name="gentext.template">
                        <xsl:with-param name="context" select="'xref-number'"/>
                        <xsl:with-param name="name">
                            <xsl:choose>
                                <xsl:when test="local-name($referrer) = 'olink'">
                                    <xsl:value-of select="$target.elem"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:call-template name="xpath.location"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:with-param>
                        <xsl:with-param name="purpose" select="$purpose"/>
                        <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                        <xsl:with-param name="referrer" select="$referrer"/>
                    </xsl:call-template>
                </xsl:when>
            </xsl:choose>

            <xsl:choose>
                <xsl:when test="$titletype != ''">
                    <xsl:value-of select="$xref.label-title.separator"/>
                </xsl:when>
                <xsl:when test="$pagetype != '' and $pagetype != 'nopage'">
                    <xsl:value-of select="$xref.label-page.separator"/>
                </xsl:when>
            </xsl:choose>
        </xsl:if>

        <xsl:if test="$titletype != ''">
            <xsl:choose>
                <xsl:when test="$titletype = 'title'">
                    <xsl:text>%t</xsl:text>
                </xsl:when>
                <xsl:when test="$titletype = 'quotedtitle'">
                    <xsl:call-template name="gentext.dingbat">
                        <xsl:with-param name="dingbat" select="'startquote'"/>
                    </xsl:call-template>
                    <xsl:text>%t</xsl:text>
                    <xsl:call-template name="gentext.dingbat">
                        <xsl:with-param name="dingbat" select="'endquote'"/>
                    </xsl:call-template>
                </xsl:when>
            </xsl:choose>

            <xsl:choose>
                <xsl:when test="$pagetype != '' and $pagetype != 'nopage'">
                    <xsl:value-of select="$xref.title-page.separator"/>
                </xsl:when>
            </xsl:choose>
        </xsl:if>

        <!-- special case: use regular xref template if just turning off page -->
        <xsl:if test="($pagetype = 'nopage' or $docnametype = 'nodocname')                   and local-name($referrer) != 'olink'                   and $labeltype = ''                    and $titletype = ''">
            <xsl:apply-templates select="." mode="object.xref.template">
                <xsl:with-param name="purpose" select="$purpose"/>
                <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                <xsl:with-param name="referrer" select="$referrer"/>
            </xsl:apply-templates>
        </xsl:if>

        <xsl:if test="$pagetype != ''">
            <xsl:choose>
                <xsl:when test="$pagetype = 'page'">
                    <xsl:call-template name="gentext.template">
                        <xsl:with-param name="context" select="'xref'"/>
                        <xsl:with-param name="name" select="'page'"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="$pagetype = 'Page'">
                    <xsl:call-template name="gentext.template">
                        <xsl:with-param name="context" select="'xref'"/>
                        <xsl:with-param name="name" select="'Page'"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="$pagetype = 'pageabbrev'">
                    <xsl:call-template name="gentext.template">
                        <xsl:with-param name="context" select="'xref'"/>
                        <xsl:with-param name="name" select="'pageabbrev'"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="$pagetype = 'pagenumber'">
                    <xsl:text>%p</xsl:text>
                </xsl:when>
            </xsl:choose>

        </xsl:if>

        <!-- Add reference to other document title -->
        <xsl:if test="$docnametype != '' and local-name($referrer) = 'olink'">
            <!-- Any separator should be in the gentext template -->
            <xsl:choose>
                <xsl:when test="$docnametype = 'docnamelong'">
                    <xsl:call-template name="gentext.template">
                        <xsl:with-param name="context" select="'xref'"/>
                        <xsl:with-param name="name" select="'docnamelong'"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="$docnametype = 'docname'">
                    <xsl:call-template name="gentext.template">
                        <xsl:with-param name="context" select="'xref'"/>
                        <xsl:with-param name="name" select="'docname'"/>
                    </xsl:call-template>
                </xsl:when>
            </xsl:choose>

        </xsl:if>

    </xsl:template>
    <doc:mode xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" mode="collect.targets">
        <refpurpose>Collects information for potential cross reference targets</refpurpose>
        <refdescription id="collect.targets-desc">
            <para>Processing the root element in the
                <literal role="mode">collect.targets</literal>
                mode produces
                a set of target database elements that can be used by
                the olink mechanism to resolve external cross references.
                The collection process is controlled by the
                <literal>
                    collect.xref.targets
                </literal>
                parameter, which can be
                <literal>yes</literal>
                to collect targets and process
                the document for output,
                <literal>only</literal>
                to
                only collect the targets, and
                <literal>no</literal>
                (default) to not collect the targets and only process the document.
            </para>
            <para>
                A
                <literal>targets.filename</literal>
                parameter must be
                specified to receive the output if
                <literal>collect.xref.targets</literal>
                is
                set to
                <literal>yes</literal>
                so as to
                redirect the target data to a file separate from the
                document output.
            </para>
        </refdescription>
    </doc:mode>
    <xsl:template match="*" mode="collect.targets">
        <xsl:choose>
            <xsl:when test="$collect.xref.targets = 'yes' and $targets.filename = ''">
                <xsl:message>
                    Must specify a $targets.filename parameter when
                    $collect.xref.targets is set to 'yes'.
                    The xref targets were not collected.
                </xsl:message>
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="$targets.filename">
                        <xsl:call-template name="write.chunk">
                            <xsl:with-param name="filename" select="$targets.filename"/>
                            <xsl:with-param name="method" select="'xml'"/>
                            <xsl:with-param name="encoding" select="'utf-8'"/>
                            <xsl:with-param name="omit-xml-declaration" select="'yes'"/>
                            <xsl:with-param name="doctype-public" select="''"/>
                            <xsl:with-param name="doctype-system" select="''"/>
                            <xsl:with-param name="indent" select="'no'"/>
                            <xsl:with-param name="quiet" select="0"/>
                            <xsl:with-param name="content">
                                <xsl:apply-templates select="." mode="olink.mode"/>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <!-- Else write to standard output -->
                        <xsl:apply-templates select="." mode="olink.mode"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="olink.href.target">
        <xsl:param name="nd" select="."/>

        <xsl:value-of select="$olink.base.uri"/>
        <xsl:call-template name="href.target">
            <xsl:with-param name="object" select="$nd"/>
            <xsl:with-param name="context" select="NOTANODE"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="attrs">
        <xsl:param name="nd" select="."/>

        <xsl:attribute name="element">
            <xsl:value-of select="local-name(.)"/>
        </xsl:attribute>

        <xsl:attribute name="href">
            <xsl:call-template name="olink.href.target">
                <xsl:with-param name="nd" select="$nd"/>
            </xsl:call-template>
        </xsl:attribute>

        <xsl:variable name="num">
            <xsl:apply-templates select="$nd" mode="label.markup">
                <xsl:with-param name="verbose" select="0"/>
            </xsl:apply-templates>
        </xsl:variable>

        <xsl:if test="$num">
            <xsl:attribute name="number">
                <xsl:value-of select="$num"/>
            </xsl:attribute>
        </xsl:if>

        <xsl:choose>
            <xsl:when test="$nd/@id">
                <xsl:attribute name="targetptr">
                    <xsl:value-of select="$nd/@id"/>
                </xsl:attribute>
            </xsl:when>
            <xsl:when test="$nd/@xml:id">
                <xsl:attribute name="targetptr">
                    <xsl:value-of select="$nd/@xml:id"/>
                </xsl:attribute>
            </xsl:when>
        </xsl:choose>

        <xsl:if test="$nd/@lang">
            <xsl:attribute name="lang">
                <xsl:value-of select="$nd/@lang"/>
            </xsl:attribute>
        </xsl:if>

    </xsl:template>
    <xsl:template name="div">
        <xsl:param name="nd" select="."/>

        <div xmlns="">
            <xsl:call-template name="attrs">
                <xsl:with-param name="nd" select="$nd"/>
            </xsl:call-template>
            <ttl>
                <xsl:apply-templates select="$nd" mode="title.markup">
                    <xsl:with-param name="verbose" select="0"/>
                </xsl:apply-templates>
            </ttl>
            <xreftext>
                <xsl:choose>
                    <xsl:when test="$nd/@xreflabel">
                        <xsl:call-template name="xref.xreflabel">
                            <xsl:with-param name="target" select="$nd"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="$nd" mode="xref-to">
                            <xsl:with-param name="verbose" select="0"/>
                        </xsl:apply-templates>
                    </xsl:otherwise>
                </xsl:choose>
            </xreftext>
            <xsl:apply-templates mode="olink.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="obj">
        <xsl:param name="nd" select="."/>

        <obj xmlns="">
            <xsl:call-template name="attrs">
                <xsl:with-param name="nd" select="$nd"/>
            </xsl:call-template>
            <ttl>
                <xsl:apply-templates select="$nd" mode="title.markup">
                    <xsl:with-param name="verbose" select="0"/>
                </xsl:apply-templates>
            </ttl>
            <xreftext>
                <xsl:choose>
                    <xsl:when test="$nd/@xreflabel">
                        <xsl:call-template name="xref.xreflabel">
                            <xsl:with-param name="target" select="$nd"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="$nd" mode="xref-to">
                            <xsl:with-param name="verbose" select="0"/>
                        </xsl:apply-templates>
                    </xsl:otherwise>
                </xsl:choose>
            </xreftext>
        </obj>
    </xsl:template>
    <xsl:template match="text()|processing-instruction()|comment()" mode="olink.mode">
        <!-- nop -->
    </xsl:template>
    <xsl:template match="set" mode="olink.mode">
        <xsl:call-template name="div"/>
    </xsl:template>
    <xsl:template match="book" mode="olink.mode">
        <xsl:call-template name="div"/>
    </xsl:template>
    <xsl:template match="preface|chapter|appendix" mode="olink.mode">
        <xsl:call-template name="div"/>
    </xsl:template>
    <xsl:template match="part|reference" mode="olink.mode">
        <xsl:call-template name="div"/>
    </xsl:template>
    <xsl:template match="article" mode="olink.mode">
        <xsl:call-template name="div"/>
    </xsl:template>
    <xsl:template match="topic" mode="olink.mode">
        <xsl:call-template name="div"/>
    </xsl:template>
    <xsl:template match="bibliography|bibliodiv" mode="olink.mode">
        <xsl:call-template name="div"/>
    </xsl:template>
    <xsl:template match="biblioentry|bibliomixed" mode="olink.mode">
        <xsl:call-template name="obj"/>
    </xsl:template>
    <xsl:template match="refentry" mode="olink.mode">
        <xsl:call-template name="div"/>
    </xsl:template>
    <xsl:template match="section|sect1|sect2|sect3|sect4|sect5" mode="olink.mode">
        <xsl:call-template name="div"/>
    </xsl:template>
    <xsl:template match="refsection|refsect1|refsect2|refsect3" mode="olink.mode">
        <xsl:call-template name="div"/>
    </xsl:template>
    <xsl:template match="figure|example|table" mode="olink.mode">
        <xsl:call-template name="obj"/>
        <xsl:apply-templates mode="olink.mode"/>
    </xsl:template>
    <xsl:template match="equation[title or info/title]" mode="olink.mode">
        <xsl:call-template name="obj"/>
    </xsl:template>
    <xsl:template match="qandaset|qandaentry" mode="olink.mode">
        <xsl:call-template name="div"/>
    </xsl:template>
    <xsl:template match="glossary[@role='auto']" mode="olink.mode" priority="2">
        <xsl:variable name="collection" select="document($glossary.collection, .)"/>
        <xsl:if test="$glossary.collection = ''">
            <xsl:message>
                <xsl:text>Warning: processing automatic glossary </xsl:text>
                <xsl:text>without a glossary.collection file.</xsl:text>
            </xsl:message>
        </xsl:if>

        <xsl:if test="not($collection) and $glossary.collection != ''">
            <xsl:message>
                <xsl:text>Warning: processing automatic glossary but unable to </xsl:text>
                <xsl:text>open glossary.collection file '</xsl:text>
                <xsl:value-of select="$glossary.collection"/>
                <xsl:text>'</xsl:text>
            </xsl:message>
        </xsl:if>


        <xsl:if test="$exsl.node.set.available != 0">
            <xsl:variable name="auto.glossary">
                <xsl:apply-templates select="." mode="assemble.auto.glossary"/>
            </xsl:variable>
            <xsl:variable name="auto.glossary.nodeset" select="exsl:node-set($auto.glossary)"/>
            <xsl:apply-templates select="$auto.glossary.nodeset/*" mode="olink.mode"/>
        </xsl:if>

    </xsl:template>
    <xsl:template match="glossary" mode="assemble.auto.glossary">
        <xsl:copy>
            <xsl:copy-of select="@*[not(local-name() = 'role')]"/>
            <xsl:apply-templates select="node()" mode="assemble.auto.glossary"/>
            <xsl:call-template name="select.glossentries"/>
        </xsl:copy>
    </xsl:template>
    <xsl:template name="select.glossentries">
        <xsl:param name="collection" select="document($glossary.collection, .)"/>
        <xsl:param name="terms" select="//glossterm[not(parent::glossdef)]|//firstterm"/>

        <xsl:for-each select="$collection//glossentry">
            <xsl:variable name="cterm" select="glossterm"/>
            <xsl:if test="$terms[@baseform = $cterm or . = $cterm]">
                <xsl:copy-of select="."/>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
    <xsl:template match="glossentry" mode="assemble.auto.glossary">
        <!-- skip the dummy entries -->
    </xsl:template>
    <xsl:template match="*" mode="assemble.auto.glossary">
        <!-- pass through any titles and intro stuff -->
        <xsl:copy-of select="."/>
    </xsl:template>
    <xsl:template match="*" mode="olink.mode">
        <xsl:if test="@id or @xml:id">
            <xsl:call-template name="obj"/>
        </xsl:if>
        <xsl:apply-templates mode="olink.mode"/>
    </xsl:template>
    <xsl:key name="targetdoc-key" match="document" use="@targetdoc"/>
    <xsl:key name="targetptr-key" match="div|obj"
             use="concat(ancestor::document/@targetdoc, '/',                      @targetptr, '/', ancestor::document/@lang)"/>
    <xsl:template name="select.target.database">
        <xsl:param name="targetdoc.att" select="''"/>
        <xsl:param name="targetptr.att" select="''"/>
        <xsl:param name="olink.lang" select="''"/>

        <!-- use root's xml:base if exists -->
        <xsl:variable name="xml.base" select="/*/@xml:base"/>

        <!-- This selection can be customized if needed -->
        <xsl:variable name="target.database.filename">
            <xsl:choose>
                <xsl:when
                        test="$xml.base != '' and                    not(starts-with($target.database.document, 'file:/')) and                    not(starts-with($target.database.document, '/'))">
                    <xsl:call-template name="systemIdToBaseURI">
                        <xsl:with-param name="systemId" select="$xml.base"/>
                    </xsl:call-template>
                    <xsl:value-of select="$target.database.document"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$target.database.document"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="target.database" select="document($target.database.filename,/)"/>

        <xsl:choose>
            <!-- Was the database document parameter not set? -->
            <xsl:when test="$target.database.document = ''">
                <xsl:message>
                    <xsl:text>Olinks not processed: must specify a </xsl:text>
        <xsl:text>$target.database.document parameter
</xsl:text>
                    <xsl:text>when using olinks with targetdoc </xsl:text>
                    <xsl:text>and targetptr attributes.</xsl:text>
                </xsl:message>
            </xsl:when>
            <xsl:when test="namespace-uri($target.database/*) != ''">
                <xsl:message>
                    <xsl:text>Olink error: the targetset element and children in '</xsl:text>
                    <xsl:value-of select="$target.database.document"/>
                    <xsl:text>' should not be in any namespace.</xsl:text>
                </xsl:message>
            </xsl:when>
            <!-- Did it not open? Should be a targetset element -->
            <xsl:when test="not($target.database/*)">
                <xsl:message>
                    <xsl:text>Olink error: could not open target database '</xsl:text>
                    <xsl:value-of select="$target.database.filename"/>
                    <xsl:text>'.</xsl:text>
                </xsl:message>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$target.database.filename"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="select.olink.key">
        <xsl:param name="targetdoc.att" select="''"/>
        <xsl:param name="targetptr.att" select="''"/>
        <xsl:param name="olink.lang" select="''"/>
        <xsl:param name="target.database"/>

        <xsl:if test="$target.database/*">
            <xsl:variable name="olink.fallback.sequence">
                <xsl:call-template name="select.olink.lang.fallback">
                    <xsl:with-param name="olink.lang" select="$olink.lang"/>
                </xsl:call-template>
            </xsl:variable>

            <!-- Recurse through the languages until you find a match -->
            <xsl:call-template name="select.olink.key.in.lang">
                <xsl:with-param name="targetdoc.att" select="$targetdoc.att"/>
                <xsl:with-param name="targetptr.att" select="$targetptr.att"/>
                <xsl:with-param name="olink.lang" select="$olink.lang"/>
                <xsl:with-param name="target.database" select="$target.database"/>
                <xsl:with-param name="fallback.index" select="1"/>
                <xsl:with-param name="olink.fallback.sequence" select="$olink.fallback.sequence"/>
            </xsl:call-template>
        </xsl:if>

    </xsl:template>
    <xsl:template name="select.olink.key.in.lang">
        <xsl:param name="targetdoc.att" select="''"/>
        <xsl:param name="targetptr.att" select="''"/>
        <xsl:param name="olink.lang" select="''"/>
        <xsl:param name="target.database"/>
        <xsl:param name="fallback.index" select="1"/>
        <xsl:param name="olink.fallback.sequence" select="''"/>

        <xsl:variable name="target.lang">
            <xsl:call-template name="select.target.lang">
                <xsl:with-param name="fallback.index" select="$fallback.index"/>
                <xsl:with-param name="olink.fallback.sequence" select="$olink.fallback.sequence"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:if test="$olink.debug != 0">
            <xsl:message>
                <xsl:text>Olink debug: cases for targetdoc='</xsl:text>
                <xsl:value-of select="$targetdoc.att"/>
                <xsl:text>' and targetptr='</xsl:text>
                <xsl:value-of select="$targetptr.att"/>
                <xsl:text>' in language '</xsl:text>
                <xsl:value-of select="$target.lang"/>
                <xsl:text>'.</xsl:text>
            </xsl:message>
        </xsl:if>

        <!-- Customize these cases if you want different selection logic -->
        <xsl:variable name="CaseA">
            <!-- targetdoc.att = not blank
         targetptr.att = not blank
    -->
            <xsl:if test="$targetdoc.att != '' and                   $targetptr.att != ''">
                <xsl:for-each select="$target.database">
                    <xsl:variable name="key"
                                  select="concat($targetdoc.att, '/',                                       $targetptr.att, '/',                                      $target.lang)"/>
                    <xsl:choose>
                        <xsl:when test="key('targetptr-key', $key)[1]/@href != ''">
                            <xsl:value-of select="$key"/>
                            <xsl:if test="$olink.debug != 0">
                                <xsl:message>Olink debug: CaseA matched.</xsl:message>
                            </xsl:if>
                        </xsl:when>
                        <xsl:when test="$olink.debug != 0">
                            <xsl:message>Olink debug: CaseA NOT matched</xsl:message>
                        </xsl:when>
                    </xsl:choose>
                </xsl:for-each>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="CaseB">
            <!-- targetdoc.att = not blank
         targetptr.att = not blank
         prefer.internal.olink = not zero
         current.docid = not blank 
    -->
            <xsl:if test="$targetdoc.att != '' and                   $targetptr.att != '' and                   $current.docid != '' and                   $prefer.internal.olink != 0">
                <xsl:for-each select="$target.database">
                    <xsl:variable name="key"
                                  select="concat($current.docid, '/',                                       $targetptr.att, '/',                                      $target.lang)"/>
                    <xsl:choose>
                        <xsl:when test="key('targetptr-key', $key)[1]/@href != ''">
                            <xsl:value-of select="$key"/>
                            <xsl:if test="$olink.debug != 0">
                                <xsl:message>Olink debug: CaseB matched.</xsl:message>
                            </xsl:if>
                        </xsl:when>
                        <xsl:when test="$olink.debug != 0">
                            <xsl:message>Olink debug: CaseB NOT matched</xsl:message>
                        </xsl:when>
                    </xsl:choose>
                </xsl:for-each>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="CaseC">
            <!-- targetdoc.att = blank
         targetptr.att = not blank
         current.docid = not blank 
    -->
            <xsl:if test="string-length($targetdoc.att) = 0 and                   $targetptr.att != '' and                   $current.docid != ''">
                <!-- Must use a for-each to change context for keys to work -->
                <xsl:for-each select="$target.database">
                    <xsl:variable name="key"
                                  select="concat($current.docid, '/',                                       $targetptr.att, '/',                                      $target.lang)"/>
                    <xsl:choose>
                        <xsl:when test="key('targetptr-key', $key)[1]/@href != ''">
                            <xsl:value-of select="$key"/>
                            <xsl:if test="$olink.debug != 0">
                                <xsl:message>Olink debug: CaseC matched.</xsl:message>
                            </xsl:if>
                        </xsl:when>
                        <xsl:when test="$olink.debug != 0">
                            <xsl:message>Olink debug: CaseC NOT matched.</xsl:message>
                        </xsl:when>
                    </xsl:choose>
                </xsl:for-each>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="CaseD">
            <!-- targetdoc.att = blank
         targetptr.att = not blank
         current.docid = blank 
    -->
            <!-- This is possible if only one document in the database -->
            <xsl:if test="string-length($targetdoc.att) = 0 and                   $targetptr.att != '' and                   string-length($current.docid) = 0 and                   count($target.database//document) = 1">
                <xsl:for-each select="$target.database">
                    <xsl:variable name="key"
                                  select="concat(.//document/@targetdoc, '/',                                       $targetptr.att, '/',                                      $target.lang)"/>
                    <xsl:choose>
                        <xsl:when test="key('targetptr-key', $key)[1]/@href != ''">
                            <xsl:value-of select="$key"/>
                            <xsl:if test="$olink.debug != 0">
                                <xsl:message>Olink debug: CaseD matched.</xsl:message>
                            </xsl:if>
                        </xsl:when>
                        <xsl:when test="$olink.debug != 0">
                            <xsl:message>Olink debug: CaseD NOT matched</xsl:message>
                        </xsl:when>
                    </xsl:choose>
                </xsl:for-each>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="CaseE">
            <!-- targetdoc.att = not blank
         targetptr.att = blank
    -->
            <xsl:if test="$targetdoc.att != '' and                   string-length($targetptr.att) = 0">

                <!-- Try the document's root element id -->
                <xsl:variable name="rootid">
                    <xsl:choose>
                        <xsl:when test="$target.lang != ''">
                            <xsl:value-of
                                    select="$target.database//document[@targetdoc = $targetdoc.att and @lang = $target.lang]/*[1]/@targetptr"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of
                                    select="$target.database//document[@targetdoc = $targetdoc.att and not(@lang)]/*[1]/@targetptr"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>

                <xsl:for-each select="$target.database">
                    <xsl:variable name="key"
                                  select="concat($targetdoc.att, '/',                                       $rootid, '/',                                      $target.lang)"/>
                    <xsl:choose>
                        <xsl:when test="key('targetptr-key', $key)[1]/@href != ''">
                            <xsl:value-of select="$key"/>
                            <xsl:if test="$olink.debug != 0">
                                <xsl:message>Olink debug: CaseE matched.</xsl:message>
                            </xsl:if>
                        </xsl:when>
                        <xsl:when test="$olink.debug != 0">
                            <xsl:message>Olink debug: CaseE NOT matched.</xsl:message>
                        </xsl:when>
                    </xsl:choose>
                </xsl:for-each>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="CaseF">
            <!-- targetdoc.att = not blank
         targetptr.att = blank
         prefer.internal.olink = not zero
         current.docid = not blank 
    -->
            <xsl:if test="$targetdoc.att != '' and                   string-length($targetptr.att) = 0 and                   $current.docid != '' and                   $prefer.internal.olink != 0">
                <!-- Try the document's root element id -->
                <xsl:variable name="rootid">
                    <xsl:choose>
                        <xsl:when test="$target.lang != ''">
                            <xsl:value-of
                                    select="$target.database//document[@targetdoc = $current.docid and @lang = $target.lang]/*[1]/@targetptr"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of
                                    select="$target.database//document[@targetdoc = $current.docid and not(@lang)]/*[1]/@targetptr"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>

                <xsl:for-each select="$target.database">
                    <xsl:variable name="key"
                                  select="concat($current.docid, '/',                                       $rootid, '/',                                      $target.lang)"/>
                    <xsl:choose>
                        <xsl:when test="key('targetptr-key', $key)[1]/@href != ''">
                            <xsl:value-of select="$key"/>
                            <xsl:if test="$olink.debug != 0">
                                <xsl:message>Olink debug: CaseF matched.</xsl:message>
                            </xsl:if>
                        </xsl:when>
                        <xsl:when test="$olink.debug != 0">
                            <xsl:message>Olink debug: CaseF NOT matched.</xsl:message>
                        </xsl:when>
                    </xsl:choose>
                </xsl:for-each>
            </xsl:if>
        </xsl:variable>

        <!-- Now select the best match. Customize the order if needed -->
        <xsl:variable name="selected.key">
            <xsl:choose>
                <xsl:when test="$CaseB != ''">
                    <xsl:value-of select="$CaseB"/>
                    <xsl:if test="$olink.debug != 0">
                        <xsl:message>
                            <xsl:text>Olink debug: CaseB key is the final selection: </xsl:text>
                            <xsl:value-of select="$CaseB"/>
                        </xsl:message>
                    </xsl:if>
                </xsl:when>
                <xsl:when test="$CaseA != ''">
                    <xsl:value-of select="$CaseA"/>
                    <xsl:if test="$olink.debug != 0">
                        <xsl:message>
                            <xsl:text>Olink debug: CaseA key is the final selection: </xsl:text>
                            <xsl:value-of select="$CaseA"/>
                        </xsl:message>
                    </xsl:if>
                </xsl:when>
                <xsl:when test="$CaseC != ''">
                    <xsl:value-of select="$CaseC"/>
                    <xsl:if test="$olink.debug != 0">
                        <xsl:message>
                            <xsl:text>Olink debug: CaseC key is the final selection: </xsl:text>
                            <xsl:value-of select="$CaseC"/>
                        </xsl:message>
                    </xsl:if>
                </xsl:when>
                <xsl:when test="$CaseD != ''">
                    <xsl:value-of select="$CaseD"/>
                    <xsl:if test="$olink.debug != 0">
                        <xsl:message>
                            <xsl:text>Olink debug: CaseD key is the final selection: </xsl:text>
                            <xsl:value-of select="$CaseD"/>
                        </xsl:message>
                    </xsl:if>
                </xsl:when>
                <xsl:when test="$CaseF != ''">
                    <xsl:value-of select="$CaseF"/>
                    <xsl:if test="$olink.debug != 0">
                        <xsl:message>
                            <xsl:text>Olink debug: CaseF key is the final selection: </xsl:text>
                            <xsl:value-of select="$CaseF"/>
                        </xsl:message>
                    </xsl:if>
                </xsl:when>
                <xsl:when test="$CaseE != ''">
                    <xsl:value-of select="$CaseE"/>
                    <xsl:if test="$olink.debug != 0">
                        <xsl:message>
                            <xsl:text>Olink debug: CaseE key is the final selection: </xsl:text>
                            <xsl:value-of select="$CaseE"/>
                        </xsl:message>
                    </xsl:if>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:if test="$olink.debug != 0">
                        <xsl:message>
                            <xsl:text>Olink debug: No case matched for lang '</xsl:text>
                            <xsl:value-of select="$target.lang"/>
                            <xsl:text>'.</xsl:text>
                        </xsl:message>
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$selected.key != ''">
                <xsl:value-of select="$selected.key"/>
            </xsl:when>
            <xsl:when test="string-length($selected.key) = 0 and                      string-length($target.lang) = 0">
                <!-- No match on last try, and we are done -->
            </xsl:when>
            <xsl:otherwise>
                <!-- Recurse through next language -->
                <xsl:call-template name="select.olink.key.in.lang">
                    <xsl:with-param name="targetdoc.att" select="$targetdoc.att"/>
                    <xsl:with-param name="targetptr.att" select="$targetptr.att"/>
                    <xsl:with-param name="olink.lang" select="$olink.lang"/>
                    <xsl:with-param name="target.database" select="$target.database"/>
                    <xsl:with-param name="fallback.index" select="$fallback.index + 1"/>
                    <xsl:with-param name="olink.fallback.sequence" select="$olink.fallback.sequence"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>

    </xsl:template>
    <xsl:template name="select.target.lang">
        <xsl:param name="fallback.index" select="1"/>
        <xsl:param name="olink.fallback.sequence" select="''"/>

        <!-- recurse backwards to find the lang matching the index -->
        <xsl:variable name="firstlang" select="substring-before($olink.fallback.sequence, ' ')"/>
        <xsl:variable name="rest" select="substring-after($olink.fallback.sequence, ' ')"/>
        <xsl:choose>
            <xsl:when test="$fallback.index = 1">
                <xsl:value-of select="$firstlang"/>
            </xsl:when>
            <xsl:when test="$fallback.index &gt; 1">
                <xsl:call-template name="select.target.lang">
                    <xsl:with-param name="fallback.index" select="$fallback.index - 1"/>
                    <xsl:with-param name="olink.fallback.sequence" select="$rest"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="select.olink.lang.fallback">
        <xsl:param name="olink.lang" select="''"/>

        <!-- Prefer language of the olink element -->
        <xsl:value-of
                select="concat(normalize-space(concat($olink.lang, ' ',                          $olink.lang.fallback.sequence)), ' ')"/>
    </xsl:template>
    <xsl:template name="make.olink.href">
        <xsl:param name="olink.key" select="''"/>
        <xsl:param name="target.database"/>

        <xsl:if test="$olink.key != ''">
            <xsl:variable name="target.href">
                <xsl:for-each select="$target.database">
                    <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@href"/>
                </xsl:for-each>
            </xsl:variable>

            <xsl:variable name="targetdoc">
                <xsl:value-of select="substring-before($olink.key, '/')"/>
            </xsl:variable>

            <!-- Does the target database use a sitemap? -->
            <xsl:variable name="use.sitemap">
                <xsl:choose>
                    <xsl:when test="$target.database//sitemap">1</xsl:when>
                    <xsl:otherwise>0</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>


            <!-- Get the baseuri for this targetptr -->
            <xsl:variable name="baseuri">
                <xsl:choose>
                    <!-- Does the database use a sitemap? -->
                    <xsl:when test="$use.sitemap != 0">
                        <xsl:choose>
                            <!-- Was current.docid parameter set? -->
                            <xsl:when test="$current.docid != ''">
                                <!-- Was it found in the database? -->
                                <xsl:variable name="currentdoc.key">
                                    <xsl:for-each select="$target.database">
                                        <xsl:value-of
                                                select="key('targetdoc-key',                                         $current.docid)[1]/@targetdoc"/>
                                    </xsl:for-each>
                                </xsl:variable>
                                <xsl:choose>
                                    <xsl:when test="$currentdoc.key != ''">
                                        <xsl:for-each select="$target.database">
                                            <xsl:call-template name="targetpath">
                                                <xsl:with-param name="dirnode"
                                                                select="key('targetdoc-key', $current.docid)[1]/parent::dir"/>
                                                <xsl:with-param name="targetdoc" select="$targetdoc"/>
                                            </xsl:call-template>
                                        </xsl:for-each>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:message>
                                            <xsl:text>Olink error: cannot compute relative </xsl:text>
                                            <xsl:text>sitemap path because $current.docid '</xsl:text>
                                            <xsl:value-of select="$current.docid"/>
                                            <xsl:text>' not found in target database.</xsl:text>
                                        </xsl:message>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message>
                                    <xsl:text>Olink warning: cannot compute relative </xsl:text>
                                    <xsl:text>sitemap path without $current.docid parameter</xsl:text>
                                </xsl:message>
                            </xsl:otherwise>
                        </xsl:choose>
                        <!-- In either case, add baseuri from its document entry-->
                        <xsl:variable name="docbaseuri">
                            <xsl:for-each select="$target.database">
                                <xsl:value-of select="key('targetdoc-key', $targetdoc)[1]/@baseuri"/>
                            </xsl:for-each>
                        </xsl:variable>
                        <xsl:if test="$docbaseuri != ''">
                            <xsl:value-of select="$docbaseuri"/>
                        </xsl:if>
                    </xsl:when>
                    <!-- No database sitemap in use -->
                    <xsl:otherwise>
                        <!-- Just use any baseuri from its document entry -->
                        <xsl:variable name="docbaseuri">
                            <xsl:for-each select="$target.database">
                                <xsl:value-of select="key('targetdoc-key', $targetdoc)[1]/@baseuri"/>
                            </xsl:for-each>
                        </xsl:variable>
                        <xsl:if test="$docbaseuri != ''">
                            <xsl:value-of select="$docbaseuri"/>
                        </xsl:if>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>

            <!-- Is this olink to be active? -->
            <xsl:variable name="active.olink">
                <xsl:choose>
                    <xsl:when test="$activate.external.olinks = 0">
                        <xsl:choose>
                            <xsl:when test="$current.docid = ''">1</xsl:when>
                            <xsl:when test="$targetdoc = ''">1</xsl:when>
                            <xsl:when test="$targetdoc = $current.docid">1</xsl:when>
                            <xsl:otherwise>0</xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>

            <!-- Form the href information -->
            <xsl:if test="$active.olink != 0">
                <xsl:if test="$baseuri != ''">
                    <xsl:value-of select="$baseuri"/>
                    <xsl:if test="substring($target.href,1,1) != '#'">
                        <!--xsl:text>/</xsl:text-->
                    </xsl:if>
                </xsl:if>
                <!-- optionally turn off frag for PDF references -->
                <xsl:if test="not($insert.olink.pdf.frag = 0 and             translate(substring($baseuri, string-length($baseuri) - 3),                       'PDF', 'pdf') = '.pdf'             and starts-with($target.href, '#') )">
                    <xsl:value-of select="$target.href"/>
                </xsl:if>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    <xsl:template name="olink.from.uri">
        <xsl:param name="target.database"/>
        <xsl:param name="object" select="NotAnElement"/>
        <xsl:param name="object.targetdoc" select="$current.docid"/>
        <xsl:param name="object.lang"
                   select="concat($object/ancestor::*[last()]/@lang,                           $object/ancestor::*[last()]/@xml:lang)"/>

        <xsl:variable name="parent.id">
            <xsl:call-template name="object.id">
                <xsl:with-param name="object" select="$object"/>
            </xsl:call-template>
        </xsl:variable>

        <!-- Get the olink key for the parent of olink element -->
        <xsl:variable name="from.key">
            <xsl:call-template name="select.olink.key">
                <xsl:with-param name="targetdoc.att" select="$object.targetdoc"/>
                <xsl:with-param name="targetptr.att" select="$parent.id"/>
                <xsl:with-param name="olink.lang" select="$object.lang"/>
                <xsl:with-param name="target.database" select="$target.database"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="from.olink.href">
            <xsl:for-each select="$target.database">
                <xsl:value-of select="key('targetptr-key', $from.key)[1]/@href"/>
            </xsl:for-each>
        </xsl:variable>

        <xsl:choose>
            <!-- we found the olink object -->
            <xsl:when test="$from.olink.href != ''">
                <xsl:value-of select="$from.olink.href"/>
            </xsl:when>
            <xsl:when test="not($object/parent::*)">
                <xsl:value-of select="$from.olink.href"/>
            </xsl:when>
            <xsl:otherwise>
                <!-- recurse upward in current document -->
                <xsl:call-template name="olink.from.uri">
                    <xsl:with-param name="target.database" select="$target.database"/>
                    <xsl:with-param name="object" select="$object/parent::*"/>
                    <xsl:with-param name="object.targetdoc" select="$object.targetdoc"/>
                    <xsl:with-param name="object.lang" select="$object.lang"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>

    </xsl:template>
    <xsl:template name="olink.hottext">
        <xsl:param name="target.database"/>
        <xsl:param name="olink.lang" select="''"/>
        <xsl:param name="olink.key" select="''"/>
        <xsl:param name="referrer" select="."/>
        <xsl:param name="xrefstyle">
            <xsl:choose>
                <xsl:when test="@role and not(@xrefstyle)                        and $use.role.as.xrefstyle != 0">
                    <xsl:value-of select="@role"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="@xrefstyle"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:param>

        <xsl:choose>
            <!-- If it has elements or text (not just PI or comment) -->
            <xsl:when test="child::text() or child::*">
                <xsl:apply-templates/>
            </xsl:when>
            <xsl:when test="$olink.key != ''">
                <!-- Get the xref text for this record -->
                <xsl:variable name="xref.text">
                    <xsl:for-each select="$target.database">
                        <xsl:call-template name="insert.targetdb.data">
                            <xsl:with-param name="data" select="key('targetptr-key', $olink.key)[1]/xreftext/node()"/>
                        </xsl:call-template>
                    </xsl:for-each>
                </xsl:variable>

                <xsl:variable name="xref.number">
                    <xsl:for-each select="$target.database">
                        <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@number"/>
                    </xsl:for-each>
                </xsl:variable>

                <xsl:variable name="target.elem">
                    <xsl:for-each select="$target.database">
                        <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@element"/>
                    </xsl:for-each>
                </xsl:variable>

                <xsl:variable name="lang">
                    <xsl:variable name="candidate">
                        <xsl:for-each select="$target.database">
                            <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@lang"/>
                        </xsl:for-each>
                    </xsl:variable>
                    <xsl:choose>
                        <xsl:when test="$candidate != ''">
                            <xsl:value-of select="$candidate"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$olink.lang"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>

                <xsl:variable name="targetdoc">
                    <xsl:value-of select="substring-before($olink.key, '/')"/>
                </xsl:variable>

                <xsl:choose>
                    <xsl:when
                            test="$xrefstyle != '' and                         starts-with(normalize-space($xrefstyle), 'select:') and                         (contains($xrefstyle, 'nodocname') or                         contains($xrefstyle, 'nopage')) and                         not(contains($xrefstyle, 'title')) and                         not(contains($xrefstyle, 'label'))">
                        <xsl:copy-of select="$xref.text"/>
                    </xsl:when>
                    <xsl:when test="$xrefstyle != ''">
                        <xsl:if test="$olink.debug != 0">
                            <xsl:message>
                                <xsl:text>xrefstyle is '</xsl:text>
                                <xsl:value-of select="$xrefstyle"/>
                                <xsl:text>'.</xsl:text>
                            </xsl:message>
                        </xsl:if>
                        <xsl:variable name="template">
                            <xsl:choose>
                                <xsl:when
                                        test="starts-with(normalize-space($xrefstyle),                                           'select:')">
                                    <xsl:call-template name="make.gentext.template">
                                        <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                                        <xsl:with-param name="purpose" select="'olink'"/>
                                        <xsl:with-param name="referrer" select="."/>
                                        <xsl:with-param name="target.elem" select="$target.elem"/>
                                    </xsl:call-template>
                                </xsl:when>
                                <xsl:when
                                        test="starts-with(normalize-space($xrefstyle),                                           'template:')">
                                    <xsl:value-of
                                            select="substring-after(                                  normalize-space($xrefstyle), 'template:')"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <!-- Look for Gentext template with @style attribute -->
                                    <!-- Must compare to no style value because gentext.template
                     falls back to no style -->

                                    <xsl:variable name="xref-context">
                                        <xsl:call-template name="gentext.template">
                                            <xsl:with-param name="context" select="'xref'"/>
                                            <xsl:with-param name="name" select="$target.elem"/>
                                            <xsl:with-param name="lang" select="$lang"/>
                                        </xsl:call-template>
                                    </xsl:variable>

                                    <xsl:variable name="styled-xref-context">
                                        <xsl:call-template name="gentext.template">
                                            <xsl:with-param name="context" select="'xref'"/>
                                            <xsl:with-param name="name" select="$target.elem"/>
                                            <xsl:with-param name="lang" select="$lang"/>
                                            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                                        </xsl:call-template>
                                    </xsl:variable>

                                    <xsl:variable name="xref-number-context">
                                        <xsl:call-template name="gentext.template">
                                            <xsl:with-param name="context" select="'xref-number'"/>
                                            <xsl:with-param name="name" select="$target.elem"/>
                                            <xsl:with-param name="lang" select="$lang"/>
                                        </xsl:call-template>
                                    </xsl:variable>

                                    <xsl:variable name="styled-xref-number-context">
                                        <xsl:call-template name="gentext.template">
                                            <xsl:with-param name="context" select="'xref-number'"/>
                                            <xsl:with-param name="name" select="$target.elem"/>
                                            <xsl:with-param name="lang" select="$lang"/>
                                            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                                        </xsl:call-template>
                                    </xsl:variable>

                                    <xsl:variable name="xref-number-and-title-context">
                                        <xsl:call-template name="gentext.template">
                                            <xsl:with-param name="context" select="'xref-number-and-title'"/>
                                            <xsl:with-param name="name" select="$target.elem"/>
                                            <xsl:with-param name="lang" select="$lang"/>
                                        </xsl:call-template>
                                    </xsl:variable>

                                    <xsl:variable name="styled-xref-number-and-title-context">
                                        <xsl:call-template name="gentext.template">
                                            <xsl:with-param name="context" select="'xref-number-and-title'"/>
                                            <xsl:with-param name="name" select="$target.elem"/>
                                            <xsl:with-param name="lang" select="$lang"/>
                                            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                                        </xsl:call-template>
                                    </xsl:variable>

                                    <xsl:choose>
                                        <xsl:when
                                                test="$xref-number-and-title-context !=                                   $styled-xref-number-and-title-context and                                  $xref.number != '' and                                  $xref.with.number.and.title != 0">
                                            <xsl:value-of select="$styled-xref-number-and-title-context"/>
                                        </xsl:when>
                                        <xsl:when
                                                test="$xref-number-context !=                                   $styled-xref-number-context and                                  $xref.number != ''">
                                            <xsl:value-of select="$styled-xref-number-context"/>
                                        </xsl:when>
                                        <xsl:when test="$xref-context != $styled-xref-context">
                                            <xsl:value-of select="$styled-xref-context"/>
                                        </xsl:when>
                                        <xsl:when
                                                test="$xref-number-and-title-context != '' and                                  $xref.number != '' and                                  $xref.with.number.and.title != 0">
                                            <xsl:value-of select="$xref-number-and-title-context"/>
                                            <xsl:if test="$olink.debug">
                                                <xsl:message>
                                                    <xsl:text>Olink error: no gentext template</xsl:text>
                                                    <xsl:text> exists for xrefstyle '</xsl:text>
                                                    <xsl:value-of select="$xrefstyle"/>
                                                    <xsl:text>' for element '</xsl:text>
                                                    <xsl:value-of select="$target.elem"/>
                                                    <xsl:text>' in language '</xsl:text>
                                                    <xsl:value-of select="$lang"/>
                                                    <xsl:text>' in context 'xref-number-and-title</xsl:text>
                                                    <xsl:text>'. Using template without @style.</xsl:text>
                                                </xsl:message>
                                            </xsl:if>
                                        </xsl:when>
                                        <xsl:when
                                                test="$xref-number-context != '' and                                  $xref.number != ''">
                                            <xsl:value-of select="$xref-number-context"/>
                                            <xsl:if test="$olink.debug">
                                                <xsl:message>
                                                    <xsl:text>Olink error: no gentext template</xsl:text>
                                                    <xsl:text> exists for xrefstyle '</xsl:text>
                                                    <xsl:value-of select="$xrefstyle"/>
                                                    <xsl:text>' for element '</xsl:text>
                                                    <xsl:value-of select="$target.elem"/>
                                                    <xsl:text>' in language '</xsl:text>
                                                    <xsl:value-of select="$lang"/>
                                                    <xsl:text>' in context 'xref-number</xsl:text>
                                                    <xsl:text>'. Using template without @style.</xsl:text>
                                                </xsl:message>
                                            </xsl:if>
                                        </xsl:when>
                                        <xsl:when test="$xref-context != ''">
                                            <xsl:value-of select="$xref-context"/>
                                            <xsl:if test="$olink.debug">
                                                <xsl:message>
                                                    <xsl:text>Olink error: no gentext template</xsl:text>
                                                    <xsl:text> exists for xrefstyle '</xsl:text>
                                                    <xsl:value-of select="$xrefstyle"/>
                                                    <xsl:text>' for element '</xsl:text>
                                                    <xsl:value-of select="$target.elem"/>
                                                    <xsl:text>' in language '</xsl:text>
                                                    <xsl:value-of select="$lang"/>
                                                    <xsl:text>' in context 'xref</xsl:text>
                                                    <xsl:text>'. Using template without @style.</xsl:text>
                                                </xsl:message>
                                            </xsl:if>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:message>
                                                <xsl:text>Olink error: no gentext template</xsl:text>
                                                <xsl:text> exists for xrefstyle '</xsl:text>
                                                <xsl:value-of select="$xrefstyle"/>
                                                <xsl:text>' for element '</xsl:text>
                                                <xsl:value-of select="$target.elem"/>
                                                <xsl:text>' in language '</xsl:text>
                                                <xsl:value-of select="$lang"/>
                                                <xsl:text>'. Trying '%t'.</xsl:text>
                                            </xsl:message>
                                            <xsl:value-of select="'%t'"/>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:variable>

                        <xsl:if test="$olink.debug != 0">
                            <xsl:message>
                                <xsl:text>Olink debug: xrefstyle template is '</xsl:text>
                                <xsl:value-of select="$template"/>
                                <xsl:text>'.</xsl:text>
                            </xsl:message>
                        </xsl:if>

                        <xsl:call-template name="substitute-markup">
                            <xsl:with-param name="template" select="$template"/>
                            <xsl:with-param name="title">
                                <xsl:for-each select="$target.database">
                                    <xsl:call-template name="insert.targetdb.data">
                                        <xsl:with-param name="data"
                                                        select="key('targetptr-key', $olink.key)/ttl/node()"/>
                                    </xsl:call-template>
                                </xsl:for-each>
                            </xsl:with-param>
                            <xsl:with-param name="label">
                                <xsl:for-each select="$target.database">
                                    <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@number"/>
                                </xsl:for-each>
                            </xsl:with-param>
                            <xsl:with-param name="pagenumber">
                                <xsl:for-each select="$target.database">
                                    <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@page"/>
                                </xsl:for-each>
                            </xsl:with-param>
                            <xsl:with-param name="docname">
                                <xsl:for-each select="$target.database">
                                    <xsl:call-template name="insert.targetdb.data">
                                        <xsl:with-param name="data"
                                                        select="key('targetdoc-key', $targetdoc)[1]/div[1]/ttl/node()"/>
                                    </xsl:call-template>
                                </xsl:for-each>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:when>

                    <xsl:when test="$use.local.olink.style != 0">

                        <!-- Is autonumbering on? -->
                        <xsl:variable name="target.number">
                            <xsl:for-each select="$target.database">
                                <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@number"/>
                            </xsl:for-each>
                        </xsl:variable>

                        <xsl:variable name="autonumber">
                            <xsl:choose>
                                <xsl:when test="$target.number != ''">1</xsl:when>
                                <xsl:otherwise>0</xsl:otherwise>
                            </xsl:choose>
                        </xsl:variable>

                        <xsl:variable name="number-and-title-template">
                            <xsl:call-template name="gentext.template.exists">
                                <xsl:with-param name="context" select="'xref-number-and-title'"/>
                                <xsl:with-param name="name" select="$target.elem"/>
                            </xsl:call-template>
                        </xsl:variable>

                        <xsl:variable name="number-template">
                            <xsl:call-template name="gentext.template.exists">
                                <xsl:with-param name="context" select="'xref-number'"/>
                                <xsl:with-param name="name" select="$target.elem"/>
                            </xsl:call-template>
                        </xsl:variable>

                        <xsl:variable name="context">
                            <xsl:choose>
                                <xsl:when
                                        test="string($autonumber) != 0                                and $number-and-title-template != 0                               and $xref.with.number.and.title != 0">
                                    <xsl:value-of select="'xref-number-and-title'"/>
                                </xsl:when>
                                <xsl:when
                                        test="string($autonumber) != 0                                and $number-template != 0">
                                    <xsl:value-of select="'xref-number'"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:value-of select="'xref'"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:variable>

                        <xsl:variable name="template">
                            <xsl:call-template name="gentext.template">
                                <xsl:with-param name="context" select="$context"/>
                                <xsl:with-param name="name" select="$target.elem"/>
                                <xsl:with-param name="lang" select="$lang"/>
                            </xsl:call-template>
                        </xsl:variable>

                        <xsl:call-template name="substitute-markup">
                            <xsl:with-param name="template" select="$template"/>
                            <xsl:with-param name="title">
                                <xsl:for-each select="$target.database">
                                    <xsl:call-template name="insert.targetdb.data">
                                        <xsl:with-param name="data"
                                                        select="key('targetptr-key', $olink.key)[1]/ttl/node()"/>
                                    </xsl:call-template>
                                </xsl:for-each>
                            </xsl:with-param>
                            <xsl:with-param name="label">
                                <xsl:for-each select="$target.database">
                                    <xsl:call-template name="insert.targetdb.data">
                                        <xsl:with-param name="data"
                                                        select="key('targetptr-key', $olink.key)[1]/@number"/>
                                    </xsl:call-template>
                                </xsl:for-each>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:when test="$xref.text !=''">
                        <xsl:copy-of select="$xref.text"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message>
                            <xsl:text>Olink error: no generated text for </xsl:text>
                            <xsl:text>targetdoc/targetptr/lang = '</xsl:text>
                            <xsl:value-of select="$olink.key"/>
                            <xsl:text>'.</xsl:text>
                        </xsl:message>
                        <xsl:text>????</xsl:text>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:if test="$olink.key != ''">
                    <xsl:message>
                        <xsl:text>Olink error: no generated text for </xsl:text>
                        <xsl:text>targetdoc/targetptr/lang = '</xsl:text>
                        <xsl:value-of select="$olink.key"/>
                        <xsl:text>'.</xsl:text>
                    </xsl:message>
                </xsl:if>
                <xsl:text>????</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="insert.targetdb.data">
        <xsl:param name="data"/>
        <!-- Customize this to massage data further -->
        <xsl:copy-of select="$data"/>
    </xsl:template>
    <xsl:template match="*" mode="olink.docname.markup">
        <!-- No-op for now -->
    </xsl:template>
    <xsl:template name="targetpath">
        <xsl:param name="dirnode"/>
        <xsl:param name="targetdoc" select="''"/>

        <!-- 
<xsl:message>dirnode is <xsl:value-of select="$dirnode/@name"/></xsl:message>
<xsl:message>targetdoc is <xsl:value-of select="$targetdoc"/></xsl:message>
-->
        <!-- recursive template generates path to olink target directory -->
        <xsl:choose>
            <!-- Have we arrived at the final path step? -->
            <xsl:when test="$dirnode/child::document[@targetdoc = $targetdoc]">
                <!-- We are done -->
            </xsl:when>
            <!-- Have we reached the top without a match? -->
            <xsl:when test="local-name($dirnode) != 'dir'">
                <xsl:message>Olink error: cannot locate targetdoc
                    <xsl:value-of select="$targetdoc"/> in sitemap
                </xsl:message>
            </xsl:when>
            <!-- Is the target in a descendant? -->
            <xsl:when test="$dirnode/descendant::document/@targetdoc = $targetdoc">
                <xsl:variable name="step" select="$dirnode/child::dir[descendant::document/@targetdoc = $targetdoc]"/>
                <xsl:if test="$step">
                    <xsl:value-of select="$step/@name"/>
                    <xsl:text>/</xsl:text>
                </xsl:if>
                <!-- Now recurse with the child -->
                <xsl:call-template name="targetpath">
                    <xsl:with-param name="dirnode" select="$step"/>
                    <xsl:with-param name="targetdoc" select="$targetdoc"/>
                </xsl:call-template>
            </xsl:when>
            <!-- Otherwise we need to move up a step -->
            <xsl:otherwise>
                <xsl:if test="$dirnode/parent::dir">
                    <xsl:text>../</xsl:text>
                </xsl:if>
                <xsl:call-template name="targetpath">
                    <xsl:with-param name="dirnode" select="$dirnode/parent::*"/>
                    <xsl:with-param name="targetdoc" select="$targetdoc"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="olink.page.citation">
        <xsl:param name="olink.key" select="''"/>
        <xsl:param name="olink.lang" select="'en'"/>
        <xsl:param name="target.database"/>
        <xsl:param name="linkend" select="''"/>
        <xsl:param name="xrefstyle">
            <xsl:choose>
                <xsl:when test="@role and not(@xrefstyle)                        and $use.role.as.xrefstyle != 0">
                    <xsl:value-of select="@role"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="@xrefstyle"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:param>

        <xsl:variable name="targetdoc">
            <xsl:value-of select="substring-before($olink.key, '/')"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$linkend != ''">
                <xsl:call-template name="xref.page.citation">
                    <xsl:with-param name="linkend" select="$linkend"/>
                    <xsl:with-param name="target" select="key('id', $linkend)"/>
                    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when
                    test="not(starts-with(normalize-space($xrefstyle),                         'select:')                  and (contains($xrefstyle, 'page')                      or contains($xrefstyle, 'Page')))                 and $current.docid != ''                  and $current.docid != $targetdoc                 and $insert.olink.page.number = 'yes' ">

                <xsl:variable name="page-number">
                    <xsl:for-each select="$target.database">
                        <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@page"/>
                    </xsl:for-each>
                </xsl:variable>

                <xsl:if test="$page-number != ''">
                    <xsl:call-template name="substitute-markup">
                        <xsl:with-param name="template">
                            <xsl:call-template name="gentext.template">
                                <xsl:with-param name="name" select="'olink.page.citation'"/>
                                <xsl:with-param name="context" select="'xref'"/>
                                <xsl:with-param name="lang" select="$olink.lang"/>
                            </xsl:call-template>
                        </xsl:with-param>
                        <xsl:with-param name="pagenumber" select="$page-number"/>
                    </xsl:call-template>
                </xsl:if>

            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="olink.document.citation">
        <xsl:param name="olink.key" select="''"/>
        <xsl:param name="olink.lang" select="'en'"/>
        <xsl:param name="target.database"/>
        <xsl:param name="xrefstyle">
            <xsl:choose>
                <xsl:when test="@role and not(@xrefstyle)                        and $use.role.as.xrefstyle != 0">
                    <xsl:value-of select="@role"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="@xrefstyle"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:param>

        <xsl:variable name="page">
            <xsl:for-each select="$target.database">
                <xsl:value-of select="key('targetptr-key', $olink.key)[1]/@page"/>
            </xsl:for-each>
        </xsl:variable>

        <xsl:variable name="targetdoc">
            <xsl:value-of select="substring-before($olink.key, '/')"/>
        </xsl:variable>

        <xsl:variable name="targetptr">
            <xsl:value-of select="substring-before(substring-after($olink.key, '/'), '/')"/>
        </xsl:variable>

        <!-- Don't add docname if pointing to root element -->
        <xsl:variable name="rootptr">
            <xsl:for-each select="$target.database">
                <xsl:value-of select="key('targetdoc-key', $targetdoc)[1]/div[1]/@targetptr"/>
            </xsl:for-each>
        </xsl:variable>

        <xsl:variable name="docname">
            <xsl:for-each select="$target.database">
                <xsl:call-template name="insert.targetdb.data">
                    <xsl:with-param name="data" select="key('targetdoc-key', $targetdoc)[1]/div[1]/ttl/node()"/>
                </xsl:call-template>
            </xsl:for-each>
        </xsl:variable>

        <xsl:if test="not(starts-with(normalize-space($xrefstyle), 'select:')                and (contains($xrefstyle, 'docname')))               and ($olink.doctitle = 'yes' or $olink.doctitle = '1')               and $current.docid != ''                and $rootptr != $targetptr               and $current.docid != $targetdoc               and $docname != ''">
            <xsl:call-template name="substitute-markup">
                <xsl:with-param name="template">
                    <xsl:call-template name="gentext.template">
                        <xsl:with-param name="name" select="'olink.document.citation'"/>
                        <xsl:with-param name="context" select="'xref'"/>
                        <xsl:with-param name="lang" select="$olink.lang"/>
                    </xsl:call-template>
                </xsl:with-param>
                <xsl:with-param name="docname" select="$docname"/>
                <xsl:with-param name="pagenumber" select="$page"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template name="xref.page.citation">
        <!-- Determine if this xref should have a page citation.
       Context node is the xref or local olink element -->
        <xsl:param name="linkend" select="@linkend"/>
        <xsl:param name="target" select="key('id', $linkend)"/>
        <xsl:param name="xrefstyle">
            <xsl:choose>
                <xsl:when test="@role and not(@xrefstyle)                        and $use.role.as.xrefstyle != 0">
                    <xsl:value-of select="@role"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="@xrefstyle"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:param>

        <xsl:if test="not(starts-with(normalize-space($xrefstyle),'select:')                     and (contains($xrefstyle, 'page')                          or contains($xrefstyle, 'Page')))                 and ( $insert.xref.page.number = 'yes'                     or $insert.xref.page.number = '1')                 or local-name($target) = 'para'">
            <xsl:apply-templates select="$target" mode="page.citation">
                <xsl:with-param name="id" select="$linkend"/>
            </xsl:apply-templates>
        </xsl:if>
    </xsl:template>
    <doc:reference xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0">
        <info>
            <title>Common Processing Instruction Reference</title>
            <releaseinfo role="meta">
                $Id: pi.xsl 8782 2010-07-27 21:15:17Z mzjn $
            </releaseinfo>
        </info>
        <partintro id="partintro">
            <title>Introduction</title>
            <para>This is generated reference documentation for all
                user-specifiable processing instructions (PIs) in the
                “common” part of the DocBook XSL stylesheets.
                <note>
                    <para>You add these PIs at particular points in a document to
                        cause specific “exceptions” to formatting/output behavior. To
                        make global changes in formatting/output behavior across an
                        entire document, it’s better to do it by setting an
                        appropriate stylesheet parameter (if there is one).
                    </para>
                </note>
            </para>
        </partintro>
    </doc:reference>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbchoice_choice">
        <refpurpose>Generates a localized choice separator</refpurpose>
        <refdescription id="select.choice.separator-desc">
            <para>Use the
                <tag class="xmlpi">dbchoice choice</tag>
                PI to
                generate an appropriate localized “choice” separator (for
                example,
                <literal>and</literal>
                or<literal>or</literal>)
                before the final item in an inline
                <tag>simplelist</tag>
            </para>
            <warning>
                <para>This PI is a less-than-ideal hack; support for it may
                    disappear in the future (particularly if and when a more
                    appropriate means for marking up "choice" lists becomes
                    available in DocBook).
                </para>
            </warning>
        </refdescription>
        <refsynopsisdiv>
            <synopsis>
                <tag class="xmlpi">dbchoice choice="and"|"or"|<replaceable>string</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter>
            <variablelist>
                <varlistentry>
                    <term>choice="and"</term>
                    <listitem>
                        <para>generates a localized
                            <literal>and</literal>
                            separator
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>choice="or"</term>
                    <listitem>
                        <para>generates a localized
                            <literal>or</literal>
                            separator
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>choice="<replaceable>string</replaceable>"
                    </term>
                    <listitem>
                        <para>generates a literal
                            <replaceable>string</replaceable>
                            separator
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
    </doc:pi>
    <xsl:template name="pi.dbchoice_choice">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="pi-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbchoice')"/>
            <xsl:with-param name="attribute">choice</xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbtimestamp">
        <refpurpose>Inserts a date timestamp</refpurpose>
        <refdescription>
            <para>Use the
                <tag class="xmlpi">dbtimestamp</tag>
                PI at any point in a
                source document to cause a date timestamp (a formatted
                string representing the current date and time) to be
                inserted in output of the document.
            </para>
        </refdescription>
        <refsynopsisdiv>
            <synopsis>
                <tag class="xmlpi">dbtimestamp format="<replaceable>formatstring</replaceable>" [padding="0"|"1"]
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter>
            <variablelist>
                <varlistentry>
                    <term>format="<replaceable>formatstring</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies format in which the date and time are
                            output
                        </para>
                        <note>
                            <para>For details of the content of the format string,
                                see<link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg"
                                         xlink:href="Datetime.html">Date and time</link>.
                            </para>
                        </note>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>padding="0"|"1"</term>
                    <listitem>
                        <para>Specifies padding behavior; if non-zero, padding is is added</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
    </doc:pi>
    <xsl:template name="pi.dbtimestamp">
        <xsl:variable name="format">
            <xsl:variable name="pi-format">
                <xsl:call-template name="pi-attribute">
                    <xsl:with-param name="pis" select="."/>
                    <xsl:with-param name="attribute">format</xsl:with-param>
                </xsl:call-template>
            </xsl:variable>
            <xsl:choose>
                <xsl:when test="$pi-format != ''">
                    <xsl:value-of select="$pi-format"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="gentext.template">
                        <xsl:with-param name="context" select="'datetime'"/>
                        <xsl:with-param name="name" select="'format'"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="padding">
            <xsl:variable name="pi-padding">
                <xsl:call-template name="pi-attribute">
                    <xsl:with-param name="pis" select="."/>
                    <xsl:with-param name="attribute">padding</xsl:with-param>
                </xsl:call-template>
            </xsl:variable>
            <xsl:choose>
                <xsl:when test="$pi-padding != ''">
                    <xsl:value-of select="$pi-padding"/>
                </xsl:when>
                <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="date">
            <xsl:choose>
                <xsl:when test="function-available('date:date-time')">
                    <xsl:value-of select="date:date-time()"/>
                </xsl:when>
                <xsl:when test="function-available('date:dateTime')">
                    <!-- Xalan quirk -->
                    <xsl:value-of select="date:dateTime()"/>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="function-available('date:date-time') or       function-available('date:dateTime')">
                <xsl:call-template name="datetime.format">
                    <xsl:with-param name="date" select="$date"/>
                    <xsl:with-param name="format" select="$format"/>
                    <xsl:with-param name="padding" select="$padding"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>
                    Timestamp processing requires XSLT processor with EXSLT date support.
                </xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbtex_delims">
        <refpurpose>Generates delimiters around embedded TeX equations
            in output
        </refpurpose>
        <refdescription>
            <para>Use the
                <tag class="xmlpi">dbtex delims</tag>
                PI as a
                child of a
                <tag>textobject</tag>
                containing embedded TeX
                markup, to cause that markup to be surrounded by
                <literal>$</literal>
                delimiter characters in output.
            </para>
            <warning>
                <para>This feature is useful for print/PDF output only if you
                    use the obsolete and now unsupported PassiveTeX XSL-FO
                    engine.
                </para>
            </warning>
        </refdescription>
        <refsynopsisdiv>
            <synopsis>
                <tag class="xmlpi">dbtex delims="no"|"yes"</tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter>
            <variablelist>
                <varlistentry>
                    <term>dbtex delims="no"|"yes"</term>
                    <listitem>
                        <para>Specifies whether delimiters are output</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>

        <refsee role="params">
            <para>
                <parameter>tex.math.delims</parameter>
            </para>
        </refsee>

    </doc:pi>
    <xsl:template name="pi.dbtex_delims">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="pi-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbtex')"/>
            <xsl:with-param name="attribute" select="'delims'"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="processing-instruction()" mode="titlepage.mode">
        <!-- * Als process PIs on title pages -->
        <xsl:apply-templates select="."/>
    </xsl:template>
    <xsl:template match="processing-instruction('dbtimestamp')">
        <xsl:call-template name="pi.dbtimestamp"/>
    </xsl:template>
    <xsl:template name="datetime.format">
        <xsl:param name="date"/>
        <xsl:param name="format"/>
        <xsl:param name="padding" select="1"/>
        <xsl:if test="$format != ''">
            <!-- replace any whitespace in the format string with a non-breaking space -->
            <xsl:variable name="format-nbsp"
                          select="translate($format,       ' &#9;&#13;&#10;',       '&#xA0;&#xA0;&#xA0;&#xA0;')"/>
            <xsl:variable name="tokenized-format-string">
                <xsl:call-template name="str.tokenize.keep.delimiters">
                    <xsl:with-param name="string" select="$format-nbsp"/>
                    <xsl:with-param name="delimiters" select="'&#xA0;,./-()[]:'"/>
                </xsl:call-template>
            </xsl:variable>
            <xsl:choose>
                <xsl:when test="$exsl.node.set.available != 0">
                    <!-- We must preserve context node in order to get valid language -->
                    <xsl:variable name="context" select="."/>
                    <xsl:for-each select="exsl:node-set($tokenized-format-string)/node()">
                        <xsl:variable name="token">
                            <xsl:value-of select="."/>
                        </xsl:variable>
                        <!-- Restore context node -->
                        <xsl:for-each select="$context">
                            <xsl:choose>
                                <xsl:when test="$token = 'a'">
                                    <xsl:call-template name="gentext.template">
                                        <xsl:with-param name="context" select="'datetime-abbrev'"/>
                                        <xsl:with-param name="name" select="date:day-abbreviation($date)"/>
                                    </xsl:call-template>
                                </xsl:when>
                                <xsl:when test="$token = 'A'">
                                    <xsl:call-template name="gentext.template">
                                        <xsl:with-param name="context" select="'datetime-full'"/>
                                        <xsl:with-param name="name" select="date:day-name($date)"/>
                                    </xsl:call-template>
                                </xsl:when>
                                <xsl:when test="$token = 'b'">
                                    <xsl:call-template name="gentext.template">
                                        <xsl:with-param name="context" select="'datetime-abbrev'"/>
                                        <xsl:with-param name="name" select="date:month-abbreviation($date)"/>
                                    </xsl:call-template>
                                </xsl:when>
                                <xsl:when test="$token = 'c'">
                                    <xsl:value-of select="date:date($date)"/>
                                    <xsl:text> </xsl:text>
                                    <xsl:value-of select="date:time($date)"/>
                                </xsl:when>
                                <xsl:when test="$token = 'B'">
                                    <xsl:call-template name="gentext.template">
                                        <xsl:with-param name="context" select="'datetime-full'"/>
                                        <xsl:with-param name="name" select="date:month-name($date)"/>
                                    </xsl:call-template>
                                </xsl:when>
                                <xsl:when test="$token = 'd'">
                                    <xsl:if test="$padding = 1 and                   string-length(date:day-in-month($date)) = 1">
                                        0
                                    </xsl:if>
                                    <xsl:value-of select="date:day-in-month($date)"/>
                                </xsl:when>
                                <xsl:when test="$token = 'H'">
                                    <xsl:if test="$padding = 1 and string-length(date:hour-in-day($date)) = 1">0
                                    </xsl:if>
                                    <xsl:value-of select="date:hour-in-day($date)"/>
                                </xsl:when>
                                <xsl:when test="$token = 'j'">
                                    <xsl:value-of select="date:day-in-year($date)"/>
                                </xsl:when>
                                <xsl:when test="$token = 'm'">
                                    <xsl:if test="$padding = 1 and string-length(date:month-in-year($date)) = 1">0
                                    </xsl:if>
                                    <xsl:value-of select="date:month-in-year($date)"/>
                                </xsl:when>
                                <xsl:when test="$token = 'M'">
                                    <xsl:if test="string-length(date:minute-in-hour($date)) = 1">0</xsl:if>
                                    <xsl:value-of select="date:minute-in-hour($date)"/>
                                </xsl:when>
                                <xsl:when test="$token = 'S'">
                                    <xsl:if test="string-length(date:second-in-minute($date)) = 1">0</xsl:if>
                                    <xsl:value-of select="date:second-in-minute($date)"/>
                                </xsl:when>
                                <xsl:when test="$token = 'U'">
                                    <xsl:value-of select="date:week-in-year($date)"/>
                                </xsl:when>
                                <xsl:when test="$token = 'w'">
                                    <xsl:value-of select="date:day-in-week($date)"/>
                                </xsl:when>
                                <xsl:when test="$token = 'x'">
                                    <xsl:value-of select="date:date($date)"/>
                                </xsl:when>
                                <xsl:when test="$token = 'X'">
                                    <xsl:value-of select="date:time($date)"/>
                                </xsl:when>
                                <xsl:when test="$token = 'Y'">
                                    <xsl:value-of select="date:year($date)"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:value-of select="$token"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:for-each>
                    </xsl:for-each>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:message>
                        Timestamp processing requires an XSLT processor with support
                        for the EXSLT node-set() function.
                    </xsl:message>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
    </xsl:template>
    <xsl:variable name="toc.listitem.type">
        <xsl:choose>
            <xsl:when test="$toc.list.type = 'dl'">dt</xsl:when>
            <xsl:otherwise>li</xsl:otherwise>
        </xsl:choose>
    </xsl:variable>
    <xsl:variable name="toc.dd.type">
        <xsl:choose>
            <xsl:when test="$toc.list.type = 'dl'">dd</xsl:when>
            <xsl:otherwise/>
        </xsl:choose>
    </xsl:variable>
    <xsl:template name="make.toc">
        <xsl:param name="toc-context" select="."/>
        <xsl:param name="toc.title.p" select="true()"/>
        <xsl:param name="nodes" select="/NOT-AN-ELEMENT"/>

        <xsl:variable name="nodes.plus" select="$nodes | qandaset"/>

        <xsl:variable name="toc.title">
            <xsl:if test="$toc.title.p">
                <xsl:choose>
                    <xsl:when test="$make.clean.html != 0">
                        <div class="{$class.prefix}toc-title">
                            <xsl:call-template name="gentext">
                                <xsl:with-param name="key">TableofContents</xsl:with-param>
                            </xsl:call-template>
                        </div>
                    </xsl:when>
                    <xsl:otherwise>
                        <p>
                            <strong>
                                <xsl:call-template name="gentext">
                                    <xsl:with-param name="key">TableofContents</xsl:with-param>
                                </xsl:call-template>
                            </strong>
                        </p>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:if>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$manual.toc != ''">
                <xsl:variable name="id">
                    <xsl:call-template name="object.id"/>
                </xsl:variable>
                <xsl:variable name="toc" select="document($manual.toc, .)"/>
                <xsl:variable name="tocentry" select="$toc//tocentry[@linkend=$id]"/>
                <xsl:if test="$tocentry and $tocentry/*">
                    <div class="{$class.prefix}toc">
                        <xsl:copy-of select="$toc.title"/>
                        <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
                            <xsl:call-template name="toc.list.attributes">
                                <xsl:with-param name="toc-context" select="$toc-context"/>
                                <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
                                <xsl:with-param name="nodes" select="$nodes"/>
                            </xsl:call-template>
                            <xsl:call-template name="manual-toc">
                                <xsl:with-param name="tocentry" select="$tocentry/*[1]"/>
                            </xsl:call-template>
                        </xsl:element>
                    </div>
                </xsl:if>
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="$qanda.in.toc != 0">
                        <xsl:if test="$nodes.plus">
                            <div class="{$class.prefix}toc">
                                <xsl:copy-of select="$toc.title"/>
                                <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
                                    <xsl:call-template name="toc.list.attributes">
                                        <xsl:with-param name="toc-context" select="$toc-context"/>
                                        <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
                                        <xsl:with-param name="nodes" select="$nodes"/>
                                    </xsl:call-template>
                                    <xsl:apply-templates select="$nodes.plus" mode="toc">
                                        <xsl:with-param name="toc-context" select="$toc-context"/>
                                    </xsl:apply-templates>
                                </xsl:element>
                            </div>
                        </xsl:if>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:if test="$nodes">
                            <div class="{$class.prefix}toc">
                                <xsl:copy-of select="$toc.title"/>
                                <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
                                    <xsl:call-template name="toc.list.attributes">
                                        <xsl:with-param name="toc-context" select="$toc-context"/>
                                        <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
                                        <xsl:with-param name="nodes" select="$nodes"/>
                                    </xsl:call-template>
                                    <xsl:apply-templates select="$nodes" mode="toc">
                                        <xsl:with-param name="toc-context" select="$toc-context"/>
                                    </xsl:apply-templates>
                                </xsl:element>
                            </div>
                        </xsl:if>
                    </xsl:otherwise>
                </xsl:choose>

            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="toc.list.attributes">
        <xsl:param name="toc-context" select="."/>
        <xsl:param name="toc.title.p" select="true()"/>
        <xsl:param name="nodes" select="/NOT-AN-ELEMENT"/>

        <xsl:attribute name="class"><xsl:value-of select="$class.prefix"/>toc
        </xsl:attribute>
    </xsl:template>
    <xsl:template name="make.lots">
        <xsl:param name="toc.params" select="''"/>
        <xsl:param name="toc"/>

        <xsl:if test="contains($toc.params, 'toc')">
            <xsl:copy-of select="$toc"/>
        </xsl:if>

        <xsl:if test="contains($toc.params, 'figure')">
            <xsl:call-template name="list.of.titles">
                <xsl:with-param name="titles" select="'figure'"/>
                <xsl:with-param name="nodes" select=".//figure"/>
            </xsl:call-template>
        </xsl:if>

        <xsl:if test="contains($toc.params, 'table')">
            <xsl:call-template name="list.of.titles">
                <xsl:with-param name="titles" select="'table'"/>
                <xsl:with-param name="nodes" select=".//table[not(@tocentry = 0)]"/>
            </xsl:call-template>
        </xsl:if>

        <xsl:if test="contains($toc.params, 'example')">
            <xsl:call-template name="list.of.titles">
                <xsl:with-param name="titles" select="'example'"/>
                <xsl:with-param name="nodes" select=".//example"/>
            </xsl:call-template>
        </xsl:if>

        <xsl:if test="contains($toc.params, 'equation')">
            <xsl:call-template name="list.of.titles">
                <xsl:with-param name="titles" select="'equation'"/>
                <xsl:with-param name="nodes" select=".//equation[title or info/title]"/>
            </xsl:call-template>
        </xsl:if>

        <xsl:if test="contains($toc.params, 'procedure')">
            <xsl:call-template name="list.of.titles">
                <xsl:with-param name="titles" select="'procedure'"/>
                <xsl:with-param name="nodes" select=".//procedure[title]"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template name="set.toc">
        <xsl:param name="toc-context" select="."/>
        <xsl:param name="toc.title.p" select="true()"/>

        <xsl:call-template name="make.toc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
            <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
            <xsl:with-param name="nodes" select="book|setindex|set"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="division.toc">
        <xsl:param name="toc-context" select="."/>
        <xsl:param name="toc.title.p" select="true()"/>

        <xsl:call-template name="make.toc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
            <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
            <xsl:with-param name="nodes"
                            select="part|reference                                          |preface|chapter|appendix                                          |article                                          |topic                                          |bibliography|glossary|index                                          |refentry                                          |bridgehead[$bridgehead.in.toc != 0]"/>

        </xsl:call-template>
    </xsl:template>
    <xsl:template name="component.toc">
        <xsl:param name="toc-context" select="."/>
        <xsl:param name="toc.title.p" select="true()"/>

        <xsl:call-template name="make.toc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
            <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
            <xsl:with-param name="nodes"
                            select="section|sect1                                          |simplesect[$simplesect.in.toc != 0]                                          |topic                                          |refentry                                          |article|bibliography|glossary                                          |appendix|index                                          |bridgehead[not(@renderas)                                                      and $bridgehead.in.toc != 0]                                          |.//bridgehead[@renderas='sect1'                                                         and $bridgehead.in.toc != 0]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="component.toc.separator">
        <!-- Customize to output something between
       component.toc and first output -->
    </xsl:template>
    <xsl:template name="section.toc">
        <xsl:param name="toc-context" select="."/>
        <xsl:param name="toc.title.p" select="true()"/>

        <xsl:call-template name="make.toc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
            <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
            <xsl:with-param name="nodes"
                            select="section|sect1|sect2|sect3|sect4|sect5|refentry                            |bridgehead[$bridgehead.in.toc != 0]"/>

        </xsl:call-template>
    </xsl:template>
    <xsl:template name="section.toc.separator">
        <!-- Customize to output something between
       section.toc and first output -->
    </xsl:template>
    <xsl:template name="subtoc">
        <xsl:param name="toc-context" select="."/>
        <xsl:param name="nodes" select="NOT-AN-ELEMENT"/>

        <xsl:variable name="nodes.plus" select="$nodes | qandaset"/>

        <xsl:variable name="subtoc">
            <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
                <xsl:choose>
                    <xsl:when test="$qanda.in.toc != 0">
                        <xsl:apply-templates mode="toc" select="$nodes.plus">
                            <xsl:with-param name="toc-context" select="$toc-context"/>
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates mode="toc" select="$nodes">
                            <xsl:with-param name="toc-context" select="$toc-context"/>
                        </xsl:apply-templates>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:element>
        </xsl:variable>

        <xsl:variable name="depth">
            <xsl:choose>
                <xsl:when test="local-name(.) = 'section'">
                    <xsl:value-of select="count(ancestor::section) + 1"/>
                </xsl:when>
                <xsl:when test="local-name(.) = 'sect1'">1</xsl:when>
                <xsl:when test="local-name(.) = 'sect2'">2</xsl:when>
                <xsl:when test="local-name(.) = 'sect3'">3</xsl:when>
                <xsl:when test="local-name(.) = 'sect4'">4</xsl:when>
                <xsl:when test="local-name(.) = 'sect5'">5</xsl:when>
                <xsl:when test="local-name(.) = 'refsect1'">1</xsl:when>
                <xsl:when test="local-name(.) = 'refsect2'">2</xsl:when>
                <xsl:when test="local-name(.) = 'refsect3'">3</xsl:when>
                <xsl:when test="local-name(.) = 'topic'">1</xsl:when>
                <xsl:when test="local-name(.) = 'simplesect'">
                    <!-- sigh... -->
                    <xsl:choose>
                        <xsl:when test="local-name(..) = 'section'">
                            <xsl:value-of select="count(ancestor::section)"/>
                        </xsl:when>
                        <xsl:when test="local-name(..) = 'sect1'">2</xsl:when>
                        <xsl:when test="local-name(..) = 'sect2'">3</xsl:when>
                        <xsl:when test="local-name(..) = 'sect3'">4</xsl:when>
                        <xsl:when test="local-name(..) = 'sect4'">5</xsl:when>
                        <xsl:when test="local-name(..) = 'sect5'">6</xsl:when>
                        <xsl:when test="local-name(..) = 'topic'">2</xsl:when>
                        <xsl:when test="local-name(..) = 'refsect1'">2</xsl:when>
                        <xsl:when test="local-name(..) = 'refsect2'">3</xsl:when>
                        <xsl:when test="local-name(..) = 'refsect3'">4</xsl:when>
                        <xsl:otherwise>1</xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>0</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="depth.from.context" select="count(ancestor::*)-count($toc-context/ancestor::*)"/>

        <xsl:variable name="subtoc.list">
            <xsl:choose>
                <xsl:when test="$toc.dd.type = ''">
                    <xsl:copy-of select="$subtoc"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:element name="{$toc.dd.type}" namespace="http://www.w3.org/1999/xhtml">
                        <xsl:copy-of select="$subtoc"/>
                    </xsl:element>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:element name="{$toc.listitem.type}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="toc.line">
                <xsl:with-param name="toc-context" select="$toc-context"/>
            </xsl:call-template>
            <xsl:if test="$toc.listitem.type = 'li' and                   ( (self::set or self::book or self::part) or                          $toc.section.depth &gt; $depth) and                    ( ($qanda.in.toc = 0 and count($nodes)&gt;0) or                     ($qanda.in.toc != 0 and count($nodes.plus)&gt;0) )                   and $toc.max.depth &gt; $depth.from.context">
                <xsl:copy-of select="$subtoc.list"/>
            </xsl:if>
        </xsl:element>
        <xsl:if test="$toc.listitem.type != 'li' and                   ( (self::set or self::book or self::part) or                          $toc.section.depth &gt; $depth) and                  ( ($qanda.in.toc = 0 and count($nodes)&gt;0) or                   ($qanda.in.toc != 0 and count($nodes.plus)&gt;0) )                 and $toc.max.depth &gt; $depth.from.context">
            <xsl:copy-of select="$subtoc.list"/>
        </xsl:if>
    </xsl:template>
    <xsl:template name="toc.line">
        <xsl:param name="toc-context" select="."/>
        <xsl:param name="depth" select="1"/>
        <xsl:param name="depth.from.context" select="8"/>

        <span>
            <xsl:attribute name="class">
                <xsl:value-of select="$class.prefix"/><xsl:value-of select="local-name(.)"/>
            </xsl:attribute>

            <!-- * if $autotoc.label.in.hyperlink is zero, then output the label -->
            <!-- * before the hyperlinked title (as the DSSSL stylesheet does) -->
            <xsl:if test="$autotoc.label.in.hyperlink = 0">
                <xsl:variable name="label">
                    <xsl:apply-templates select="." mode="label.markup"/>
                </xsl:variable>
                <xsl:copy-of select="$label"/>
                <xsl:if test="$label != ''">
                    <xsl:value-of select="$autotoc.label.separator"/>
                </xsl:if>
            </xsl:if>

            <a>
                <xsl:attribute name="href">
                    <xsl:call-template name="href.target">
                        <xsl:with-param name="context" select="$toc-context"/>
                        <xsl:with-param name="toc-context" select="$toc-context"/>
                    </xsl:call-template>
                </xsl:attribute>

                <!-- * if $autotoc.label.in.hyperlink is non-zero, then output the label -->
                <!-- * as part of the hyperlinked title -->
                <xsl:if test="not($autotoc.label.in.hyperlink = 0)">
                    <xsl:variable name="label">
                        <xsl:apply-templates select="." mode="label.markup"/>
                    </xsl:variable>
                    <xsl:copy-of select="$label"/>
                    <xsl:if test="$label != ''">
                        <xsl:value-of select="$autotoc.label.separator"/>
                    </xsl:if>
                </xsl:if>

                <xsl:apply-templates select="." mode="titleabbrev.markup"/>
            </a>
        </span>
    </xsl:template>
    <xsl:template match="book" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <xsl:call-template name="subtoc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
            <xsl:with-param name="nodes"
                            select="part|reference                                          |preface|chapter|appendix                                          |article                                          |topic                                          |bibliography|glossary|index                                          |refentry                                          |bridgehead[$bridgehead.in.toc != 0]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="setindex" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <!-- If the setindex tag is not empty, it should be it in the TOC -->
        <xsl:if test="* or $generate.index != 0">
            <xsl:call-template name="subtoc">
                <xsl:with-param name="toc-context" select="$toc-context"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template match="part|reference" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <xsl:call-template name="subtoc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
            <xsl:with-param name="nodes"
                            select="appendix|chapter|article|topic                                          |index|glossary|bibliography                                          |preface|reference|refentry                                          |bridgehead[$bridgehead.in.toc != 0]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="preface|chapter|appendix|article|topic" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <xsl:call-template name="subtoc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
            <xsl:with-param name="nodes"
                            select="section|sect1                                          |simplesect[$simplesect.in.toc != 0]                                          |topic                                          |refentry                                          |glossary|bibliography|index                                          |bridgehead[$bridgehead.in.toc != 0]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="sect1" mode="toc">
        <xsl:param name="toc-context" select="."/>
        <xsl:call-template name="subtoc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
            <xsl:with-param name="nodes"
                            select="sect2                                          |bridgehead[$bridgehead.in.toc != 0]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="sect2" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <xsl:call-template name="subtoc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
            <xsl:with-param name="nodes"
                            select="sect3                                          |bridgehead[$bridgehead.in.toc != 0]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="sect3" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <xsl:call-template name="subtoc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
            <xsl:with-param name="nodes"
                            select="sect4                                          |bridgehead[$bridgehead.in.toc != 0]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="sect4" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <xsl:call-template name="subtoc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
            <xsl:with-param name="nodes"
                            select="sect5                                          |bridgehead[$bridgehead.in.toc != 0]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="sect5" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <xsl:call-template name="subtoc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="simplesect" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <xsl:call-template name="subtoc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="section" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <xsl:call-template name="subtoc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
            <xsl:with-param name="nodes"
                            select="section|refentry                                          |simplesect[$simplesect.in.toc != 0]                                          |bridgehead[$bridgehead.in.toc != 0]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="topic" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <xsl:call-template name="subtoc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
            <xsl:with-param name="nodes"
                            select="section|refentry                                          |simplesect[$simplesect.in.toc != 0]                                          |bridgehead[$bridgehead.in.toc != 0]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="bridgehead" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <xsl:if test="$bridgehead.in.toc != 0">
            <xsl:call-template name="subtoc">
                <xsl:with-param name="toc-context" select="$toc-context"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template match="bibliography|glossary" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <xsl:call-template name="subtoc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="index" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <!-- If the index tag is not empty, it should be it in the TOC -->
        <xsl:if test="* or $generate.index != 0">
            <xsl:call-template name="subtoc">
                <xsl:with-param name="toc-context" select="$toc-context"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template match="refentry" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <xsl:variable name="refmeta" select=".//refmeta"/>
        <xsl:variable name="refentrytitle" select="$refmeta//refentrytitle"/>
        <xsl:variable name="refnamediv" select=".//refnamediv"/>
        <xsl:variable name="refname" select="$refnamediv//refname"/>
        <xsl:variable name="refdesc" select="$refnamediv//refdescriptor"/>
        <xsl:variable name="title">
            <xsl:choose>
                <xsl:when test="$refentrytitle">
                    <xsl:apply-templates select="$refentrytitle[1]" mode="titleabbrev.markup"/>
                </xsl:when>
                <xsl:when test="$refdesc">
                    <xsl:apply-templates select="$refdesc" mode="titleabbrev.markup"/>
                </xsl:when>
                <xsl:when test="$refname">
                    <xsl:apply-templates select="$refname[1]" mode="titleabbrev.markup"/>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:element name="{$toc.listitem.type}" namespace="http://www.w3.org/1999/xhtml">
            <span class="{$class.prefix}refentrytitle">
                <a>
                    <xsl:attribute name="href">
                        <xsl:call-template name="href.target">
                            <xsl:with-param name="toc-context" select="$toc-context"/>
                        </xsl:call-template>
                    </xsl:attribute>
                    <xsl:copy-of select="$title"/>
                </a>
            </span>
            <span class="{$class.prefix}refpurpose">
                <xsl:if test="$annotate.toc != 0">
                    <!-- * DocBook 5 says inlinemediaobject (among other things) -->
                    <!-- * is allowed in refpurpose; so we need to run -->
                    <!-- * apply-templates on refpurpose here, instead of value-of  -->
                    <xsl:apply-templates select="refnamediv/refpurpose" mode="no.anchor.mode"/>
                </xsl:if>
            </span>
        </xsl:element>
    </xsl:template>
    <xsl:template match="title" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <a>
            <xsl:attribute name="href">
                <xsl:call-template name="href.target">
                    <xsl:with-param name="object" select=".."/>
                    <xsl:with-param name="toc-context" select="$toc-context"/>
                </xsl:call-template>
            </xsl:attribute>
            <xsl:apply-templates/>
        </a>
    </xsl:template>
    <xsl:template name="manual-toc">
        <xsl:param name="toc-context" select="."/>
        <xsl:param name="tocentry"/>
        <xsl:param name="toc.title.p" select="true()"/>
        <xsl:param name="nodes" select="/NOT-AN-ELEMENT"/>

        <!-- be careful, we don't want to change the current document to the other tree! -->

        <xsl:if test="$tocentry">
            <xsl:variable name="node" select="key('id', $tocentry/@linkend)"/>

            <xsl:element name="{$toc.listitem.type}" namespace="http://www.w3.org/1999/xhtml">
                <xsl:variable name="label">
                    <xsl:apply-templates select="$node" mode="label.markup"/>
                </xsl:variable>
                <xsl:copy-of select="$label"/>
                <xsl:if test="$label != ''">
                    <xsl:value-of select="$autotoc.label.separator"/>
                </xsl:if>
                <a>
                    <xsl:attribute name="href">
                        <xsl:call-template name="href.target">
                            <xsl:with-param name="object" select="$node"/>
                            <xsl:with-param name="toc-context" select="$toc-context"/>
                        </xsl:call-template>
                    </xsl:attribute>
                    <xsl:apply-templates select="$node" mode="titleabbrev.markup"/>
                </a>
            </xsl:element>

            <xsl:if test="$tocentry/*">
                <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
                    <xsl:call-template name="toc.list.attributes">
                        <xsl:with-param name="toc-context" select="$toc-context"/>
                        <xsl:with-param name="toc.title.p" select="$toc.title.p"/>
                        <xsl:with-param name="nodes" select="$nodes"/>
                    </xsl:call-template>
                    <xsl:call-template name="manual-toc">
                        <xsl:with-param name="tocentry" select="$tocentry/*[1]"/>
                    </xsl:call-template>
                </xsl:element>
            </xsl:if>

            <xsl:if test="$tocentry/following-sibling::*">
                <xsl:call-template name="manual-toc">
                    <xsl:with-param name="tocentry" select="$tocentry/following-sibling::*[1]"/>
                </xsl:call-template>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    <xsl:template name="list.of.titles">
        <xsl:param name="toc-context" select="."/>
        <xsl:param name="titles" select="'table'"/>
        <xsl:param name="nodes" select=".//table"/>

        <xsl:if test="$nodes">
            <div class="{$class.prefix}list-of-{$titles}s">
                <xsl:choose>
                    <xsl:when test="$make.clean.html != 0">
                        <div class="{$class.prefix}toc-title">
                            <xsl:call-template name="gentext">
                                <xsl:with-param name="key">
                                    <xsl:choose>
                                        <xsl:when test="$titles='table'">ListofTables</xsl:when>
                                        <xsl:when test="$titles='figure'">ListofFigures</xsl:when>
                                        <xsl:when test="$titles='equation'">ListofEquations</xsl:when>
                                        <xsl:when test="$titles='example'">ListofExamples</xsl:when>
                                        <xsl:when test="$titles='procedure'">ListofProcedures</xsl:when>
                                        <xsl:otherwise>ListofUnknown</xsl:otherwise>
                                    </xsl:choose>
                                </xsl:with-param>
                            </xsl:call-template>
                        </div>
                    </xsl:when>
                    <xsl:otherwise>
                        <p>
                            <strong>
                                <xsl:call-template name="gentext">
                                    <xsl:with-param name="key">
                                        <xsl:choose>
                                            <xsl:when test="$titles='table'">ListofTables</xsl:when>
                                            <xsl:when test="$titles='figure'">ListofFigures</xsl:when>
                                            <xsl:when test="$titles='equation'">ListofEquations</xsl:when>
                                            <xsl:when test="$titles='example'">ListofExamples</xsl:when>
                                            <xsl:when test="$titles='procedure'">ListofProcedures</xsl:when>
                                            <xsl:otherwise>ListofUnknown</xsl:otherwise>
                                        </xsl:choose>
                                    </xsl:with-param>
                                </xsl:call-template>
                            </strong>
                        </p>
                    </xsl:otherwise>
                </xsl:choose>

                <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
                    <xsl:apply-templates select="$nodes" mode="toc">
                        <xsl:with-param name="toc-context" select="$toc-context"/>
                    </xsl:apply-templates>
                </xsl:element>
            </div>
        </xsl:if>
    </xsl:template>
    <xsl:template match="figure|table|example|equation|procedure" mode="toc">
        <xsl:param name="toc-context" select="."/>

        <xsl:element name="{$toc.listitem.type}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:variable name="label">
                <xsl:apply-templates select="." mode="label.markup"/>
            </xsl:variable>
            <xsl:copy-of select="$label"/>
            <xsl:if test="$label != ''">
                <xsl:value-of select="$autotoc.label.separator"/>
            </xsl:if>
            <a>
                <xsl:attribute name="href">
                    <xsl:call-template name="href.target">
                        <xsl:with-param name="toc-context" select="$toc-context"/>
                    </xsl:call-template>
                </xsl:attribute>
                <xsl:apply-templates select="." mode="titleabbrev.markup"/>
            </a>
        </xsl:element>
    </xsl:template>
    <xsl:template match="qandaset" mode="toc">
        <xsl:param name="toc-context" select="."/>
        <xsl:call-template name="subtoc">
            <xsl:with-param name="toc-context" select="$toc-context"/>
            <xsl:with-param name="nodes" select="qandadiv | qandaentry"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="qandadiv|qandaentry" mode="toc">
        <xsl:apply-templates select="." mode="qandatoc.mode"/>
    </xsl:template>
    <xsl:variable name="kimber.imported" select="0"/>
    <xsl:variable name="kosek.imported" select="0"/>
    <xsl:key name="letter" match="indexterm"
             use="translate(substring(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 1, 1),'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;','AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
    <xsl:key name="primary" match="indexterm" use="normalize-space(concat(primary/@sortas, &quot; &quot;, primary))"/>
    <xsl:key name="secondary" match="indexterm"
             use="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)))"/>
    <xsl:key name="tertiary" match="indexterm"
             use="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)))"/>
    <xsl:key name="endofrange" match="indexterm[@class='endofrange']" use="@startref"/>
    <xsl:key name="primary-section" match="indexterm[not(secondary) and not(see)]"
             use="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, generate-id((ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()]))"/>
    <xsl:key name="secondary-section" match="indexterm[not(tertiary) and not(see)]"
             use="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, generate-id((ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()]))"/>
    <xsl:key name="tertiary-section" match="indexterm[not(see)]"
             use="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)), &quot; &quot;, generate-id((ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()]))"/>
    <xsl:key name="see-also" match="indexterm[seealso]"
             use="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)), &quot; &quot;, seealso)"/>
    <xsl:key name="see" match="indexterm[see]"
             use="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)), &quot; &quot;, see)"/>
    <xsl:key name="sections" match="*[@id or @xml:id]" use="@id|@xml:id"/>
    <xsl:template name="generate-index">
        <xsl:param name="scope" select="(ancestor::book|/)[last()]"/>

        <xsl:choose>
            <xsl:when test="$index.method = 'kosek'">
                <xsl:call-template name="generate-kosek-index">
                    <xsl:with-param name="scope" select="$scope"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="$index.method = 'kimber'">
                <xsl:call-template name="generate-kimber-index">
                    <xsl:with-param name="scope" select="$scope"/>
                </xsl:call-template>
            </xsl:when>

            <xsl:otherwise>
                <xsl:call-template name="generate-basic-index">
                    <xsl:with-param name="scope" select="$scope"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="generate-basic-index">
        <xsl:param name="scope" select="NOTANODE"/>

        <xsl:variable name="role">
            <xsl:if test="$index.on.role != 0">
                <xsl:value-of select="@role"/>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="type">
            <xsl:if test="$index.on.type != 0">
                <xsl:value-of select="@type"/>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="terms"
                      select="//indexterm                         [count(.|key('letter',                           translate(substring(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 1, 1),                              'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;',                              'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'))                           [count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1                           and not(@class = 'endofrange')]"/>

        <xsl:variable name="alphabetical"
                      select="$terms[contains(concat('Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'),                                         substring(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 1, 1))]"/>

        <xsl:variable name="others"
                      select="$terms[not(contains(concat('Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;',                                                  'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'),                                              substring(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 1, 1)))]"/>
        <div class="{$class.prefix}index">
            <xsl:if test="$others">
                <xsl:choose>
                    <xsl:when
                            test="normalize-space($type) != '' and                          $others[@type = $type][count(.|key('primary', normalize-space(concat(primary/@sortas, &quot; &quot;, primary)))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1]">
                        <div class="{$class.prefix}indexdiv">
                            <h3>
                                <xsl:call-template name="gentext">
                                    <xsl:with-param name="key" select="'index symbols'"/>
                                </xsl:call-template>
                            </h3>
                            <dl>
                                <xsl:apply-templates
                                        select="$others[count(.|key('primary', normalize-space(concat(primary/@sortas, &quot; &quot;, primary)))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1]"
                                        mode="index-symbol-div">
                                    <xsl:with-param name="position" select="position()"/>
                                    <xsl:with-param name="scope" select="$scope"/>
                                    <xsl:with-param name="role" select="$role"/>
                                    <xsl:with-param name="type" select="$type"/>
                                    <xsl:sort
                                            select="translate(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
                                </xsl:apply-templates>
                            </dl>
                        </div>
                    </xsl:when>
                    <xsl:when test="normalize-space($type) != ''">
                        <!-- Output nothing, as there isn't a match for $other using this $type -->
                    </xsl:when>
                    <xsl:otherwise>
                        <div class="{$class.prefix}indexdiv">
                            <h3>
                                <xsl:call-template name="gentext">
                                    <xsl:with-param name="key" select="'index symbols'"/>
                                </xsl:call-template>
                            </h3>
                            <dl>
                                <xsl:apply-templates
                                        select="$others[count(.|key('primary',                                           normalize-space(concat(primary/@sortas, &quot; &quot;, primary)))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1]"
                                        mode="index-symbol-div">
                                    <xsl:with-param name="position" select="position()"/>
                                    <xsl:with-param name="scope" select="$scope"/>
                                    <xsl:with-param name="role" select="$role"/>
                                    <xsl:with-param name="type" select="$type"/>
                                    <xsl:sort
                                            select="translate(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
                                </xsl:apply-templates>
                            </dl>
                        </div>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:if>

            <xsl:apply-templates
                    select="$alphabetical[count(.|key('letter',                                  translate(substring(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 1, 1),                                            'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;','AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1]"
                    mode="index-div-basic">
                <xsl:with-param name="position" select="position()"/>
                <xsl:with-param name="scope" select="$scope"/>
                <xsl:with-param name="role" select="$role"/>
                <xsl:with-param name="type" select="$type"/>
                <xsl:sort
                        select="translate(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
            </xsl:apply-templates>
        </div>
    </xsl:template>
    <xsl:template name="generate-kosek-index">
        <xsl:param name="scope" select="NOTANODE"/>

        <xsl:variable name="vendor" select="system-property('xsl:vendor')"/>
        <xsl:if test="contains($vendor, 'libxslt')">
            <xsl:message terminate="yes">
                <xsl:text>ERROR: the 'kosek' index method does not </xsl:text>
                <xsl:text>work with the xsltproc XSLT processor.</xsl:text>
            </xsl:message>
        </xsl:if>


        <xsl:if test="$exsl.node.set.available = 0">
            <xsl:message terminate="yes">
                <xsl:text>ERROR: the 'kosek' index method requires the </xsl:text>
                <xsl:text>exslt:node-set() function. Use a processor that </xsl:text>
                <xsl:text>has it, or use a different index method.</xsl:text>
            </xsl:message>
        </xsl:if>

        <xsl:if test="$kosek.imported = 0">
            <xsl:message terminate="yes">
      <xsl:text>ERROR: the 'kosek' index method requires the
</xsl:text>
      <xsl:text>kosek index extensions be imported:
</xsl:text>
                <xsl:text>  xsl:import href="html/autoidx-kosek.xsl"</xsl:text>
            </xsl:message>
        </xsl:if>

    </xsl:template>
    <xsl:template name="generate-kimber-index">
        <xsl:param name="scope" select="NOTANODE"/>

        <xsl:variable name="vendor" select="system-property('xsl:vendor')"/>
        <xsl:if test="not(contains($vendor, 'SAXON '))">
            <xsl:message terminate="yes">
                <xsl:text>ERROR: the 'kimber' index method requires the </xsl:text>
                <xsl:text>Saxon version 6 or 8 XSLT processor.</xsl:text>
            </xsl:message>
        </xsl:if>

        <xsl:if test="$kimber.imported = 0">
            <xsl:message terminate="yes">
      <xsl:text>ERROR: the 'kimber' index method requires the
</xsl:text>
      <xsl:text>kimber index extensions be imported:
</xsl:text>
                <xsl:text>  xsl:import href="html/autoidx-kimber.xsl"</xsl:text>
            </xsl:message>
        </xsl:if>

    </xsl:template>
    <xsl:template match="indexterm" mode="index-div-basic">
        <xsl:param name="scope" select="."/>
        <xsl:param name="role" select="''"/>
        <xsl:param name="type" select="''"/>

        <xsl:variable name="key"
                      select="translate(substring(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 1, 1),                          'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;','AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>

        <xsl:if test="key('letter', $key)[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]                 [count(.|key('primary', normalize-space(concat(primary/@sortas, &quot; &quot;, primary)))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1]">
            <div class="{$class.prefix}indexdiv">
                <xsl:if test="contains(concat('Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'), $key)">
                    <h3>
                        <xsl:value-of
                                select="translate($key, 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
                    </h3>
                </xsl:if>
                <dl>
                    <xsl:apply-templates
                            select="key('letter', $key)[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]                                      [count(.|key('primary', normalize-space(concat(primary/@sortas, &quot; &quot;, primary)))                                      [count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])=1]"
                            mode="index-primary">
                        <xsl:with-param name="position" select="position()"/>
                        <xsl:with-param name="scope" select="$scope"/>
                        <xsl:with-param name="role" select="$role"/>
                        <xsl:with-param name="type" select="$type"/>
                        <xsl:sort
                                select="translate(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
                    </xsl:apply-templates>
                </dl>
            </div>
        </xsl:if>
    </xsl:template>
    <xsl:template match="indexterm" mode="index-symbol-div">
        <xsl:param name="scope" select="/"/>
        <xsl:param name="role" select="''"/>
        <xsl:param name="type" select="''"/>

        <xsl:variable name="key"
                      select="translate(substring(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 1, 1),                                              'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;','AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>

        <xsl:apply-templates
                select="key('letter', $key)                                [count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][count(.|key('primary', normalize-space(concat(primary/@sortas, &quot; &quot;, primary)))[1]) = 1]"
                mode="index-primary">
            <xsl:with-param name="position" select="position()"/>
            <xsl:with-param name="scope" select="$scope"/>
            <xsl:with-param name="role" select="$role"/>
            <xsl:with-param name="type" select="$type"/>
            <xsl:sort
                    select="translate(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="indexterm" mode="index-primary">
        <xsl:param name="scope" select="."/>
        <xsl:param name="role" select="''"/>
        <xsl:param name="type" select="''"/>

        <xsl:variable name="key" select="normalize-space(concat(primary/@sortas, &quot; &quot;, primary))"/>
        <xsl:variable name="refs"
                      select="key('primary', $key)[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]"/>
        <dt>
            <xsl:for-each select="$refs/primary">
                <xsl:if test="@id or @xml:id">
                    <xsl:choose>
                        <xsl:when test="$generate.id.attributes = 0">
                            <a id="{(@id|@xml:id)[1]}"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <span>
                                <xsl:call-template name="id.attribute"/>
                            </span>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:if>
            </xsl:for-each>
            <xsl:value-of select="primary"/>
            <xsl:choose>
                <xsl:when test="$index.links.to.section = 1">
                    <xsl:for-each
                            select="$refs[@zone != '' or generate-id() = generate-id(key('primary-section', concat($key, &quot; &quot;, generate-id((ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()])))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]">
                        <xsl:apply-templates select="." mode="reference">
                            <xsl:with-param name="position" select="position()"/>
                            <xsl:with-param name="scope" select="$scope"/>
                            <xsl:with-param name="role" select="$role"/>
                            <xsl:with-param name="type" select="$type"/>
                        </xsl:apply-templates>
                    </xsl:for-each>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:for-each
                            select="$refs[not(see)                                and not(secondary)][count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]">
                        <xsl:apply-templates select="." mode="reference">
                            <xsl:with-param name="position" select="position()"/>
                            <xsl:with-param name="scope" select="$scope"/>
                            <xsl:with-param name="role" select="$role"/>
                            <xsl:with-param name="type" select="$type"/>
                        </xsl:apply-templates>
                    </xsl:for-each>
                </xsl:otherwise>
            </xsl:choose>

            <xsl:if test="$refs[not(secondary)]/*[self::see]">
                <xsl:apply-templates
                        select="$refs[generate-id() = generate-id(key('see', concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, &quot; &quot;, &quot; &quot;, see))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]"
                        mode="index-see">
                    <xsl:with-param name="position" select="position()"/>
                    <xsl:with-param name="scope" select="$scope"/>
                    <xsl:with-param name="role" select="$role"/>
                    <xsl:with-param name="type" select="$type"/>
                    <xsl:sort
                            select="translate(see, 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
                </xsl:apply-templates>
            </xsl:if>
        </dt>
        <xsl:choose>
            <xsl:when test="$refs/secondary or $refs[not(secondary)]/*[self::seealso]">
                <dd>
                    <dl>
                        <xsl:apply-templates
                                select="$refs[generate-id() = generate-id(key('see-also', concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, &quot; &quot;, &quot; &quot;, seealso))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]"
                                mode="index-seealso">
                            <xsl:with-param name="position" select="position()"/>
                            <xsl:with-param name="scope" select="$scope"/>
                            <xsl:with-param name="role" select="$role"/>
                            <xsl:with-param name="type" select="$type"/>
                            <xsl:sort
                                    select="translate(seealso, 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
                        </xsl:apply-templates>
                        <xsl:apply-templates
                                select="$refs[secondary and count(.|key('secondary', concat($key, &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary))))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1]"
                                mode="index-secondary">
                            <xsl:with-param name="position" select="position()"/>
                            <xsl:with-param name="scope" select="$scope"/>
                            <xsl:with-param name="role" select="$role"/>
                            <xsl:with-param name="type" select="$type"/>
                            <xsl:sort
                                    select="translate(normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
                        </xsl:apply-templates>
                    </dl>
                </dd>
            </xsl:when>
            <!-- HTML5 requires dd for each dt -->
            <xsl:when test="$div.element = 'section'">
                <dd/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="indexterm" mode="index-secondary">
        <xsl:param name="scope" select="."/>
        <xsl:param name="role" select="''"/>
        <xsl:param name="type" select="''"/>

        <xsl:variable name="key"
                      select="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)))"/>
        <xsl:variable name="refs"
                      select="key('secondary', $key)[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]"/>
        <dt>
            <xsl:for-each select="$refs/secondary">
                <xsl:if test="@id or @xml:id">
                    <xsl:choose>
                        <xsl:when test="$generate.id.attributes = 0">
                            <a id="{(@id|@xml:id)[1]}"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <span>
                                <xsl:call-template name="id.attribute"/>
                            </span>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:if>
            </xsl:for-each>
            <xsl:value-of select="secondary"/>
            <xsl:choose>
                <xsl:when test="$index.links.to.section = 1">
                    <xsl:for-each
                            select="$refs[@zone != '' or generate-id() = generate-id(key('secondary-section', concat($key, &quot; &quot;, generate-id((ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()])))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]">
                        <xsl:apply-templates select="." mode="reference">
                            <xsl:with-param name="position" select="position()"/>
                            <xsl:with-param name="scope" select="$scope"/>
                            <xsl:with-param name="role" select="$role"/>
                            <xsl:with-param name="type" select="$type"/>
                        </xsl:apply-templates>
                    </xsl:for-each>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:for-each
                            select="$refs[not(see)                                  and not(tertiary)][count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]">
                        <xsl:apply-templates select="." mode="reference">
                            <xsl:with-param name="position" select="position()"/>
                            <xsl:with-param name="scope" select="$scope"/>
                            <xsl:with-param name="role" select="$role"/>
                            <xsl:with-param name="type" select="$type"/>
                        </xsl:apply-templates>
                    </xsl:for-each>
                </xsl:otherwise>
            </xsl:choose>

            <xsl:if test="$refs[not(tertiary)]/*[self::see]">
                <xsl:apply-templates
                        select="$refs[generate-id() = generate-id(key('see', concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, &quot; &quot;, see))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]"
                        mode="index-see">
                    <xsl:with-param name="position" select="position()"/>
                    <xsl:with-param name="scope" select="$scope"/>
                    <xsl:with-param name="role" select="$role"/>
                    <xsl:with-param name="type" select="$type"/>
                    <xsl:sort
                            select="translate(see, 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
                </xsl:apply-templates>
            </xsl:if>
        </dt>
        <xsl:choose>
            <xsl:when test="$refs/tertiary or $refs[not(tertiary)]/*[self::seealso]">
                <dd>
                    <dl>
                        <xsl:apply-templates
                                select="$refs[generate-id() = generate-id(key('see-also', concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, &quot; &quot;, seealso))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]"
                                mode="index-seealso">
                            <xsl:with-param name="position" select="position()"/>
                            <xsl:with-param name="scope" select="$scope"/>
                            <xsl:with-param name="role" select="$role"/>
                            <xsl:with-param name="type" select="$type"/>
                            <xsl:sort
                                    select="translate(seealso, 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
                        </xsl:apply-templates>
                        <xsl:apply-templates
                                select="$refs[tertiary and count(.|key('tertiary', concat($key, &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary))))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]) = 1]"
                                mode="index-tertiary">
                            <xsl:with-param name="position" select="position()"/>
                            <xsl:with-param name="scope" select="$scope"/>
                            <xsl:with-param name="role" select="$role"/>
                            <xsl:with-param name="type" select="$type"/>
                            <xsl:sort
                                    select="translate(normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
                        </xsl:apply-templates>
                    </dl>
                </dd>
            </xsl:when>
            <!-- HTML5 requires dd for each dt -->
            <xsl:when test="$div.element = 'section'">
                <dd/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="indexterm" mode="index-tertiary">
        <xsl:param name="scope" select="."/>
        <xsl:param name="role" select="''"/>
        <xsl:param name="type" select="''"/>

        <xsl:variable name="key"
                      select="concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)))"/>
        <xsl:variable name="refs"
                      select="key('tertiary', $key)[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]"/>
        <dt>
            <xsl:for-each select="$refs/tertiary">
                <xsl:if test="@id or @xml:id">
                    <xsl:choose>
                        <xsl:when test="$generate.id.attributes = 0">
                            <a id="{(@id|@xml:id)[1]}"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <span>
                                <xsl:call-template name="id.attribute"/>
                            </span>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:if>
            </xsl:for-each>
            <xsl:value-of select="tertiary"/>
            <xsl:choose>
                <xsl:when test="$index.links.to.section = 1">
                    <xsl:for-each
                            select="$refs[@zone != '' or generate-id() = generate-id(key('tertiary-section', concat($key, &quot; &quot;, generate-id((ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()])))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]">
                        <xsl:apply-templates select="." mode="reference">
                            <xsl:with-param name="position" select="position()"/>
                            <xsl:with-param name="scope" select="$scope"/>
                            <xsl:with-param name="role" select="$role"/>
                            <xsl:with-param name="type" select="$type"/>
                        </xsl:apply-templates>
                    </xsl:for-each>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:for-each
                            select="$refs[not(see)][count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]">
                        <xsl:apply-templates select="." mode="reference">
                            <xsl:with-param name="position" select="position()"/>
                            <xsl:with-param name="scope" select="$scope"/>
                            <xsl:with-param name="role" select="$role"/>
                            <xsl:with-param name="type" select="$type"/>
                        </xsl:apply-templates>
                    </xsl:for-each>
                </xsl:otherwise>
            </xsl:choose>

            <xsl:if test="$refs/see">
                <xsl:apply-templates
                        select="$refs[generate-id() = generate-id(key('see', concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)), &quot; &quot;, see))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]"
                        mode="index-see">
                    <xsl:with-param name="position" select="position()"/>
                    <xsl:with-param name="scope" select="$scope"/>
                    <xsl:with-param name="role" select="$role"/>
                    <xsl:with-param name="type" select="$type"/>
                    <xsl:sort
                            select="translate(see, 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
                </xsl:apply-templates>
            </xsl:if>
        </dt>
        <xsl:choose>
            <xsl:when test="$refs/seealso">
                <dd>
                    <dl>
                        <xsl:apply-templates
                                select="$refs[generate-id() = generate-id(key('see-also', concat(normalize-space(concat(primary/@sortas, &quot; &quot;, primary)), &quot; &quot;, normalize-space(concat(secondary/@sortas, &quot; &quot;, secondary)), &quot; &quot;, normalize-space(concat(tertiary/@sortas, &quot; &quot;, tertiary)), &quot; &quot;, seealso))[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1])]"
                                mode="index-seealso">
                            <xsl:with-param name="position" select="position()"/>
                            <xsl:with-param name="scope" select="$scope"/>
                            <xsl:with-param name="role" select="$role"/>
                            <xsl:with-param name="type" select="$type"/>
                            <xsl:sort
                                    select="translate(seealso, 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
                        </xsl:apply-templates>
                    </dl>
                </dd>
            </xsl:when>
            <!-- HTML5 requires dd for each dt -->
            <xsl:when test="$div.element = 'section'">
                <dd/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="indexterm" mode="reference">
        <xsl:param name="scope" select="."/>
        <xsl:param name="role" select="''"/>
        <xsl:param name="type" select="''"/>
        <xsl:param name="position"/>
        <xsl:param name="separator" select="''"/>

        <xsl:variable name="term.separator">
            <xsl:call-template name="index.separator">
                <xsl:with-param name="key" select="'index.term.separator'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="number.separator">
            <xsl:call-template name="index.separator">
                <xsl:with-param name="key" select="'index.number.separator'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="range.separator">
            <xsl:call-template name="index.separator">
                <xsl:with-param name="key" select="'index.range.separator'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$separator != ''">
                <xsl:value-of select="$separator"/>
            </xsl:when>
            <xsl:when test="$position = 1">
                <xsl:value-of select="$term.separator"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$number.separator"/>
            </xsl:otherwise>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="@zone and string(@zone)">
                <xsl:call-template name="reference">
                    <xsl:with-param name="zones" select="normalize-space(@zone)"/>
                    <xsl:with-param name="position" select="position()"/>
                    <xsl:with-param name="scope" select="$scope"/>
                    <xsl:with-param name="role" select="$role"/>
                    <xsl:with-param name="type" select="$type"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <a>
                    <xsl:apply-templates select="." mode="class.attribute"/>
                    <xsl:variable name="title">
                        <xsl:choose>
                            <xsl:when test="$index.prefer.titleabbrev != 0">
                                <xsl:apply-templates
                                        select="(ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()]"
                                        mode="titleabbrev.markup"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:apply-templates
                                        select="(ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()]"
                                        mode="title.markup"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>

                    <xsl:attribute name="href">
                        <xsl:choose>
                            <xsl:when test="$index.links.to.section = 1">
                                <xsl:call-template name="href.target">
                                    <xsl:with-param name="object"
                                                    select="(ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()]"/>
                                    <xsl:with-param name="context"
                                                    select="(//index[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))] | //setindex[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))])[1]"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:call-template name="href.target">
                                    <xsl:with-param name="object" select="."/>
                                    <xsl:with-param name="context"
                                                    select="(//index[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))] | //setindex[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))])[1]"/>
                                </xsl:call-template>
                            </xsl:otherwise>
                        </xsl:choose>

                    </xsl:attribute>

                    <xsl:value-of select="$title"/>
                    <!-- text only -->
                </a>

                <xsl:variable name="id" select="(@id|@xml:id)[1]"/>
                <xsl:if test="key('endofrange', $id)[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))]">
                    <xsl:apply-templates
                            select="key('endofrange', $id)[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][last()]"
                            mode="reference">
                        <xsl:with-param name="position" select="position()"/>
                        <xsl:with-param name="scope" select="$scope"/>
                        <xsl:with-param name="role" select="$role"/>
                        <xsl:with-param name="type" select="$type"/>
                        <xsl:with-param name="separator" select="$range.separator"/>
                    </xsl:apply-templates>
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="reference">
        <xsl:param name="scope" select="."/>
        <xsl:param name="role" select="''"/>
        <xsl:param name="type" select="''"/>
        <xsl:param name="zones"/>

        <xsl:choose>
            <xsl:when test="contains($zones, ' ')">
                <xsl:variable name="zone" select="substring-before($zones, ' ')"/>
                <xsl:variable name="target" select="key('sections', $zone)"/>

                <a>
                    <xsl:apply-templates select="." mode="class.attribute"/>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:attribute name="href">
                        <xsl:call-template name="href.target">
                            <xsl:with-param name="object" select="$target[1]"/>
                            <xsl:with-param name="context"
                                            select="//index[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]"/>
                        </xsl:call-template>
                    </xsl:attribute>
                    <xsl:apply-templates select="$target[1]" mode="index-title-content"/>
                </a>
                <xsl:text>, </xsl:text>
                <xsl:call-template name="reference">
                    <xsl:with-param name="zones" select="substring-after($zones, ' ')"/>
                    <xsl:with-param name="position" select="position()"/>
                    <xsl:with-param name="scope" select="$scope"/>
                    <xsl:with-param name="role" select="$role"/>
                    <xsl:with-param name="type" select="$type"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="zone" select="$zones"/>
                <xsl:variable name="target" select="key('sections', $zone)"/>

                <a>
                    <xsl:apply-templates select="." mode="class.attribute"/>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:attribute name="href">
                        <xsl:call-template name="href.target">
                            <xsl:with-param name="object" select="$target[1]"/>
                            <xsl:with-param name="context"
                                            select="//index[count(ancestor::node()|$scope) = count(ancestor::node()) and ($role = @role or $type = @type or (string-length($role) = 0 and string-length($type) = 0))][1]"/>
                        </xsl:call-template>
                    </xsl:attribute>
                    <xsl:apply-templates select="$target[1]" mode="index-title-content"/>
                </a>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="indexterm" mode="index-see">
        <xsl:param name="scope" select="."/>
        <xsl:param name="role" select="''"/>
        <xsl:param name="type" select="''"/>

        <xsl:text> (</xsl:text>
        <xsl:call-template name="gentext">
            <xsl:with-param name="key" select="'see'"/>
        </xsl:call-template>
        <xsl:text> </xsl:text>
        <xsl:value-of select="see"/>
        <xsl:text>)</xsl:text>
    </xsl:template>
    <xsl:template match="indexterm" mode="index-seealso">
        <xsl:param name="scope" select="."/>
        <xsl:param name="role" select="''"/>
        <xsl:param name="type" select="''"/>

        <xsl:for-each select="seealso">
            <xsl:sort
                    select="translate(., 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ')"/>
            <dt>
                <xsl:text>(</xsl:text>
                <xsl:call-template name="gentext">
                    <xsl:with-param name="key" select="'seealso'"/>
                </xsl:call-template>
                <xsl:text> </xsl:text>
                <xsl:value-of select="."/>
                <xsl:text>)</xsl:text>
            </dt>
            <xsl:if test="$div.element = 'section'">
                <dd/>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
    <xsl:template match="*" mode="index-title-content">
        <xsl:variable name="title">
            <xsl:apply-templates
                    select="(ancestor-or-self::set|ancestor-or-self::book|ancestor-or-self::part|ancestor-or-self::reference|ancestor-or-self::partintro|ancestor-or-self::chapter|ancestor-or-self::appendix|ancestor-or-self::preface|ancestor-or-self::article|ancestor-or-self::section|ancestor-or-self::sect1|ancestor-or-self::sect2|ancestor-or-self::sect3|ancestor-or-self::sect4|ancestor-or-self::sect5|ancestor-or-self::refentry|ancestor-or-self::refsect1|ancestor-or-self::refsect2|ancestor-or-self::refsect3|ancestor-or-self::simplesect|ancestor-or-self::bibliography|ancestor-or-self::glossary|ancestor-or-self::index|ancestor-or-self::webpage|ancestor-or-self::topic)[last()]"
                    mode="title.markup"/>
        </xsl:variable>

        <xsl:value-of select="$title"/>
    </xsl:template>
    <xsl:template name="index.separator">
        <xsl:param name="key" select="''"/>
        <xsl:param name="lang">
            <xsl:call-template name="l10n.language"/>
        </xsl:param>

        <xsl:choose>
            <xsl:when test="$key = 'index.term.separator'">
                <xsl:choose>
                    <!-- Use the override if not blank -->
                    <xsl:when test="$index.term.separator != ''">
                        <xsl:copy-of select="$index.term.separator"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="lang" select="$lang"/>
                            <xsl:with-param name="context">index</xsl:with-param>
                            <xsl:with-param name="name">term-separator</xsl:with-param>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="$key = 'index.number.separator'">
                <xsl:choose>
                    <!-- Use the override if not blank -->
                    <xsl:when test="$index.number.separator != ''">
                        <xsl:copy-of select="$index.number.separator"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="lang" select="$lang"/>
                            <xsl:with-param name="context">index</xsl:with-param>
                            <xsl:with-param name="name">number-separator</xsl:with-param>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="$key = 'index.range.separator'">
                <xsl:choose>
                    <!-- Use the override if not blank -->
                    <xsl:when test="$index.range.separator != ''">
                        <xsl:copy-of select="$index.range.separator"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="lang" select="$lang"/>
                            <xsl:with-param name="context">index</xsl:with-param>
                            <xsl:with-param name="name">range-separator</xsl:with-param>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="itemizedlist/title">
        <!-- nop -->
    </xsl:template>
    <xsl:template match="itemizedlist/listitem">
        <xsl:variable name="mark" select="../@mark"/>
        <xsl:variable name="override" select="@override"/>

        <xsl:variable name="usemark">
            <xsl:choose>
                <xsl:when test="$override != ''">
                    <xsl:value-of select="$override"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$mark"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="cssmark">
            <xsl:choose>
                <xsl:when test="$usemark = 'opencircle'">circle</xsl:when>
                <xsl:when test="$usemark = 'bullet'">disc</xsl:when>
                <xsl:when test="$usemark = 'box'">square</xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$usemark"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <li>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:if test="$css.decoration = '1' and $cssmark != ''">
                <xsl:attribute name="style">
                    <xsl:text>list-style-type: </xsl:text>
                    <xsl:value-of select="$cssmark"/>
                </xsl:attribute>
            </xsl:if>

            <!-- we can't just drop the anchor in since some browsers (Opera)
         get confused about line breaks if we do. So if the first child
         is a para, assume the para will put in the anchor. Otherwise,
         put the anchor in anyway. -->
            <xsl:if test="local-name(child::*[1]) != 'para'">
                <xsl:call-template name="anchor"/>
            </xsl:if>

            <xsl:choose>
                <xsl:when test="$show.revisionflag != 0 and @revisionflag">
                    <div class="{$class.prefix}{@revisionflag}">
                        <xsl:apply-templates/>
                    </div>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates/>
                </xsl:otherwise>
            </xsl:choose>
        </li>
    </xsl:template>
    <xsl:template match="orderedlist/title">
        <!-- nop -->
    </xsl:template>
    <xsl:template match="orderedlist/listitem">
        <li>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:if test="@override">
                <xsl:attribute name="value">
                    <xsl:value-of select="@override"/>
                </xsl:attribute>
            </xsl:if>

            <!-- we can't just drop the anchor in since some browsers (Opera)
         get confused about line breaks if we do. So if the first child
         is a para, assume the para will put in the anchor. Otherwise,
         put the anchor in anyway. -->
            <xsl:if test="local-name(child::*[1]) != 'para'">
                <xsl:call-template name="anchor"/>
            </xsl:if>

            <xsl:choose>
                <xsl:when test="$show.revisionflag != 0 and @revisionflag">
                    <div class="{$class.prefix}{@revisionflag}">
                        <xsl:apply-templates/>
                    </div>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates/>
                </xsl:otherwise>
            </xsl:choose>
        </li>
    </xsl:template>
    <xsl:template match="orderedlist/listitem" mode="orderedlist-table">
        <tr>
            <td>
                <xsl:apply-templates select="." mode="item-number"/>
            </td>
            <td>
                <xsl:if test="local-name(child::*[1]) != 'para'">
                    <xsl:call-template name="id.attribute"/>
                    <xsl:call-template name="anchor"/>
                </xsl:if>

                <xsl:choose>
                    <xsl:when test="$show.revisionflag != 0 and @revisionflag">
                        <div class="{$class.prefix}{@revisionflag}">
                            <xsl:apply-templates/>
                        </div>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates/>
                    </xsl:otherwise>
                </xsl:choose>
            </td>
        </tr>
    </xsl:template>
    <xsl:template match="variablelist">
        <xsl:variable name="pi-presentation">
            <xsl:call-template name="pi.dbhtml_list-presentation"/>
        </xsl:variable>
        <!-- Handle spacing="compact" as multiple class attribute instead
       of the deprecated HTML compact attribute -->
        <xsl:variable name="default.class">
            <xsl:value-of select="local-name()"/>
            <xsl:if test="@spacing = 'compact'">
                <xsl:text> compact</xsl:text>
            </xsl:if>
        </xsl:variable>


        <xsl:variable name="presentation">
            <xsl:choose>
                <xsl:when test="$pi-presentation != ''">
                    <xsl:value-of select="$pi-presentation"/>
                </xsl:when>
                <xsl:when test="$variablelist.as.table != 0">
                    <xsl:value-of select="'table'"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="'list'"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="list-width">
            <xsl:call-template name="pi.dbhtml_list-width"/>
        </xsl:variable>

        <xsl:variable name="term-width">
            <xsl:call-template name="pi.dbhtml_term-width"/>
        </xsl:variable>

        <xsl:variable name="table-summary">
            <xsl:call-template name="pi.dbhtml_table-summary"/>
        </xsl:variable>

        <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:if test="title|info/title">
                <xsl:call-template name="formal.object.heading"/>
            </xsl:if>

            <xsl:choose>
                <xsl:when test="$presentation = 'table'">
                    <!-- Preserve order of PIs and comments -->
                    <xsl:apply-templates
                            select="*[not(self::varlistentry                     or self::title                     or self::titleabbrev)]                   |comment()[not(preceding-sibling::varlistentry)]                   |processing-instruction()[not(preceding-sibling::varlistentry)]"/>
                    <table border="{$table.border.off}">
                        <xsl:call-template name="generate.class.attribute">
                            <xsl:with-param name="class" select="$default.class"/>
                        </xsl:call-template>
                        <xsl:if test="$list-width != ''">
                            <xsl:attribute name="width">
                                <xsl:value-of select="$list-width"/>
                            </xsl:attribute>
                        </xsl:if>
                        <xsl:if test="$table-summary != ''">
                            <xsl:attribute name="summary">
                                <xsl:value-of select="$table-summary"/>
                            </xsl:attribute>
                        </xsl:if>
                        <colgroup>
                            <col align="{$direction.align.start}" valign="top">
                                <xsl:if test="$term-width != ''">
                                    <xsl:attribute name="width">
                                        <xsl:value-of select="$term-width"/>
                                    </xsl:attribute>
                                </xsl:if>
                            </col>
                            <col/>
                        </colgroup>
                        <tbody>
                            <xsl:apply-templates mode="varlist-table"
                                                 select="varlistentry                       |comment()[preceding-sibling::varlistentry]                       |processing-instruction()[preceding-sibling::varlistentry]"/>
                        </tbody>
                    </table>
                </xsl:when>
                <xsl:otherwise>
                    <!-- Preserve order of PIs and comments -->
                    <xsl:apply-templates
                            select="*[not(self::varlistentry                     or self::title                     or self::titleabbrev)]                   |comment()[not(preceding-sibling::varlistentry)]                   |processing-instruction()[not(preceding-sibling::varlistentry)]"/>
                    <dl>
                        <xsl:call-template name="generate.class.attribute">
                            <xsl:with-param name="class" select="$default.class"/>
                        </xsl:call-template>
                        <xsl:apply-templates
                                select="varlistentry                       |comment()[preceding-sibling::varlistentry]                       |processing-instruction()[preceding-sibling::varlistentry]"/>
                    </dl>
                </xsl:otherwise>
            </xsl:choose>
        </div>
    </xsl:template>
    <xsl:template match="variablelist/title">
        <!-- nop -->
    </xsl:template>
    <xsl:template match="itemizedlist/titleabbrev|orderedlist/titleabbrev">
        <!--nop-->
    </xsl:template>
    <xsl:template match="variablelist/titleabbrev">
        <!--nop-->
    </xsl:template>
    <xsl:template match="listitem" mode="xref">
        <xsl:number format="1"/>
    </xsl:template>
    <xsl:template match="listitem/simpara" priority="2">
        <!-- If a listitem contains only a single simpara, don't output
       the <p> wrapper; this has the effect of creating an li
       with simple text content. -->
        <xsl:choose>
            <xsl:when test="not(preceding-sibling::*)                     and not (following-sibling::*)">
                <xsl:call-template name="anchor"/>
                <xsl:apply-templates/>
            </xsl:when>
            <xsl:otherwise>
                <p>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:choose>
                        <xsl:when test="@role and $para.propagates.style != 0">
                            <xsl:call-template name="common.html.attributes">
                                <xsl:with-param name="class" select="@role"/>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:call-template name="common.html.attributes"/>
                        </xsl:otherwise>
                    </xsl:choose>

                    <xsl:call-template name="anchor"/>
                    <xsl:apply-templates/>
                </p>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="varlistentry">
        <dt>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:apply-templates select="term"/>
        </dt>
        <dd>
            <xsl:apply-templates select="listitem"/>
        </dd>
    </xsl:template>
    <xsl:template match="varlistentry" mode="varlist-table">
        <xsl:variable name="presentation">
            <xsl:call-template name="pi.dbhtml_term-presentation">
                <xsl:with-param name="node" select=".."/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="separator">
            <xsl:call-template name="pi.dbhtml_term-separator">
                <xsl:with-param name="node" select=".."/>
            </xsl:call-template>
        </xsl:variable>
        <tr>
            <xsl:call-template name="tr.attributes">
                <xsl:with-param name="rownum">
                    <xsl:number from="variablelist" count="varlistentry"/>
                </xsl:with-param>
            </xsl:call-template>

            <td>
                <xsl:call-template name="id.attribute"/>
                <p>
                    <xsl:call-template name="anchor"/>
                    <xsl:choose>
                        <xsl:when test="$presentation = 'bold'">
                            <strong>
                                <xsl:apply-templates select="term"/>
                                <xsl:value-of select="$separator"/>
                            </strong>
                        </xsl:when>
                        <xsl:when test="$presentation = 'italic'">
                            <em>
                                <xsl:apply-templates select="term"/>
                                <xsl:value-of select="$separator"/>
                            </em>
                        </xsl:when>
                        <xsl:when test="$presentation = 'bold-italic'">
                            <strong>
                                <em>
                                    <xsl:apply-templates select="term"/>
                                    <xsl:value-of select="$separator"/>
                                </em>
                            </strong>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:apply-templates select="term"/>
                            <xsl:value-of select="$separator"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </p>
            </td>
            <td>
                <xsl:apply-templates select="listitem"/>
            </td>
        </tr>
    </xsl:template>
    <xsl:template match="varlistentry/term">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:apply-templates/>
                </xsl:with-param>
            </xsl:call-template>
            <xsl:choose>
                <xsl:when test="position() = last()"/>
                <!-- do nothing -->
                <xsl:otherwise>
                    <!-- * if we have multiple terms in the same varlistentry, generate -->
                    <!-- * a separator (", " by default) and/or an additional line -->
                    <!-- * break after each one except the last -->
                    <xsl:value-of select="$variablelist.term.separator"/>
                    <xsl:if test="not($variablelist.term.break.after = '0')">
                        <br/>
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
        </span>
    </xsl:template>
    <xsl:template match="varlistentry/listitem">
        <!-- we can't just drop the anchor in since some browsers (Opera)
       get confused about line breaks if we do. So if the first child
       is a para, assume the para will put in the anchor. Otherwise,
       put the anchor in anyway. -->
        <xsl:if test="local-name(child::*[1]) != 'para'">
            <xsl:call-template name="anchor"/>
        </xsl:if>

        <xsl:choose>
            <xsl:when test="$show.revisionflag != 0 and @revisionflag">
                <div class="{$class.prefix}{@revisionflag}">
                    <xsl:apply-templates/>
                </div>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="simplelist">
        <!-- with no type specified, the default is 'vert' -->
        <xsl:call-template name="anchor"/>
        <table border="{$table.border.off}">
            <xsl:if test="$div.element != 'section'">
                <xsl:attribute name="summary">Simple list</xsl:attribute>
            </xsl:if>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="simplelist.vert">
                <xsl:with-param name="cols">
                    <xsl:choose>
                        <xsl:when test="@columns">
                            <xsl:value-of select="@columns"/>
                        </xsl:when>
                        <xsl:otherwise>1</xsl:otherwise>
                    </xsl:choose>
                </xsl:with-param>
            </xsl:call-template>
        </table>
    </xsl:template>
    <xsl:template match="simplelist[@type='inline']">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <!-- if dbchoice PI exists, use that to determine the choice separator -->
            <!-- (that is, equivalent of "and" or "or" in current locale), or literal -->
            <!-- value of "choice" otherwise -->
            <xsl:variable name="localized-choice-separator">
                <xsl:choose>
                    <xsl:when test="processing-instruction('dbchoice')">
                        <xsl:call-template name="select.choice.separator"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <!-- empty -->
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>

            <xsl:for-each select="member">
                <xsl:call-template name="simple.xlink">
                    <xsl:with-param name="content">
                        <xsl:apply-templates/>
                    </xsl:with-param>
                </xsl:call-template>
                <xsl:choose>
                    <xsl:when test="position() = last()"/>
                    <!-- do nothing -->
                    <xsl:otherwise>
                        <xsl:text>, </xsl:text>
                        <xsl:if test="position() = last() - 1">
                            <xsl:if test="$localized-choice-separator != ''">
                                <xsl:value-of select="$localized-choice-separator"/>
                                <xsl:text> </xsl:text>
                            </xsl:if>
                        </xsl:if>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:for-each>
        </span>
    </xsl:template>
    <xsl:template match="simplelist[@type='horiz']">
        <xsl:call-template name="anchor"/>
        <table border="{$table.border.off}">
            <xsl:if test="$div.element != 'section'">
                <xsl:attribute name="summary">Simple list</xsl:attribute>
            </xsl:if>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="simplelist.horiz">
                <xsl:with-param name="cols">
                    <xsl:choose>
                        <xsl:when test="@columns">
                            <xsl:value-of select="@columns"/>
                        </xsl:when>
                        <xsl:otherwise>1</xsl:otherwise>
                    </xsl:choose>
                </xsl:with-param>
            </xsl:call-template>
        </table>
    </xsl:template>
    <xsl:template match="simplelist[@type='vert']">
        <xsl:call-template name="anchor"/>
        <table border="{$table.border.off}">
            <xsl:if test="$div.element != 'section'">
                <xsl:attribute name="summary">Simple list</xsl:attribute>
            </xsl:if>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="simplelist.vert">
                <xsl:with-param name="cols">
                    <xsl:choose>
                        <xsl:when test="@columns">
                            <xsl:value-of select="@columns"/>
                        </xsl:when>
                        <xsl:otherwise>1</xsl:otherwise>
                    </xsl:choose>
                </xsl:with-param>
            </xsl:call-template>
        </table>
    </xsl:template>
    <xsl:template name="simplelist.horiz">
        <xsl:param name="cols">1</xsl:param>
        <xsl:param name="cell">1</xsl:param>
        <xsl:param name="members" select="./member"/>

        <xsl:if test="$cell &lt;= count($members)">
            <tr>
                <xsl:call-template name="tr.attributes">
                    <xsl:with-param name="row" select="$members[1]"/>
                    <xsl:with-param name="rownum" select="(($cell - 1) div $cols) + 1"/>
                </xsl:call-template>

                <xsl:call-template name="simplelist.horiz.row">
                    <xsl:with-param name="cols" select="$cols"/>
                    <xsl:with-param name="cell" select="$cell"/>
                    <xsl:with-param name="members" select="$members"/>
                </xsl:call-template>
            </tr>
            <xsl:call-template name="simplelist.horiz">
                <xsl:with-param name="cols" select="$cols"/>
                <xsl:with-param name="cell" select="$cell + $cols"/>
                <xsl:with-param name="members" select="$members"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template name="simplelist.horiz.row">
        <xsl:param name="cols">1</xsl:param>
        <xsl:param name="cell">1</xsl:param>
        <xsl:param name="members" select="./member"/>
        <xsl:param name="curcol">1</xsl:param>

        <xsl:if test="$curcol &lt;= $cols">
            <td>
                <xsl:choose>
                    <xsl:when test="$members[position()=$cell]">
                        <xsl:apply-templates select="$members[position()=$cell]"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text> </xsl:text>
                    </xsl:otherwise>
                </xsl:choose>
            </td>
            <xsl:call-template name="simplelist.horiz.row">
                <xsl:with-param name="cols" select="$cols"/>
                <xsl:with-param name="cell" select="$cell+1"/>
                <xsl:with-param name="members" select="$members"/>
                <xsl:with-param name="curcol" select="$curcol+1"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template name="simplelist.vert">
        <xsl:param name="cols">1</xsl:param>
        <xsl:param name="cell">1</xsl:param>
        <xsl:param name="members" select="./member"/>
        <xsl:param name="rows" select="floor((count($members)+$cols - 1) div $cols)"/>

        <xsl:if test="$cell &lt;= $rows">
            <tr>
                <xsl:call-template name="tr.attributes">
                    <xsl:with-param name="row" select="$members[1]"/>
                    <xsl:with-param name="rownum" select="$cell"/>
                </xsl:call-template>

                <xsl:call-template name="simplelist.vert.row">
                    <xsl:with-param name="cols" select="$cols"/>
                    <xsl:with-param name="rows" select="$rows"/>
                    <xsl:with-param name="cell" select="$cell"/>
                    <xsl:with-param name="members" select="$members"/>
                </xsl:call-template>
            </tr>
            <xsl:call-template name="simplelist.vert">
                <xsl:with-param name="cols" select="$cols"/>
                <xsl:with-param name="cell" select="$cell+1"/>
                <xsl:with-param name="members" select="$members"/>
                <xsl:with-param name="rows" select="$rows"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template name="simplelist.vert.row">
        <xsl:param name="cols">1</xsl:param>
        <xsl:param name="rows">1</xsl:param>
        <xsl:param name="cell">1</xsl:param>
        <xsl:param name="members" select="./member"/>
        <xsl:param name="curcol">1</xsl:param>

        <xsl:if test="$curcol &lt;= $cols">
            <td>
                <xsl:choose>
                    <xsl:when test="$members[position()=$cell]">
                        <xsl:apply-templates select="$members[position()=$cell]"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text> </xsl:text>
                    </xsl:otherwise>
                </xsl:choose>
            </td>
            <xsl:call-template name="simplelist.vert.row">
                <xsl:with-param name="cols" select="$cols"/>
                <xsl:with-param name="rows" select="$rows"/>
                <xsl:with-param name="cell" select="$cell+$rows"/>
                <xsl:with-param name="members" select="$members"/>
                <xsl:with-param name="curcol" select="$curcol+1"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template match="member">
        <xsl:call-template name="anchor"/>
        <xsl:call-template name="simple.xlink">
            <xsl:with-param name="content">
                <xsl:apply-templates/>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="procedure/title">
        <!-- nop -->
    </xsl:template>
    <xsl:template match="step">
        <li>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:apply-templates/>
        </li>
    </xsl:template>
    <xsl:template match="stepalternatives">
        <xsl:call-template name="anchor"/>
        <ul>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates/>
        </ul>
    </xsl:template>
    <xsl:template match="step/title">
        <p>
            <xsl:call-template name="common.html.attributes"/>
            <strong>
                <xsl:apply-templates/>
            </strong>
        </p>
    </xsl:template>
    <xsl:template match="segmentedlist">
        <xsl:variable name="presentation">
            <xsl:call-template name="pi.dbhtml_list-presentation"/>
        </xsl:variable>

        <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>

            <xsl:choose>
                <xsl:when test="$presentation = 'table'">
                    <xsl:apply-templates select="." mode="seglist-table"/>
                </xsl:when>
                <xsl:when test="$presentation = 'list'">
                    <xsl:apply-templates/>
                </xsl:when>
                <xsl:when test="$segmentedlist.as.table != 0">
                    <xsl:apply-templates select="." mode="seglist-table"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates/>
                </xsl:otherwise>
            </xsl:choose>
        </div>
    </xsl:template>
    <xsl:template match="segmentedlist/title">
        <div>
            <xsl:call-template name="common.html.attributes"/>
            <strong>
                <span>
                    <xsl:call-template name="generate.class.attribute"/>
                    <xsl:apply-templates/>
                </span>
            </strong>
        </div>
    </xsl:template>
    <xsl:template match="segtitle">
    </xsl:template>
    <xsl:template match="segtitle" mode="segtitle-in-seg">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="seglistitem">
        <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="seg">
        <xsl:variable name="segnum" select="count(preceding-sibling::seg)+1"/>
        <xsl:variable name="seglist" select="ancestor::segmentedlist"/>
        <xsl:variable name="segtitles" select="$seglist/segtitle"/>

        <!--
     Note: segtitle is only going to be the right thing in a well formed
     SegmentedList.  If there are too many Segs or too few SegTitles,
     you'll get something odd...maybe an error
  -->

        <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <strong>
                <span class="{$class.prefix}segtitle">
                    <xsl:apply-templates select="$segtitles[$segnum=position()]" mode="segtitle-in-seg"/>
                    <xsl:text>: </xsl:text>
                </span>
            </strong>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="segmentedlist" mode="seglist-table">
        <xsl:variable name="table-summary">
            <xsl:call-template name="pi.dbhtml_table-summary"/>
        </xsl:variable>

        <xsl:variable name="list-width">
            <xsl:call-template name="pi.dbhtml_list-width"/>
        </xsl:variable>

        <xsl:apply-templates select="title"/>

        <table border="{$table.border.off}">
            <xsl:if test="$list-width != ''">
                <xsl:attribute name="width">
                    <xsl:value-of select="$list-width"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="$table-summary != '' and $div.element != 'section'">
                <xsl:attribute name="summary">
                    <xsl:value-of select="$table-summary"/>
                </xsl:attribute>
            </xsl:if>
            <thead>
                <tr class="{$class.prefix}segtitle">
                    <xsl:call-template name="tr.attributes">
                        <xsl:with-param name="row" select="segtitle[1]"/>
                        <xsl:with-param name="rownum" select="1"/>
                    </xsl:call-template>
                    <xsl:apply-templates select="segtitle" mode="seglist-table"/>
                </tr>
            </thead>
            <tbody>
                <xsl:apply-templates select="seglistitem" mode="seglist-table"/>
            </tbody>
        </table>
    </xsl:template>
    <xsl:template match="segtitle" mode="seglist-table">
        <th>
            <xsl:apply-templates/>
        </th>
    </xsl:template>
    <xsl:template match="seglistitem" mode="seglist-table">
        <xsl:variable name="seglinum">
            <xsl:number from="segmentedlist" count="seglistitem"/>
        </xsl:variable>

        <tr>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="tr.attributes">
                <xsl:with-param name="rownum" select="$seglinum + 1"/>
            </xsl:call-template>
            <xsl:apply-templates mode="seglist-table"/>
        </tr>
    </xsl:template>
    <xsl:template match="seg" mode="seglist-table">
        <td>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates/>
        </td>
    </xsl:template>
    <xsl:template match="seg[1]" mode="seglist-table">
        <td>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor">
                <xsl:with-param name="node" select="ancestor::seglistitem"/>
            </xsl:call-template>
            <xsl:apply-templates/>
        </td>
    </xsl:template>
    <xsl:template match="calloutlist">
        <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:if test="title|info/title">
                <xsl:call-template name="formal.object.heading"/>
            </xsl:if>

            <!-- Preserve order of PIs and comments -->
            <xsl:apply-templates
                    select="*[not(self::callout or self::title or self::titleabbrev)]                    |comment()[not(preceding-sibling::callout)]                    |processing-instruction()[not(preceding-sibling::callout)]"/>

            <xsl:choose>
                <xsl:when test="$callout.list.table != 0">
                    <table border="{$table.border.off}">
                        <xsl:if test="$div.element != 'section'">
                            <xsl:attribute name="summary">Callout list</xsl:attribute>
                        </xsl:if>
                        <xsl:apply-templates
                                select="callout                                 |comment()[preceding-sibling::callout]                                 |processing-instruction()[preceding-sibling::callout]"/>
                    </table>
                </xsl:when>
                <xsl:otherwise>
                    <dl>
                        <xsl:apply-templates select="." mode="class.attribute"/>
                        <xsl:apply-templates
                                select="callout                                 |comment()[preceding-sibling::callout]                                 |processing-instruction()[preceding-sibling::callout]"/>
                    </dl>
                </xsl:otherwise>
            </xsl:choose>
        </div>
    </xsl:template>
    <xsl:template match="calloutlist/title">
    </xsl:template>
    <xsl:template match="callout">
        <xsl:choose>
            <xsl:when test="$callout.list.table != 0">
                <tr>
                    <xsl:call-template name="tr.attributes">
                        <xsl:with-param name="rownum">
                            <xsl:number from="calloutlist" count="callout"/>
                        </xsl:with-param>
                    </xsl:call-template>

                    <td width="5%" valign="top" align="{$direction.align.start}">
                        <xsl:call-template name="id.attribute"/>
                        <p>
                            <xsl:call-template name="anchor"/>
                            <xsl:call-template name="callout.arearefs">
                                <xsl:with-param name="arearefs" select="@arearefs"/>
                            </xsl:call-template>
                        </p>
                    </td>
                    <td valign="top" align="{$direction.align.start}">
                        <xsl:apply-templates/>
                    </td>
                </tr>
            </xsl:when>
            <xsl:otherwise>
                <dt>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:call-template name="anchor"/>
                    <xsl:call-template name="callout.arearefs">
                        <xsl:with-param name="arearefs" select="@arearefs"/>
                    </xsl:call-template>
                </dt>
                <dd>
                    <xsl:apply-templates/>
                </dd>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="callout/simpara" priority="2">
        <!-- If a callout contains only a single simpara, don't output
       the <p> wrapper; this has the effect of creating an li
       with simple text content. -->
        <xsl:choose>
            <xsl:when test="not(preceding-sibling::*)                     and not (following-sibling::*)">
                <xsl:call-template name="anchor"/>
                <xsl:apply-templates/>
            </xsl:when>
            <xsl:otherwise>
                <p>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:if test="@role and $para.propagates.style != 0">
                        <xsl:choose>
                            <xsl:when test="@role and $para.propagates.style != 0">
                                <xsl:call-template name="common.html.attributes">
                                    <xsl:with-param name="class" select="@role"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:call-template name="common.html.attributes"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:if>

                    <xsl:call-template name="anchor"/>
                    <xsl:apply-templates/>
                </p>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="callout.arearefs">
        <xsl:param name="arearefs"/>
        <xsl:if test="$arearefs!=''">
            <xsl:choose>
                <xsl:when test="substring-before($arearefs,' ')=''">
                    <xsl:call-template name="callout.arearef">
                        <xsl:with-param name="arearef" select="$arearefs"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="callout.arearef">
                        <xsl:with-param name="arearef" select="substring-before($arearefs,' ')"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:call-template name="callout.arearefs">
                <xsl:with-param name="arearefs" select="substring-after($arearefs,' ')"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template name="callout.arearef">
        <xsl:param name="arearef"/>
        <xsl:variable name="targets" select="key('id',$arearef)"/>
        <xsl:variable name="target" select="$targets[1]"/>

        <xsl:call-template name="check.id.unique">
            <xsl:with-param name="linkend" select="$arearef"/>
        </xsl:call-template>

        <xsl:choose>
            <xsl:when test="count($target)=0">
                <xsl:text>???</xsl:text>
            </xsl:when>
            <xsl:when test="local-name($target)='co'">
                <a>
                    <xsl:attribute name="href">
                        <xsl:text>#</xsl:text>
                        <xsl:value-of select="$arearef"/>
                    </xsl:attribute>
                    <xsl:apply-templates select="$target" mode="callout-bug"/>
                </a>
                <xsl:text> </xsl:text>
            </xsl:when>
            <xsl:when test="local-name($target)='areaset'">
                <xsl:call-template name="callout-bug">
                    <xsl:with-param name="conum">
                        <xsl:apply-templates select="$target" mode="conumber"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="local-name($target)='area'">
                <xsl:choose>
                    <xsl:when test="$target/parent::areaset">
                        <xsl:call-template name="callout-bug">
                            <xsl:with-param name="conum">
                                <xsl:apply-templates select="$target/parent::areaset" mode="conumber"/>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="callout-bug">
                            <xsl:with-param name="conum">
                                <xsl:apply-templates select="$target" mode="conumber"/>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>???</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="orderedlist-starting-number">
        <xsl:param name="list" select="."/>
        <xsl:variable name="pi-start">
            <xsl:call-template name="pi.dbhtml_start">
                <xsl:with-param name="node" select="$list"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:call-template name="output-orderedlist-starting-number">
            <xsl:with-param name="list" select="$list"/>
            <xsl:with-param name="pi-start" select="$pi-start"/>
        </xsl:call-template>
    </xsl:template>
    <lxslt:component xmlns:lxslt="http://xml.apache.org/xslt" prefix="xverb" functions="insertCallouts"/>
    <xsl:template match="areaspec|areaset|area">
    </xsl:template>
    <xsl:template match="areaset" mode="conumber">
        <xsl:number count="area|areaset" format="1"/>
    </xsl:template>
    <xsl:template match="area" mode="conumber">
        <xsl:number count="area|areaset" format="1"/>
    </xsl:template>
    <xsl:template match="coref">
        <!-- tricky; this relies on the fact that we can process the "co" that's -->
        <!-- "over there" as if it were "right here" -->

        <xsl:variable name="co" select="key('id', @linkend)"/>
        <xsl:choose>
            <xsl:when test="not($co)">
                <xsl:message>
                    <xsl:text>Error: coref link is broken: </xsl:text>
                    <xsl:value-of select="@linkend"/>
                </xsl:message>
            </xsl:when>
            <xsl:when test="local-name($co) != 'co'">
                <xsl:message>
                    <xsl:text>Error: coref doesn't point to a co: </xsl:text>
                    <xsl:value-of select="@linkend"/>
                </xsl:message>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="$co"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <lxslt:component xmlns:lxslt="http://xml.apache.org/xslt" prefix="xverb" functions="numberLines"/>
    <xsl:template match="programlisting|screen|synopsis">
        <xsl:param name="suppress-numbers" select="'0'"/>

        <xsl:call-template name="anchor"/>

        <xsl:variable name="div.element">pre</xsl:variable>

        <xsl:if test="$shade.verbatim != 0">
            <xsl:message>
                <xsl:text>The shade.verbatim parameter is deprecated. </xsl:text>
                <xsl:text>Use CSS instead,</xsl:text>
            </xsl:message>
            <xsl:message>
                <xsl:text>for example: pre.</xsl:text>
                <xsl:value-of select="local-name(.)"/>
                <xsl:text> { background-color: #E0E0E0; }</xsl:text>
            </xsl:message>
        </xsl:if>

        <xsl:choose>
            <xsl:when
                    test="$suppress-numbers = '0'                     and @linenumbering = 'numbered'                     and $use.extensions != '0'                     and $linenumbering.extension != '0'">
                <xsl:variable name="rtf">
                    <xsl:choose>
                        <xsl:when test="$highlight.source != 0">
                            <xsl:call-template name="apply-highlighting"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:apply-templates/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:if test="@width != ''">
                        <xsl:attribute name="width">
                            <xsl:value-of select="@width"/>
                        </xsl:attribute>
                    </xsl:if>
                    <xsl:call-template name="number.rtf.lines">
                        <xsl:with-param name="rtf" select="$rtf"/>
                    </xsl:call-template>
                </xsl:element>
            </xsl:when>
            <xsl:otherwise>
                <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:if test="@width != ''">
                        <xsl:attribute name="width">
                            <xsl:value-of select="@width"/>
                        </xsl:attribute>
                    </xsl:if>
                    <xsl:choose>
                        <xsl:when test="$highlight.source != 0">
                            <xsl:call-template name="apply-highlighting"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:apply-templates/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:element>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="literallayout">
        <xsl:param name="suppress-numbers" select="'0'"/>

        <xsl:variable name="rtf">
            <xsl:apply-templates/>
        </xsl:variable>

        <xsl:if test="$shade.verbatim != 0 and @class='monospaced'">
            <xsl:message>
                <xsl:text>The shade.verbatim parameter is deprecated. </xsl:text>
                <xsl:text>Use CSS instead,</xsl:text>
            </xsl:message>
            <xsl:message>
                <xsl:text>for example: pre.</xsl:text>
                <xsl:value-of select="local-name(.)"/>
                <xsl:text> { background-color: #E0E0E0; }</xsl:text>
            </xsl:message>
        </xsl:if>

        <xsl:choose>
            <xsl:when
                    test="$suppress-numbers = '0'                     and @linenumbering = 'numbered'                     and $use.extensions != '0'                     and $linenumbering.extension != '0'">
                <xsl:choose>
                    <xsl:when test="@class='monospaced'">
                        <pre>
                            <xsl:apply-templates select="." mode="common.html.attributes"/>
                            <xsl:call-template name="id.attribute"/>
                            <xsl:call-template name="number.rtf.lines">
                                <xsl:with-param name="rtf" select="$rtf"/>
                            </xsl:call-template>
                        </pre>
                    </xsl:when>
                    <xsl:otherwise>
                        <div>
                            <xsl:apply-templates select="." mode="common.html.attributes"/>
                            <xsl:call-template name="id.attribute"/>
                            <p>
                                <xsl:call-template name="number.rtf.lines">
                                    <xsl:with-param name="rtf" select="$rtf"/>
                                </xsl:call-template>
                            </p>
                        </div>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="@class='monospaced'">
                        <pre>
                            <xsl:apply-templates select="." mode="common.html.attributes"/>
                            <xsl:call-template name="id.attribute"/>
                            <xsl:copy-of select="$rtf"/>
                        </pre>
                    </xsl:when>
                    <xsl:otherwise>
                        <div>
                            <xsl:apply-templates select="." mode="common.html.attributes"/>
                            <xsl:call-template name="id.attribute"/>
                            <p>
                                <xsl:call-template name="make-verbatim">
                                    <xsl:with-param name="rtf" select="$rtf"/>
                                </xsl:call-template>
                            </p>
                        </div>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="address">
        <xsl:param name="suppress-numbers" select="'0'"/>

        <xsl:variable name="rtf">
            <xsl:apply-templates/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when
                    test="$suppress-numbers = '0'                     and @linenumbering = 'numbered'                     and $use.extensions != '0'                     and $linenumbering.extension != '0'">
                <div>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:call-template name="id.attribute"/>
                    <p>
                        <xsl:call-template name="number.rtf.lines">
                            <xsl:with-param name="rtf" select="$rtf"/>
                        </xsl:call-template>
                    </p>
                </div>
            </xsl:when>

            <xsl:otherwise>
                <div>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:call-template name="id.attribute"/>
                    <p>
                        <xsl:call-template name="make-verbatim">
                            <xsl:with-param name="rtf" select="$rtf"/>
                        </xsl:call-template>
                    </p>
                </div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="make-verbatim">
        <xsl:param name="rtf"/>

        <!-- I want to make this RTF verbatim. There are two possibilities: either
       I have access to the exsl:node-set extension function and I can "do it right"
       or I have to rely on CSS. -->

        <xsl:choose>
            <xsl:when test="$exsl.node.set.available != 0">
                <xsl:apply-templates select="exsl:node-set($rtf)" mode="make.verbatim.mode"/>
            </xsl:when>
            <xsl:otherwise>
                <span style="white-space: pre;">
                    <xsl:copy-of select="$rtf"/>
                </span>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="lastLineNumber">
        <xsl:param name="listings"/>
        <xsl:param name="number" select="0"/>

        <xsl:variable name="lines">
            <xsl:call-template name="countLines">
                <xsl:with-param name="listing" select="string($listings[1])"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="not($listings)">
                <xsl:value-of select="$number"/>
            </xsl:when>
            <xsl:when test="$listings[1]/@startinglinenumber">
                <xsl:value-of select="$number + $listings[1]/@startinglinenumber + $lines - 1"/>
            </xsl:when>
            <xsl:when test="$listings[1]/@continuation='continues'">
                <xsl:call-template name="lastLineNumber">
                    <xsl:with-param name="listings" select="$listings[position() &gt; 1]"/>
                    <xsl:with-param name="number" select="$number + $lines"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$lines"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="countLines">
        <xsl:param name="listing"/>
        <xsl:param name="count" select="1"/>

        <xsl:choose>
            <xsl:when test="contains($listing, '&#10;')">
                <xsl:call-template name="countLines">
                    <xsl:with-param name="listing" select="substring-after($listing, '&#10;')"/>
                    <xsl:with-param name="count" select="$count + 1"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$count"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <lxslt:component xmlns:lxslt="http://xml.apache.org/xslt" prefix="xtext" elements="insertfile"/>
    <lxslt:component xmlns:lxslt="http://xml.apache.org/xslt" prefix="ximg" functions="new getWidth getDepth"/>
    <xsl:template name="is.graphic.format">
        <xsl:param name="format"/>
        <xsl:if test="$format = 'SVG'                 or $format = 'PNG'                 or $format = 'JPG'                 or $format = 'JPEG'                 or $format = 'linespecific'                 or $format = 'GIF'                 or $format = 'GIF87a'                 or $format = 'GIF89a'                 or $format = 'BMP'">
            1
        </xsl:if>
    </xsl:template>
    <xsl:template name="is.graphic.extension">
        <xsl:param name="ext"/>
        <xsl:variable name="lcext"
                      select="translate($ext,                                        'ABCDEFGHIJKLMNOPQRSTUVWXYZ',                                        'abcdefghijklmnopqrstuvwxyz')"/>
        <xsl:if test="$lcext = 'svg'              or $lcext = 'png'              or $lcext = 'jpeg'              or $lcext = 'jpg'              or $lcext = 'avi'              or $lcext = 'mpg'              or $lcext = 'mp4'              or $lcext = 'mpeg'              or $lcext = 'qt'              or $lcext = 'gif'              or $lcext = 'acc'              or $lcext = 'mp1'              or $lcext = 'mp2'              or $lcext = 'mp3'              or $lcext = 'mp4'              or $lcext = 'm4v'              or $lcext = 'm4a'              or $lcext = 'wav'              or $lcext = 'ogv'              or $lcext = 'ogg'              or $lcext = 'webm'              or $lcext = 'bmp'">
            1
        </xsl:if>
    </xsl:template>
    <xsl:template match="screenshot">
        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="screenshot/title">
        <xsl:call-template name="formal.object.heading">
            <xsl:with-param name="object" select=".."/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="screeninfo">
    </xsl:template>
    <xsl:template name="process.image.attributes">
        <xsl:param name="alt"/>
        <xsl:param name="html.width"/>
        <xsl:param name="html.depth"/>
        <xsl:param name="longdesc"/>
        <xsl:param name="scale"/>
        <xsl:param name="scalefit"/>
        <xsl:param name="scaled.contentdepth"/>
        <xsl:param name="scaled.contentwidth"/>
        <xsl:param name="viewport"/>

        <xsl:choose>
            <xsl:when test="@contentwidth or @contentdepth">
                <!-- ignore @width/@depth, @scale, and @scalefit if specified -->
                <xsl:if test="@contentwidth and $scaled.contentwidth != ''">
                    <xsl:attribute name="width">
                        <xsl:value-of select="$scaled.contentwidth"/>
                    </xsl:attribute>
                </xsl:if>
                <xsl:if test="@contentdepth and $scaled.contentdepth != ''">
                    <xsl:attribute name="height">
                        <xsl:value-of select="$scaled.contentdepth"/>
                    </xsl:attribute>
                </xsl:if>
            </xsl:when>

            <xsl:when test="number($scale) != 1.0">
                <!-- scaling is always uniform, so we only have to specify one dimension -->
                <!-- ignore @scalefit if specified -->
                <xsl:attribute name="width">
                    <xsl:value-of select="$scaled.contentwidth"/>
                </xsl:attribute>
            </xsl:when>

            <xsl:when test="$scalefit != 0">
                <xsl:choose>
                    <xsl:when test="contains($html.width, '%')">
                        <xsl:choose>
                            <xsl:when test="$viewport != 0">
                                <!-- The *viewport* will be scaled, so use 100% here! -->
                                <xsl:attribute name="width">
                                    <xsl:value-of select="'100%'"/>
                                </xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="width">
                                    <xsl:value-of select="$html.width"/>
                                </xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>

                    <xsl:when test="contains($html.depth, '%')">
                        <!-- HTML doesn't deal with this case very well...do nothing -->
                    </xsl:when>

                    <xsl:when
                            test="$scaled.contentwidth != '' and $html.width != ''                         and $scaled.contentdepth != '' and $html.depth != ''">
                        <!-- scalefit should not be anamorphic; figure out which direction -->
                        <!-- has the limiting scale factor and scale in that direction -->
                        <xsl:choose>
                            <xsl:when
                                    test="$html.width div $scaled.contentwidth &gt;                             $html.depth div $scaled.contentdepth">
                                <xsl:attribute name="height">
                                    <xsl:value-of select="$html.depth"/>
                                </xsl:attribute>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:attribute name="width">
                                    <xsl:value-of select="$html.width"/>
                                </xsl:attribute>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>

                    <xsl:when test="$scaled.contentwidth != '' and $html.width != ''">
                        <xsl:attribute name="width">
                            <xsl:value-of select="$html.width"/>
                        </xsl:attribute>
                    </xsl:when>

                    <xsl:when test="$scaled.contentdepth != '' and $html.depth != ''">
                        <xsl:attribute name="height">
                            <xsl:value-of select="$html.depth"/>
                        </xsl:attribute>
                    </xsl:when>
                </xsl:choose>
            </xsl:when>
        </xsl:choose>

        <xsl:if test="$alt != ''">
            <xsl:attribute name="alt">
                <xsl:value-of select="normalize-space($alt)"/>
            </xsl:attribute>
        </xsl:if>

        <!-- Turn off longdesc attribute since not supported by browsers
  <xsl:if test="$longdesc != ''">
    <xsl:attribute name="longdesc">
      <xsl:value-of select="$longdesc"/>
    </xsl:attribute>
  </xsl:if>
  -->

        <xsl:if test="@align and $viewport = 0">
            <xsl:attribute name="align">
                <xsl:choose>
                    <xsl:when test="@align = 'center'">middle</xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="@align"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:attribute>
        </xsl:if>

        <xsl:call-template name="extension.process.image.attributes"/>
    </xsl:template>
    <xsl:template name="extension.process.image.attributes"/>
    <xsl:template match="graphic">
        <xsl:choose>
            <xsl:when test="parent::inlineequation">
                <span>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:call-template name="anchor"/>
                    <xsl:call-template name="process.image"/>
                </span>
            </xsl:when>
            <xsl:otherwise>
                <div>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:if test="@align">
                        <xsl:attribute name="align">
                            <xsl:value-of select="@align"/>
                        </xsl:attribute>
                    </xsl:if>
                    <xsl:call-template name="anchor"/>
                    <xsl:call-template name="process.image"/>
                </div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="inlinegraphic">
        <xsl:variable name="filename">
            <xsl:choose>
                <xsl:when test="@entityref">
                    <xsl:value-of select="unparsed-entity-uri(@entityref)"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates select="@fileref"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:call-template name="anchor"/>

        <xsl:choose>
            <xsl:when test="@format='linespecific'">
                <xsl:choose>
                    <xsl:when test="$use.extensions != '0'                         and $textinsert.extension != '0'">
                        <xsl:choose>
                            <xsl:when test="element-available('stext:insertfile')">
                                <stext:insertfile xmlns:stext="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.TextFactory"
                                                  href="{$filename}" encoding="{$textdata.default.encoding}"/>
                            </xsl:when>
                            <xsl:when test="element-available('xtext:insertfile')">
                                <xtext:insertfile xmlns:xtext="xalan://com.nwalsh.xalan.Text" href="{$filename}"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message terminate="yes">
                                    <xsl:text>No insertfile extension available.</xsl:text>
                                </xsl:message>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message terminate="yes">
                            <xsl:text>Cannot insert </xsl:text><xsl:value-of select="$filename"/>
                            <xsl:text>. Check use.extensions and textinsert.extension parameters.</xsl:text>
                        </xsl:message>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="process.image"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="mediaobject|mediaobjectco">

        <xsl:variable name="olist"
                      select="imageobject|imageobjectco                      |videoobject|audioobject                      |textobject"/>

        <xsl:variable name="object.index">
            <xsl:call-template name="select.mediaobject.index">
                <xsl:with-param name="olist" select="$olist"/>
                <xsl:with-param name="count" select="1"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="object" select="$olist[position() = $object.index]"/>

        <xsl:variable name="align">
            <xsl:value-of select="$object/descendant::imagedata[@align][1]/@align"/>
        </xsl:variable>

        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:if test="$align != '' ">
                <xsl:attribute name="align">
                    <xsl:value-of select="$align"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>

            <xsl:apply-templates select="$object"/>
            <xsl:apply-templates select="caption"/>
        </div>
    </xsl:template>
    <xsl:template match="inlinemediaobject">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="select.mediaobject"/>
        </span>
    </xsl:template>
    <xsl:template match="programlisting/inlinemediaobject                      |screen/inlinemediaobject" priority="2">
        <!-- the additional span causes problems in some cases -->
        <xsl:call-template name="select.mediaobject"/>
    </xsl:template>
    <xsl:template match="imageobjectco">
        <xsl:call-template name="anchor"/>
        <xsl:choose>
            <!-- select one imageobject? -->
            <xsl:when
                    test="$use.role.for.mediaobject != 0 and                     count(imageobject) &gt; 1 and                     imageobject[@role]">
                <xsl:variable name="olist" select="imageobject"/>

                <xsl:variable name="object.index">
                    <xsl:call-template name="select.mediaobject.index">
                        <xsl:with-param name="olist" select="$olist"/>
                        <xsl:with-param name="count" select="1"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="object" select="$olist[position() = $object.index]"/>

                <xsl:apply-templates select="$object"/>
            </xsl:when>
            <xsl:otherwise>
                <!-- otherwise process them all -->
                <xsl:apply-templates select="imageobject"/>
            </xsl:otherwise>
        </xsl:choose>

        <xsl:apply-templates select="calloutlist"/>

    </xsl:template>
    <xsl:template match="imageobject">
        <xsl:apply-templates select="imagedata"/>
    </xsl:template>
    <xsl:template name="longdesc.uri">
        <xsl:param name="mediaobject" select="."/>
        <xsl:if test="$html.longdesc">
            <xsl:if test="$mediaobject/textobject[not(phrase)]">
                <xsl:variable name="dbhtml.dir">
                    <xsl:call-template name="dbhtml-dir"/>
                </xsl:variable>
                <xsl:variable name="filename">
                    <xsl:call-template name="make-relative-filename">
                        <xsl:with-param name="base.dir">
                            <xsl:choose>
                                <xsl:when test="$dbhtml.dir != ''">
                                    <xsl:value-of select="$dbhtml.dir"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:value-of select="$chunk.base.dir"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:with-param>
                        <xsl:with-param name="base.name">
                            <xsl:choose>
                                <xsl:when
                                        test="                 $mediaobject/@*[local-name() = 'id']                 and not($use.id.as.filename = 0)">
                                    <!-- * if this mediaobject has an ID, then we use the -->
                                    <!-- * value of that ID as basename for the "longdesc" -->
                                    <!-- * file (that is, without prepending an "ld-" too it) -->
                                    <xsl:value-of select="$mediaobject/@*[local-name() = 'id']"/>
                                    <xsl:value-of select="$html.ext"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <!-- * otherwise, if this mediaobject does not have an -->
                                    <!-- * ID, then we generate an ID... -->
                                    <xsl:variable name="image-id">
                                        <xsl:call-template name="object.id">
                                            <xsl:with-param name="object" select="$mediaobject"/>
                                        </xsl:call-template>
                                    </xsl:variable>
                                    <!-- * ...and then we take that generated ID, prepend an -->
                                    <!-- * "ld-" to it, and use that as the basename for the file -->
                                    <xsl:value-of select="concat('ld-',$image-id,$html.ext)"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:with-param>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:value-of select="$filename"/>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    <xsl:template name="write.longdesc">
        <xsl:param name="mediaobject" select="."/>
        <xsl:if test="$html.longdesc != 0 and $mediaobject/textobject[not(phrase)]">
            <xsl:variable name="filename">
                <xsl:call-template name="longdesc.uri">
                    <xsl:with-param name="mediaobject" select="$mediaobject"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:value-of select="$filename"/>

            <xsl:call-template name="write.chunk">
                <xsl:with-param name="filename" select="$filename"/>
                <xsl:with-param name="quiet" select="$chunk.quietly"/>
                <xsl:with-param name="content">
                    <xsl:call-template name="user.preroot"/>
                    <html>
                        <head>
                            <xsl:call-template name="system.head.content"/>
                            <xsl:call-template name="head.content">
                                <xsl:with-param name="title" select="'Long Description'"/>
                            </xsl:call-template>
                            <xsl:call-template name="user.head.content"/>
                        </head>
                        <body>
                            <xsl:call-template name="body.attributes"/>
                            <xsl:for-each select="$mediaobject/textobject[not(phrase)]">
                                <xsl:apply-templates select="./*"/>
                            </xsl:for-each>
                        </body>
                    </html>
                    <xsl:value-of select="$chunk.append"/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template match="mediaobject/alt">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="videoobject">
        <xsl:apply-templates select="videodata"/>
    </xsl:template>
    <xsl:template match="videodata">
        <xsl:call-template name="process.image">
            <xsl:with-param name="tag" select="'embed'"/>
            <xsl:with-param name="alt">
                <xsl:choose>
                    <xsl:when test="ancestor::mediaobject/alt">
                        <xsl:apply-templates select="ancestor::mediaobject/alt"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="(ancestor::mediaobject/textobject/phrase)[1]"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="audioobject">
        <xsl:apply-templates select="audiodata"/>
    </xsl:template>
    <xsl:template match="audiodata">
        <xsl:call-template name="process.image">
            <xsl:with-param name="tag" select="'embed'"/>
            <xsl:with-param name="alt">
                <xsl:choose>
                    <xsl:when test="ancestor::mediaobject/alt">
                        <xsl:apply-templates select="ancestor::mediaobject/alt"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="(ancestor::mediaobject/textobject/phrase)[1]"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="textobject">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="textdata">
        <xsl:variable name="filename">
            <xsl:choose>
                <xsl:when test="@entityref">
                    <xsl:value-of select="unparsed-entity-uri(@entityref)"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates select="@fileref"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="encoding">
            <xsl:choose>
                <xsl:when test="@encoding">
                    <xsl:value-of select="@encoding"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$textdata.default.encoding"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$use.extensions != '0'                     and $textinsert.extension != '0'">
                <xsl:choose>
                    <xsl:when test="element-available('stext:insertfile')">
                        <stext:insertfile xmlns:stext="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.TextFactory"
                                          href="{$filename}" encoding="{$encoding}"/>
                    </xsl:when>
                    <xsl:when test="element-available('xtext:insertfile')">
                        <xtext:insertfile xmlns:xtext="xalan://com.nwalsh.xalan.Text" href="{$filename}"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message terminate="yes">
                            <xsl:text>No insertfile extension available.</xsl:text>
                        </xsl:message>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="yes">
                    <xsl:text>Cannot insert </xsl:text><xsl:value-of select="$filename"/>
                    <xsl:text>. Check use.extensions and textinsert.extension parameters.</xsl:text>
                </xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="caption">
        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:if test="@align = 'right' or @align = 'left' or @align='center'">
                <xsl:attribute name="align">
                    <xsl:value-of select="@align"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template xmlns:svg="http://www.w3.org/2000/svg" match="svg:*">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:apply-templates/>
        </xsl:copy>
    </xsl:template>
    <xsl:template match="@fileref">
        <!-- need a check for absolute urls -->
        <xsl:choose>
            <xsl:when test="contains(., ':')">
                <!-- it has a uri scheme so it is an absolute uri -->
                <xsl:value-of select="."/>
            </xsl:when>
            <xsl:when test="$keep.relative.image.uris != 0">
                <!-- leave it alone -->
                <xsl:value-of select="."/>
            </xsl:when>
            <xsl:otherwise>
                <!-- its a relative uri that needs xml:base processing -->
                <xsl:call-template name="relative-uri">
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:variable name="xolink.role">http://docbook.org/xlink/role/olink</xsl:variable>
    <xsl:template match="anchor">
        <xsl:choose>
            <xsl:when test="$generate.id.attributes = 0">
                <xsl:call-template name="anchor"/>
            </xsl:when>
            <xsl:otherwise>
                <span>
                    <xsl:call-template name="id.attribute"/>
                </span>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="xref" name="xref">
        <xsl:param name="xhref" select="@xlink:href"/>
        <!-- is the @xlink:href a local idref link? -->
        <xsl:param name="xlink.idref">
            <xsl:if test="starts-with($xhref,'#')                   and (not(contains($xhref,'('))                   or starts-with($xhref, '#xpointer(id('))">
                <xsl:call-template name="xpointer.idref">
                    <xsl:with-param name="xpointer" select="$xhref"/>
                </xsl:call-template>
            </xsl:if>
        </xsl:param>
        <xsl:param name="xlink.targets" select="key('id',$xlink.idref)"/>
        <xsl:param name="linkend.targets" select="key('id',@linkend)"/>
        <xsl:param name="target" select="($xlink.targets | $linkend.targets)[1]"/>

        <xsl:variable name="xrefstyle">
            <xsl:choose>
                <xsl:when test="@role and not(@xrefstyle)                        and $use.role.as.xrefstyle != 0">
                    <xsl:value-of select="@role"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="@xrefstyle"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:call-template name="anchor"/>

        <xsl:variable name="content">
            <xsl:choose>

                <xsl:when test="@endterm">
                    <xsl:variable name="etargets" select="key('id',@endterm)"/>
                    <xsl:variable name="etarget" select="$etargets[1]"/>
                    <xsl:choose>
                        <xsl:when test="count($etarget) = 0">
                            <xsl:message>
                                <xsl:value-of select="count($etargets)"/>
                                <xsl:text>Endterm points to nonexistent ID: </xsl:text>
                                <xsl:value-of select="@endterm"/>
                            </xsl:message>
                            <xsl:text>???</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:apply-templates select="$etarget" mode="endterm"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>

                <xsl:when test="$target/@xreflabel">
                    <xsl:call-template name="xref.xreflabel">
                        <xsl:with-param name="target" select="$target"/>
                    </xsl:call-template>
                </xsl:when>

                <xsl:when test="$target">
                    <xsl:if test="not(parent::citation)">
                        <xsl:apply-templates select="$target" mode="xref-to-prefix"/>
                    </xsl:if>

                    <xsl:apply-templates select="$target" mode="xref-to">
                        <xsl:with-param name="referrer" select="."/>
                        <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                    </xsl:apply-templates>

                    <xsl:if test="not(parent::citation)">
                        <xsl:apply-templates select="$target" mode="xref-to-suffix"/>
                    </xsl:if>
                </xsl:when>

                <xsl:otherwise>
                    <xsl:message>
                        <xsl:text>ERROR: xref linking to </xsl:text>
                        <xsl:value-of select="@linkend|@xlink:href"/>
                        <xsl:text> has no generated link text.</xsl:text>
                    </xsl:message>
                    <xsl:text>???</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:call-template name="simple.xlink">
            <xsl:with-param name="content" select="$content"/>
        </xsl:call-template>

    </xsl:template>
    <xsl:template match="biblioref">
        <xsl:variable name="targets" select="key('id',@linkend)"/>
        <xsl:variable name="target" select="$targets[1]"/>
        <xsl:variable name="refelem" select="local-name($target)"/>

        <xsl:call-template name="check.id.unique">
            <xsl:with-param name="linkend" select="@linkend"/>
        </xsl:call-template>

        <xsl:call-template name="anchor"/>

        <xsl:choose>
            <xsl:when test="count($target) = 0">
                <xsl:message>
                    <xsl:text>XRef to nonexistent id: </xsl:text>
                    <xsl:value-of select="@linkend"/>
                </xsl:message>
                <xsl:text>???</xsl:text>
            </xsl:when>

            <xsl:when test="@endterm">
                <xsl:variable name="href">
                    <xsl:call-template name="href.target">
                        <xsl:with-param name="object" select="$target"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="etargets" select="key('id',@endterm)"/>
                <xsl:variable name="etarget" select="$etargets[1]"/>
                <xsl:choose>
                    <xsl:when test="count($etarget) = 0">
                        <xsl:message>
                            <xsl:value-of select="count($etargets)"/>
                            <xsl:text>Endterm points to nonexistent ID: </xsl:text>
                            <xsl:value-of select="@endterm"/>
                        </xsl:message>
                        <a href="{$href}">
                            <xsl:apply-templates select="." mode="common.html.attributes"/>
                            <xsl:call-template name="id.attribute"/>
                            <xsl:text>???</xsl:text>
                        </a>
                    </xsl:when>
                    <xsl:otherwise>
                        <a href="{$href}">
                            <xsl:apply-templates select="." mode="common.html.attributes"/>
                            <xsl:call-template name="id.attribute"/>
                            <xsl:apply-templates select="$etarget" mode="endterm"/>
                        </a>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>

            <xsl:when test="$target/@xreflabel">
                <a>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:attribute name="href">
                        <xsl:call-template name="href.target">
                            <xsl:with-param name="object" select="$target"/>
                        </xsl:call-template>
                    </xsl:attribute>
                    <xsl:call-template name="xref.xreflabel">
                        <xsl:with-param name="target" select="$target"/>
                    </xsl:call-template>
                </a>
            </xsl:when>

            <xsl:otherwise>
                <xsl:variable name="href">
                    <xsl:call-template name="href.target">
                        <xsl:with-param name="object" select="$target"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:if test="not(parent::citation)">
                    <xsl:apply-templates select="$target" mode="xref-to-prefix"/>
                </xsl:if>

                <a href="{$href}">
                    <xsl:apply-templates select="." mode="class.attribute"/>
                    <xsl:if test="$target/title or $target/info/title">
                        <xsl:attribute name="title">
                            <xsl:apply-templates select="$target" mode="xref-title"/>
                        </xsl:attribute>
                    </xsl:if>
                    <xsl:apply-templates select="$target" mode="xref-to">
                        <xsl:with-param name="referrer" select="."/>
                        <xsl:with-param name="xrefstyle">
                            <xsl:choose>
                                <xsl:when test="@role and not(@xrefstyle) and $use.role.as.xrefstyle != 0">
                                    <xsl:value-of select="@role"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:value-of select="@xrefstyle"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:with-param>
                    </xsl:apply-templates>
                </a>

                <xsl:if test="not(parent::citation)">
                    <xsl:apply-templates select="$target" mode="xref-to-suffix"/>
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*" mode="endterm">
        <!-- Process the children of the endterm element -->
        <xsl:variable name="endterm">
            <xsl:apply-templates select="child::node()" mode="no.anchor.mode"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$exsl.node.set.available != 0">
                <xsl:apply-templates select="exsl:node-set($endterm)" mode="remove-ids"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="$endterm"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*" mode="remove-ids">
        <xsl:choose>
            <!-- handle html or xhtml -->
            <xsl:when
                    test="local-name(.) = 'a'                     and (namespace-uri(.) = ''                          or namespace-uri(.) = 'http://www.w3.org/1999/xhtml')">
                <xsl:choose>
                    <xsl:when
                            test="(@name and count(@*) = 1)                         or (@id and count(@*) = 1)                         or (@xml:id and count(@*) = 1)                         or (@xml:id and @name and count(@*) = 2)                         or (@id and @name and count(@*) = 2)">
                        <xsl:message>suppress anchor</xsl:message>
                        <!-- suppress the whole thing -->
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:copy>
                            <xsl:for-each select="@*">
                                <xsl:choose>
                                    <xsl:when test="local-name(.) != 'name' and local-name(.) != 'id'">
                                        <xsl:copy/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:message>removing
                                            <xsl:value-of select="local-name(.)"/>
                                        </xsl:message>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:for-each>
                        </xsl:copy>
                        <xsl:apply-templates mode="remove-ids"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy>
                    <xsl:for-each select="@*">
                        <xsl:choose>
                            <xsl:when test="local-name(.) != 'id'">
                                <xsl:copy/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message>removing
                                    <xsl:value-of select="local-name(.)"/>
                                </xsl:message>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:for-each>
                    <xsl:apply-templates mode="remove-ids"/>
                </xsl:copy>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*" mode="xref-to-prefix"/>
    <xsl:template match="*" mode="xref-to-suffix"/>
    <xsl:template match="*" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:if test="$verbose">
            <xsl:message>
                <xsl:text>Don't know what gentext to create for xref to: "</xsl:text>
                <xsl:value-of select="name(.)"/>
                <xsl:text>", ("</xsl:text>
                <xsl:value-of select="(@id|@xml:id)[1]"/>
                <xsl:text>")</xsl:text>
            </xsl:message>
        </xsl:if>
        <xsl:text>???</xsl:text>
    </xsl:template>
    <xsl:template match="title" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <!-- if you xref to a title, xref to the parent... -->
        <xsl:choose>
            <!-- FIXME: how reliable is this? -->
            <xsl:when test="contains(local-name(parent::*), 'info')">
                <xsl:apply-templates select="parent::*[2]" mode="xref-to">
                    <xsl:with-param name="referrer" select="$referrer"/>
                    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                    <xsl:with-param name="verbose" select="$verbose"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="parent::*" mode="xref-to">
                    <xsl:with-param name="referrer" select="$referrer"/>
                    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                    <xsl:with-param name="verbose" select="$verbose"/>
                </xsl:apply-templates>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template
            match="abstract|authorblurb|personblurb|bibliodiv|bibliomset                      |biblioset|blockquote|calloutlist|caution|colophon                      |constraintdef|formalpara|glossdiv|important|indexdiv                      |itemizedlist|legalnotice|lot|msg|msgexplan|msgmain                      |msgrel|msgset|msgsub|note|orderedlist|partintro                      |productionset|qandadiv|refsynopsisdiv|screenshot|segmentedlist                      |set|setindex|sidebar|tip|toc|variablelist|warning"
            mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <!-- catch-all for things with (possibly optional) titles -->
        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="author|editor|othercredit|personname" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>

        <xsl:call-template name="person.name"/>
    </xsl:template>
    <xsl:template match="authorgroup" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>

        <xsl:call-template name="person.name.list"/>
    </xsl:template>
    <xsl:template match="figure|example|table|equation" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="procedure" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose"/>

        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="task" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose"/>

        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="cmdsynopsis" mode="xref-to">
        <xsl:apply-templates select="(.//command)[1]" mode="xref"/>
    </xsl:template>
    <xsl:template match="funcsynopsis" mode="xref-to">
        <xsl:apply-templates select="(.//function)[1]" mode="xref"/>
    </xsl:template>
    <xsl:template match="dedication|acknowledgements|preface|chapter|appendix|article" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="bibliography" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="biblioentry|bibliomixed" mode="xref-to-prefix">
        <xsl:text>[</xsl:text>
    </xsl:template>
    <xsl:template match="biblioentry|bibliomixed" mode="xref-to-suffix">
        <xsl:text>]</xsl:text>
    </xsl:template>
    <xsl:template match="biblioentry|bibliomixed" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <!-- handles both biblioentry and bibliomixed -->
        <xsl:choose>
            <xsl:when test="string(.) = ''">
                <xsl:variable name="bib" select="document($bibliography.collection,.)"/>
                <xsl:variable name="id" select="(@id|@xml:id)[1]"/>
                <xsl:variable name="entry"
                              select="$bib/bibliography/                                     *[@id=$id or @xml:id=$id][1]"/>
                <xsl:choose>
                    <xsl:when test="$entry">
                        <xsl:choose>
                            <xsl:when test="$bibliography.numbered != 0">
                                <xsl:number from="bibliography" count="biblioentry|bibliomixed" level="any" format="1"/>
                            </xsl:when>
                            <xsl:when test="local-name($entry/*[1]) = 'abbrev'">
                                <xsl:apply-templates select="$entry/*[1]" mode="no.anchor.mode"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:value-of select="(@id|@xml:id)[1]"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message>
                            <xsl:text>No bibliography entry: </xsl:text>
                            <xsl:value-of select="$id"/>
                            <xsl:text> found in </xsl:text>
                            <xsl:value-of select="$bibliography.collection"/>
                        </xsl:message>
                        <xsl:value-of select="(@id|@xml:id)[1]"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="$bibliography.numbered != 0">
                        <xsl:number from="bibliography" count="biblioentry|bibliomixed" level="any" format="1"/>
                    </xsl:when>
                    <xsl:when test="local-name(*[1]) = 'abbrev'">
                        <xsl:apply-templates select="*[1]" mode="no.anchor.mode"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="(@id|@xml:id)[1]"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="glossary" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="glossentry" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>
        <xsl:choose>
            <xsl:when test="$glossentry.show.acronym = 'primary'">
                <xsl:choose>
                    <xsl:when test="acronym|abbrev">
                        <xsl:apply-templates select="(acronym|abbrev)[1]" mode="no.anchor.mode"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="glossterm[1]" mode="xref-to">
                            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                            <xsl:with-param name="referrer" select="$referrer"/>
                            <xsl:with-param name="verbose" select="$verbose"/>
                        </xsl:apply-templates>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="glossterm[1]" mode="xref-to">
                    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                    <xsl:with-param name="referrer" select="$referrer"/>
                    <xsl:with-param name="verbose" select="$verbose"/>
                </xsl:apply-templates>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="glossterm|firstterm" mode="xref-to">
        <xsl:apply-templates mode="no.anchor.mode"/>
    </xsl:template>
    <xsl:template match="index" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="listitem" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose"/>

        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template
            match="section|simplesect                      |sect1|sect2|sect3|sect4|sect5                      |refsect1|refsect2|refsect3|refsection"
            mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
        <!-- FIXME: What about "in Chapter X"? -->
    </xsl:template>
    <xsl:template match="topic" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="bridgehead" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
        <!-- FIXME: What about "in Chapter X"? -->
    </xsl:template>
    <xsl:template match="qandaset" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="qandaentry" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates select="question[1]" mode="xref-to">
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="question|answer" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:choose>
            <xsl:when test="string-length(label) != 0">
                <xsl:apply-templates select="." mode="label.markup"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="." mode="object.xref.markup">
                    <xsl:with-param name="purpose" select="'xref'"/>
                    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                    <xsl:with-param name="referrer" select="$referrer"/>
                    <xsl:with-param name="verbose" select="$verbose"/>
                </xsl:apply-templates>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="part|reference" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="refentry" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>

        <xsl:choose>
            <xsl:when test="refmeta/refentrytitle">
                <xsl:apply-templates select="refmeta/refentrytitle" mode="no.anchor.mode"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="refnamediv/refname[1]" mode="no.anchor.mode"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:apply-templates select="refmeta/manvolnum" mode="no.anchor.mode"/>
    </xsl:template>
    <xsl:template match="refnamediv" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates select="refname[1]" mode="xref-to">
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="refname" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates mode="xref-to"/>
    </xsl:template>
    <xsl:template match="step" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>

        <xsl:call-template name="gentext">
            <xsl:with-param name="key" select="'Step'"/>
        </xsl:call-template>
        <xsl:text> </xsl:text>
        <xsl:apply-templates select="." mode="number"/>
    </xsl:template>
    <xsl:template match="varlistentry" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates select="term[1]" mode="xref-to">
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="primary|secondary|tertiary" mode="xref-to">
        <xsl:value-of select="."/>
    </xsl:template>
    <xsl:template match="indexterm" mode="xref-to">
        <xsl:value-of select="primary"/>
    </xsl:template>
    <xsl:template match="varlistentry/term" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>

        <xsl:apply-templates mode="no.anchor.mode"/>
    </xsl:template>
    <xsl:template match="co" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>

        <xsl:apply-templates select="." mode="callout-bug"/>
    </xsl:template>
    <xsl:template match="area|areaset" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>

        <xsl:call-template name="callout-bug">
            <xsl:with-param name="conum">
                <xsl:apply-templates select="." mode="conumber"/>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="book" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:apply-templates select="." mode="object.xref.markup">
            <xsl:with-param name="purpose" select="'xref'"/>
            <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
            <xsl:with-param name="referrer" select="$referrer"/>
            <xsl:with-param name="verbose" select="$verbose"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="para|phrase|simpara|anchor|quote" mode="xref-to">
        <xsl:param name="referrer"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="verbose" select="1"/>

        <xsl:variable name="context"
                      select="(ancestor::simplesect                                        |ancestor::section                                        |ancestor::sect1                                        |ancestor::sect2                                        |ancestor::sect3                                        |ancestor::sect4                                        |ancestor::sect5                                        |ancestor::topic                                        |ancestor::refsection                                        |ancestor::refsect1                                        |ancestor::refsect2                                        |ancestor::refsect3                                        |ancestor::chapter                                        |ancestor::appendix                                        |ancestor::preface                                        |ancestor::partintro                                        |ancestor::dedication                                        |ancestor::acknowledgements                                        |ancestor::colophon                                        |ancestor::bibliography                                        |ancestor::index                                        |ancestor::glossary                                        |ancestor::glossentry                                        |ancestor::listitem                                        |ancestor::varlistentry)[last()]"/>

        <xsl:choose>
            <xsl:when test="$xrefstyle != ''">
                <xsl:apply-templates select="." mode="object.xref.markup">
                    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                    <xsl:with-param name="referrer" select="$referrer"/>
                    <xsl:with-param name="verbose" select="$verbose"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="$context" mode="xref-to">
                    <xsl:with-param name="purpose" select="'xref'"/>
                    <xsl:with-param name="xrefstyle" select="$xrefstyle"/>
                    <xsl:with-param name="referrer" select="$referrer"/>
                    <xsl:with-param name="verbose" select="$verbose"/>
                </xsl:apply-templates>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*" mode="xref-title">
        <xsl:variable name="title">
            <xsl:apply-templates select="." mode="object.title.markup"/>
        </xsl:variable>

        <xsl:value-of select="$title"/>
    </xsl:template>
    <xsl:template match="author" mode="xref-title">
        <xsl:variable name="title">
            <xsl:call-template name="person.name"/>
        </xsl:variable>

        <xsl:value-of select="$title"/>
    </xsl:template>
    <xsl:template match="authorgroup" mode="xref-title">
        <xsl:variable name="title">
            <xsl:call-template name="person.name.list"/>
        </xsl:variable>

        <xsl:value-of select="$title"/>
    </xsl:template>
    <xsl:template match="cmdsynopsis" mode="xref-title">
        <xsl:variable name="title">
            <xsl:apply-templates select="(.//command)[1]" mode="xref"/>
        </xsl:variable>

        <xsl:value-of select="$title"/>
    </xsl:template>
    <xsl:template match="funcsynopsis" mode="xref-title">
        <xsl:variable name="title">
            <xsl:apply-templates select="(.//function)[1]" mode="xref"/>
        </xsl:variable>

        <xsl:value-of select="$title"/>
    </xsl:template>
    <xsl:template match="biblioentry|bibliomixed" mode="xref-title">
        <!-- handles both biblioentry and bibliomixed -->
        <xsl:variable name="title">
            <xsl:text>[</xsl:text>
            <xsl:choose>
                <xsl:when test="local-name(*[1]) = 'abbrev'">
                    <xsl:apply-templates select="*[1]" mode="no.anchor.mode"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="(@id|@xml:id)[1]"/>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:text>]</xsl:text>
        </xsl:variable>

        <xsl:value-of select="$title"/>
    </xsl:template>
    <xsl:template match="step" mode="xref-title">
        <xsl:call-template name="gentext">
            <xsl:with-param name="key" select="'Step'"/>
        </xsl:call-template>
        <xsl:text> </xsl:text>
        <xsl:apply-templates select="." mode="number"/>
    </xsl:template>
    <xsl:template match="step[not(./title)]" mode="title.markup">
        <xsl:call-template name="gentext">
            <xsl:with-param name="key" select="'Step'"/>
        </xsl:call-template>
        <xsl:text> </xsl:text>
        <xsl:apply-templates select="." mode="number"/>
    </xsl:template>
    <xsl:template match="co" mode="xref-title">
        <xsl:variable name="title">
            <xsl:apply-templates select="." mode="callout-bug"/>
        </xsl:variable>

        <xsl:value-of select="$title"/>
    </xsl:template>
    <xsl:template match="link" name="link">
        <xsl:param name="linkend" select="@linkend"/>
        <xsl:param name="a.target"/>
        <xsl:param name="xhref" select="@xlink:href"/>

        <xsl:variable name="content">
            <xsl:call-template name="anchor"/>
            <xsl:choose>
                <xsl:when test="count(child::node()) &gt; 0">
                    <!-- If it has content, use it -->
                    <xsl:apply-templates mode="no.anchor.mode"/>
                </xsl:when>
                <!-- else look for an endterm -->
                <xsl:when test="@endterm">
                    <xsl:variable name="etargets" select="key('id',@endterm)"/>
                    <xsl:variable name="etarget" select="$etargets[1]"/>
                    <xsl:choose>
                        <xsl:when test="count($etarget) = 0">
                            <xsl:message>
                                <xsl:value-of select="count($etargets)"/>
                                <xsl:text>Endterm points to nonexistent ID: </xsl:text>
                                <xsl:value-of select="@endterm"/>
                            </xsl:message>
                            <xsl:text>???</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:apply-templates select="$etarget" mode="endterm"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <!-- Use the xlink:href if no other text -->
                <xsl:when test="@xlink:href">
                    <xsl:value-of select="@xlink:href"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:message>
                        <xsl:text>Link element has no content and no Endterm. </xsl:text>
                        <xsl:text>Nothing to show in the link to </xsl:text>
                        <xsl:value-of select="(@xlink:href|@linkend)[1]"/>
                    </xsl:message>
                    <xsl:text>???</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:call-template name="simple.xlink">
            <xsl:with-param name="node" select="."/>
            <xsl:with-param name="linkend" select="$linkend"/>
            <xsl:with-param name="content" select="$content"/>
            <xsl:with-param name="a.target" select="$a.target"/>
            <xsl:with-param name="xhref" select="$xhref"/>
        </xsl:call-template>

    </xsl:template>
    <xsl:template match="olink" name="olink">
        <!-- olink content may be passed in from xlink olink -->
        <xsl:param name="content" select="NOTANELEMENT"/>

        <xsl:call-template name="anchor"/>

        <xsl:choose>
            <!-- olinks resolved by stylesheet and target database -->
            <xsl:when
                    test="@targetdoc or @targetptr or                     (@xlink:role=$xolink.role and                      contains(@xlink:href, '#') )">

                <xsl:variable name="targetdoc.att">
                    <xsl:choose>
                        <xsl:when test="@targetdoc != ''">
                            <xsl:value-of select="@targetdoc"/>
                        </xsl:when>
                        <xsl:when test="@xlink:role=$xolink.role and                        contains(@xlink:href, '#')">
                            <xsl:value-of select="substring-before(@xlink:href, '#')"/>
                        </xsl:when>
                    </xsl:choose>
                </xsl:variable>

                <xsl:variable name="targetptr.att">
                    <xsl:choose>
                        <xsl:when test="@targetptr != ''">
                            <xsl:value-of select="@targetptr"/>
                        </xsl:when>
                        <xsl:when test="@xlink:role=$xolink.role and                        contains(@xlink:href, '#')">
                            <xsl:value-of select="substring-after(@xlink:href, '#')"/>
                        </xsl:when>
                    </xsl:choose>
                </xsl:variable>

                <xsl:variable name="olink.lang">
                    <xsl:call-template name="l10n.language">
                        <xsl:with-param name="xref-context" select="true()"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="target.database.filename">
                    <xsl:call-template name="select.target.database">
                        <xsl:with-param name="targetdoc.att" select="$targetdoc.att"/>
                        <xsl:with-param name="targetptr.att" select="$targetptr.att"/>
                        <xsl:with-param name="olink.lang" select="$olink.lang"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="target.database" select="document($target.database.filename,/)"/>

                <xsl:if test="$olink.debug != 0">
                    <xsl:message>
                        <xsl:text>Olink debug: root element of target.database '</xsl:text>
                        <xsl:value-of select="$target.database.filename"/>
                        <xsl:text>' is '</xsl:text>
                        <xsl:value-of select="local-name($target.database/*[1])"/>
                        <xsl:text>'.</xsl:text>
                    </xsl:message>
                </xsl:if>

                <xsl:variable name="olink.key">
                    <xsl:call-template name="select.olink.key">
                        <xsl:with-param name="targetdoc.att" select="$targetdoc.att"/>
                        <xsl:with-param name="targetptr.att" select="$targetptr.att"/>
                        <xsl:with-param name="olink.lang" select="$olink.lang"/>
                        <xsl:with-param name="target.database" select="$target.database"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:if test="string-length($olink.key) = 0">
                    <xsl:message>
                        <xsl:text>Error: unresolved olink: </xsl:text>
                        <xsl:text>targetdoc/targetptr = '</xsl:text>
                        <xsl:value-of select="$targetdoc.att"/>
                        <xsl:text>/</xsl:text>
                        <xsl:value-of select="$targetptr.att"/>
                        <xsl:text>'.</xsl:text>
                    </xsl:message>
                </xsl:if>

                <xsl:variable name="href">
                    <xsl:call-template name="make.olink.href">
                        <xsl:with-param name="olink.key" select="$olink.key"/>
                        <xsl:with-param name="target.database" select="$target.database"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="hottext">
                    <xsl:choose>
                        <xsl:when test="string-length($content) != 0">
                            <xsl:copy-of select="$content"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:call-template name="olink.hottext">
                                <xsl:with-param name="olink.key" select="$olink.key"/>
                                <xsl:with-param name="olink.lang" select="$olink.lang"/>
                                <xsl:with-param name="target.database" select="$target.database"/>
                            </xsl:call-template>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>

                <xsl:variable name="olink.docname.citation">
                    <xsl:call-template name="olink.document.citation">
                        <xsl:with-param name="olink.key" select="$olink.key"/>
                        <xsl:with-param name="target.database" select="$target.database"/>
                        <xsl:with-param name="olink.lang" select="$olink.lang"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="olink.page.citation">
                    <xsl:call-template name="olink.page.citation">
                        <xsl:with-param name="olink.key" select="$olink.key"/>
                        <xsl:with-param name="target.database" select="$target.database"/>
                        <xsl:with-param name="olink.lang" select="$olink.lang"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:choose>
                    <xsl:when test="$href != ''">
                        <a href="{$href}">
                            <xsl:apply-templates select="." mode="common.html.attributes"/>
                            <xsl:call-template name="id.attribute"/>
                            <xsl:copy-of select="$hottext"/>
                        </a>
                        <xsl:copy-of select="$olink.page.citation"/>
                        <xsl:copy-of select="$olink.docname.citation"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <span class="{$class.prefix}olink">
                            <xsl:call-template name="id.attribute"/>
                            <xsl:copy-of select="$hottext"/>
                        </span>
                        <xsl:copy-of select="$olink.page.citation"/>
                        <xsl:copy-of select="$olink.docname.citation"/>
                    </xsl:otherwise>
                </xsl:choose>

            </xsl:when>

            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="@linkmode or @targetdocent or @localinfo">
                        <!-- old olink mechanism -->
                        <xsl:message>
                            <xsl:text>ERROR: olink using obsolete attributes </xsl:text>
                            <xsl:text>@linkmode, @targetdocent, @localinfo are </xsl:text>
                            <xsl:text>not supported.</xsl:text>
                        </xsl:message>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message>
                            <xsl:text>ERROR: olink is missing linking attributes.</xsl:text>
                        </xsl:message>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*" mode="pagenumber.markup">
        <!-- no-op in HTML -->
    </xsl:template>
    <xsl:template name="xref.xreflabel">
        <!-- called to process an xreflabel...you might use this to make  -->
        <!-- xreflabels come out in the right font for different targets, -->
        <!-- for example. -->
        <xsl:param name="target" select="."/>
        <xsl:value-of select="$target/@xreflabel"/>
    </xsl:template>
    <xsl:template match="title" mode="xref">
        <xsl:apply-templates mode="no.anchor.mode"/>
    </xsl:template>
    <xsl:template match="command" mode="xref">
        <xsl:call-template name="inline.boldseq"/>
    </xsl:template>
    <xsl:template match="function" mode="xref">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="*" mode="insert.title.markup">
        <xsl:param name="purpose"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="title"/>

        <xsl:choose>
            <xsl:when test="$purpose = 'xref'">
                <xsl:copy-of select="$title"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="$title"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="chapter|appendix" mode="insert.title.markup">
        <xsl:param name="purpose"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="title"/>

        <xsl:choose>
            <xsl:when test="$purpose = 'xref'">
                <em>
                    <xsl:copy-of select="$title"/>
                </em>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="$title"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*" mode="insert.subtitle.markup">
        <xsl:param name="purpose"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="subtitle"/>

        <xsl:copy-of select="$subtitle"/>
    </xsl:template>
    <xsl:template match="*" mode="insert.label.markup">
        <xsl:param name="purpose"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="label"/>

        <xsl:copy-of select="$label"/>
    </xsl:template>
    <xsl:template match="*" mode="insert.pagenumber.markup">
        <xsl:param name="purpose"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="pagenumber"/>

        <xsl:copy-of select="$pagenumber"/>
    </xsl:template>
    <xsl:template match="*" mode="insert.direction.markup">
        <xsl:param name="purpose"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="direction"/>

        <xsl:copy-of select="$direction"/>
    </xsl:template>
    <xsl:template match="*" mode="insert.olink.docname.markup">
        <xsl:param name="purpose"/>
        <xsl:param name="xrefstyle"/>
        <xsl:param name="docname"/>

        <span class="{$class.prefix}olinkdocname">
            <xsl:copy-of select="$docname"/>
        </span>

    </xsl:template>
    <xsl:param name="formal.object.break.after">1</xsl:param>
    <xsl:template name="formal.object">
        <xsl:param name="placement" select="'before'"/>
        <xsl:param name="class">
            <xsl:apply-templates select="." mode="class.value"/>
        </xsl:param>

        <xsl:call-template name="id.warning"/>

        <xsl:variable name="content">
            <div class="{$class.prefix}{$class}">
                <xsl:call-template name="id.attribute">
                    <xsl:with-param name="conditional" select="0"/>
                </xsl:call-template>
                <xsl:call-template name="anchor">
                    <xsl:with-param name="conditional" select="0"/>
                </xsl:call-template>

                <xsl:choose>
                    <xsl:when test="$placement = 'before'">
                        <xsl:call-template name="formal.object.heading"/>
                        <div class="{$class.prefix}{$class}-contents">
                            <xsl:apply-templates/>
                        </div>
                        <!-- HACK: This doesn't belong inside formal.object; it 
               should be done by the table template, but I want 
               the link to be inside the DIV, so... -->
                        <xsl:if test="local-name(.) = 'table'">
                            <xsl:call-template name="table.longdesc"/>
                        </xsl:if>

                        <xsl:if test="$spacing.paras != 0">
                            <p/>
                        </xsl:if>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:if test="$spacing.paras != 0">
                            <p/>
                        </xsl:if>
                        <div class="{$class.prefix}{$class}-contents">
                            <xsl:apply-templates/>
                        </div>
                        <!-- HACK: This doesn't belong inside formal.object; it 
               should be done by the table template, but I want 
               the link to be inside the DIV, so... -->
                        <xsl:if test="local-name(.) = 'table'">
                            <xsl:call-template name="table.longdesc"/>
                        </xsl:if>

                        <xsl:call-template name="formal.object.heading"/>
                    </xsl:otherwise>
                </xsl:choose>
            </div>
            <xsl:if test="not($formal.object.break.after = '0')">
                <br class="{$class.prefix}{$class}-break"/>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="floatstyle">
            <xsl:call-template name="floatstyle"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$floatstyle != ''">
                <xsl:call-template name="floater">
                    <xsl:with-param name="class"><xsl:value-of select="$class"/>-float
                    </xsl:with-param>
                    <xsl:with-param name="floatstyle" select="$floatstyle"/>
                    <xsl:with-param name="content" select="$content"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="$content"/>
            </xsl:otherwise>
        </xsl:choose>

    </xsl:template>
    <xsl:template name="formal.object.heading">
        <xsl:param name="object" select="."/>
        <xsl:param name="title">
            <xsl:apply-templates select="$object" mode="object.title.markup">
                <xsl:with-param name="allow-anchors" select="1"/>
            </xsl:apply-templates>
        </xsl:param>


        <xsl:choose>
            <xsl:when test="$make.clean.html != 0">
                <xsl:variable name="html.class" select="concat(local-name($object),'-title')"/>
                <div class="{$html.class}">
                    <xsl:copy-of select="$title"/>
                </div>
            </xsl:when>
            <xsl:otherwise>
                <p class="{$class.prefix}title">
                    <strong>
                        <xsl:copy-of select="$title"/>
                    </strong>
                </p>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="informal.object">
        <xsl:param name="class">
            <xsl:apply-templates select="." mode="class.value"/>
        </xsl:param>

        <xsl:variable name="content">
            <div class="{$class.prefix}{$class}">
                <xsl:call-template name="id.attribute"/>
                <xsl:if test="$spacing.paras != 0">
                    <p/>
                </xsl:if>
                <xsl:call-template name="anchor"/>
                <xsl:apply-templates/>

                <!-- HACK: This doesn't belong inside formal.object; it 
           should be done by the table template, but I want 
           the link to be inside the DIV, so... -->
                <xsl:if test="local-name(.) = 'informaltable'">
                    <xsl:call-template name="table.longdesc"/>
                </xsl:if>

                <xsl:if test="$spacing.paras != 0">
                    <p/>
                </xsl:if>
            </div>
        </xsl:variable>

        <xsl:variable name="floatstyle">
            <xsl:call-template name="floatstyle"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$floatstyle != ''">
                <xsl:call-template name="floater">
                    <xsl:with-param name="class"><xsl:value-of select="$class"/>-float
                    </xsl:with-param>
                    <xsl:with-param name="floatstyle" select="$floatstyle"/>
                    <xsl:with-param name="content" select="$content"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="$content"/>
            </xsl:otherwise>
        </xsl:choose>

    </xsl:template>
    <xsl:template name="semiformal.object">
        <xsl:param name="placement" select="'before'"/>
        <xsl:param name="class" select="local-name(.)"/>

        <xsl:choose>
            <xsl:when test="title or info/title">
                <xsl:call-template name="formal.object">
                    <xsl:with-param name="placement" select="$placement"/>
                    <xsl:with-param name="class" select="$class"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="informal.object">
                    <xsl:with-param name="class" select="$class"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="figure">
        <xsl:variable name="param.placement"
                      select="substring-after(normalize-space($formal.title.placement),                                         concat(local-name(.), ' '))"/>

        <xsl:variable name="placement">
            <xsl:choose>
                <xsl:when test="contains($param.placement, ' ')">
                    <xsl:value-of select="substring-before($param.placement, ' ')"/>
                </xsl:when>
                <xsl:when test="$param.placement = ''">before</xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$param.placement"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:call-template name="formal.object">
            <xsl:with-param name="placement" select="$placement"/>
        </xsl:call-template>

    </xsl:template>
    <xsl:template match="table">
        <xsl:choose>
            <xsl:when test="tgroup|mediaobject|graphic">
                <xsl:call-template name="calsTable"/>
            </xsl:when>
            <xsl:when test="caption">
                <xsl:call-template name="htmlTable.with.caption"/>
            </xsl:when>
            <xsl:otherwise>
                <!-- do not use xsl:copy because of XHTML's needs -->
                <div>
                    <xsl:call-template name="generate.class.attribute"/>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:call-template name="anchor"/>
                    <xsl:element name="table" namespace="http://www.w3.org/1999/xhtml">
                        <xsl:apply-templates select="@*" mode="htmlTableAtt"/>
                        <xsl:call-template name="htmlTable"/>
                    </xsl:element>
                </div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="htmlTable.with.caption">
        <xsl:param name="class">
            <xsl:apply-templates select="." mode="class.value"/>
        </xsl:param>

        <xsl:variable name="param.placement"
                      select="substring-after(normalize-space($formal.title.placement),                                         concat(local-name(.), ' '))"/>

        <xsl:variable name="placement">
            <xsl:choose>
                <xsl:when test="contains($param.placement, ' ')">
                    <xsl:value-of select="substring-before($param.placement, ' ')"/>
                </xsl:when>
                <xsl:when test="$param.placement = ''">before</xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$param.placement"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:call-template name="id.warning"/>

        <xsl:variable name="content">
            <div class="{$class.prefix}{$class}">
                <xsl:call-template name="id.attribute">
                    <xsl:with-param name="conditional" select="0"/>
                </xsl:call-template>
                <xsl:call-template name="anchor">
                    <xsl:with-param name="conditional" select="0"/>
                </xsl:call-template>

                <xsl:choose>
                    <xsl:when test="$placement = 'before'">

                        <xsl:call-template name="formal.object.heading"/>

                        <div class="{$class.prefix}{$class}-contents">
                            <xsl:apply-templates select="." mode="htmlTable"/>
                        </div>

                        <xsl:call-template name="table.longdesc"/>

                        <xsl:if test="$spacing.paras != 0">
                            <p/>
                        </xsl:if>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:if test="$spacing.paras != 0">
                            <p/>
                        </xsl:if>

                        <div class="{$class.prefix}{$class}-contents">
                            <xsl:apply-templates select="." mode="htmlTable"/>
                        </div>

                        <xsl:call-template name="table.longdesc"/>

                        <xsl:call-template name="formal.object.heading"/>
                    </xsl:otherwise>
                </xsl:choose>
            </div>
            <xsl:if test="not($formal.object.break.after = '0')">
                <br class="{$class.prefix}{$class}-break"/>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="floatstyle">
            <xsl:call-template name="floatstyle"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$floatstyle != ''">
                <xsl:call-template name="floater">
                    <xsl:with-param name="class"><xsl:value-of select="$class"/>-float
                    </xsl:with-param>
                    <xsl:with-param name="floatstyle" select="$floatstyle"/>
                    <xsl:with-param name="content" select="$content"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="$content"/>
            </xsl:otherwise>
        </xsl:choose>

    </xsl:template>
    <xsl:template name="calsTable">
        <xsl:if test="tgroup/tbody/tr                 |tgroup/thead/tr                 |tgroup/tfoot/tr">
            <xsl:message terminate="yes">Broken table: tr descendent of CALS Table.</xsl:message>
        </xsl:if>

        <xsl:variable name="param.placement"
                      select="substring-after(normalize-space($formal.title.placement),                                         concat(local-name(.), ' '))"/>

        <xsl:variable name="placement">
            <xsl:choose>
                <xsl:when test="contains($param.placement, ' ')">
                    <xsl:value-of select="substring-before($param.placement, ' ')"/>
                </xsl:when>
                <xsl:when test="$param.placement = ''">before</xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$param.placement"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:call-template name="formal.object">
            <xsl:with-param name="placement" select="$placement"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="table|informaltable" mode="class.value">
        <xsl:choose>
            <xsl:when test="@tabstyle">
                <xsl:value-of select="@tabstyle"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="local-name(.)"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="htmlTable">
        <xsl:if test="tgroup/tbody/row                 |tgroup/thead/row                 |tgroup/tfoot/row">
            <xsl:message terminate="yes">Broken table: row descendent of HTML table.</xsl:message>
        </xsl:if>

        <xsl:apply-templates mode="htmlTable"/>

        <xsl:if test=".//footnote|../title//footnote">
            <tbody class="{$class.prefix}footnotes">
                <tr>
                    <td colspan="50">
                        <xsl:apply-templates select=".//footnote|../title//footnote" mode="table.footnote.mode"/>
                    </td>
                </tr>
            </tbody>
        </xsl:if>
    </xsl:template>
    <xsl:template match="example">
        <xsl:variable name="param.placement"
                      select="substring-after(normalize-space($formal.title.placement),                      concat(local-name(.), ' '))"/>

        <xsl:variable name="placement">
            <xsl:choose>
                <xsl:when test="contains($param.placement, ' ')">
                    <xsl:value-of select="substring-before($param.placement, ' ')"/>
                </xsl:when>
                <xsl:when test="$param.placement = ''">before</xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$param.placement"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:call-template name="formal.object">
            <xsl:with-param name="placement" select="$placement"/>
        </xsl:call-template>

    </xsl:template>
    <xsl:template match="equation">
        <xsl:variable name="param.placement"
                      select="substring-after(normalize-space($formal.title.placement),                                       concat(local-name(.), ' '))"/>

        <xsl:variable name="placement">
            <xsl:choose>
                <xsl:when test="contains($param.placement, ' ')">
                    <xsl:value-of select="substring-before($param.placement, ' ')"/>
                </xsl:when>
                <xsl:when test="$param.placement = ''">before</xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$param.placement"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:call-template name="formal.object">
            <xsl:with-param name="placement" select="$placement"/>
        </xsl:call-template>

    </xsl:template>
    <xsl:template match="figure/title"/>
    <xsl:template match="figure/titleabbrev"/>
    <xsl:template match="table/title"/>
    <xsl:template match="table/titleabbrev"/>
    <xsl:template match="table/textobject"/>
    <xsl:template match="example/title"/>
    <xsl:template match="example/titleabbrev"/>
    <xsl:template match="equation/title"/>
    <xsl:template match="equation/titleabbrev"/>
    <xsl:template match="informalfigure">
        <xsl:call-template name="informal.object"/>
    </xsl:template>
    <xsl:template match="informalexample">
        <xsl:call-template name="informal.object"/>
    </xsl:template>
    <xsl:template match="informaltable">
        <xsl:choose>
            <xsl:when test="tgroup|mediaobject|graphic">
                <xsl:call-template name="informal.object"/>
            </xsl:when>
            <xsl:otherwise>
                <div>
                    <xsl:call-template name="generate.class.attribute"/>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:call-template name="anchor"/>
                    <xsl:element name="table" namespace="http://www.w3.org/1999/xhtml">
                        <xsl:apply-templates select="@*" mode="htmlTableAtt"/>
                        <xsl:call-template name="htmlTable"/>
                    </xsl:element>
                </div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="informaltable/textobject"/>
    <xsl:template name="table.longdesc">
        <!-- HACK: This doesn't belong inside formal.objectt; it should be done by -->
        <!-- the table template, but I want the link to be inside the DIV, so... -->
        <xsl:variable name="longdesc.uri">
            <xsl:call-template name="longdesc.uri">
                <xsl:with-param name="mediaobject" select="."/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="irrelevant">
            <!-- write.longdesc returns the filename ... -->
            <xsl:call-template name="write.longdesc">
                <xsl:with-param name="mediaobject" select="."/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:if test="$html.longdesc != 0 and $html.longdesc.link != 0                 and textobject[not(phrase)]">
            <xsl:call-template name="longdesc.link">
                <xsl:with-param name="longdesc.uri" select="$longdesc.uri"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template match="informalequation">
        <xsl:call-template name="informal.object"/>
    </xsl:template>
    <xsl:template name="floatstyle">
        <xsl:if test="(@float and @float != '0') or @floatstyle != ''">
            <xsl:choose>
                <xsl:when test="@floatstyle != ''">
                    <xsl:value-of select="@floatstyle"/>
                </xsl:when>
                <xsl:when test="@float = '1'">
                    <xsl:value-of select="$default.float.class"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="@float"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
    </xsl:template>
    <xsl:template name="floater">
        <xsl:param name="content"/>
        <xsl:param name="class" select="'float'"/>
        <xsl:param name="floatstyle" select="'left'"/>

        <div class="{$class.prefix}{$class}">
            <xsl:if test="$floatstyle = 'left' or $floatstyle = 'right'">
                <xsl:attribute name="style">
                    <xsl:text>float: </xsl:text>
                    <xsl:value-of select="$floatstyle"/>
                    <xsl:text>;</xsl:text>
                </xsl:attribute>
            </xsl:if>
            <xsl:copy-of select="$content"/>
        </div>
    </xsl:template>
    <xsl:template name="blank.spans">
        <xsl:param name="cols" select="1"/>
        <xsl:if test="$cols &gt; 0">
            <xsl:text>0:</xsl:text>
            <xsl:call-template name="blank.spans">
                <xsl:with-param name="cols" select="$cols - 1"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template name="calculate.following.spans">
        <xsl:param name="colspan" select="1"/>
        <xsl:param name="spans" select="''"/>

        <xsl:choose>
            <xsl:when test="$colspan &gt; 0">
                <xsl:call-template name="calculate.following.spans">
                    <xsl:with-param name="colspan" select="$colspan - 1"/>
                    <xsl:with-param name="spans" select="substring-after($spans,':')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$spans"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="finaltd">
        <xsl:param name="spans"/>
        <xsl:param name="col" select="0"/>

        <xsl:if test="$spans != ''">
            <xsl:choose>
                <xsl:when test="starts-with($spans,'0:')">
                    <xsl:call-template name="empty.table.cell">
                        <xsl:with-param name="colnum" select="$col"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise/>
            </xsl:choose>

            <xsl:call-template name="finaltd">
                <xsl:with-param name="spans" select="substring-after($spans,':')"/>
                <xsl:with-param name="col" select="$col+1"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template name="sfinaltd">
        <xsl:param name="spans"/>

        <xsl:if test="$spans != ''">
            <xsl:choose>
                <xsl:when test="starts-with($spans,'0:')">0:</xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="substring-before($spans,':')-1"/>
                    <xsl:text>:</xsl:text>
                </xsl:otherwise>
            </xsl:choose>

            <xsl:call-template name="sfinaltd">
                <xsl:with-param name="spans" select="substring-after($spans,':')"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template name="entry.colnum">
        <xsl:param name="entry" select="."/>

        <xsl:choose>
            <xsl:when test="$entry/@spanname">
                <xsl:variable name="spanname" select="$entry/@spanname"/>
                <xsl:variable name="spanspec"
                              select="($entry/ancestor::tgroup/spanspec[@spanname=$spanname]                              |$entry/ancestor::entrytbl/spanspec[@spanname=$spanname])[last()]"/>
                <xsl:variable name="colspec"
                              select="($entry/ancestor::tgroup/colspec[@colname=$spanspec/@namest]                              |$entry/ancestor::entrytbl/colspec[@colname=$spanspec/@namest])[last()]"/>
                <xsl:call-template name="colspec.colnum">
                    <xsl:with-param name="colspec" select="$colspec"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="$entry/@colname">
                <xsl:variable name="colname" select="$entry/@colname"/>
                <xsl:variable name="colspec"
                              select="($entry/ancestor::tgroup/colspec[@colname=$colname]                              |$entry/ancestor::entrytbl/colspec[@colname=$colname])[last()]"/>
                <xsl:call-template name="colspec.colnum">
                    <xsl:with-param name="colspec" select="$colspec"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="$entry/@namest">
                <xsl:variable name="namest" select="$entry/@namest"/>
                <xsl:variable name="colspec"
                              select="($entry/ancestor::tgroup/colspec[@colname=$namest]                              |$entry/ancestor::entrytbl/colspec[@colname=$namest])[last()]"/>
                <xsl:call-template name="colspec.colnum">
                    <xsl:with-param name="colspec" select="$colspec"/>
                </xsl:call-template>
            </xsl:when>
            <!-- no idea, return 0 -->
            <xsl:otherwise>0</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:template xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="entry.colnum">
        <refpurpose>Determine the column number in which a given entry occurs</refpurpose>
        <refdescription id="entry.colnum-desc">
            <para>If an
                <tag>entry</tag>
                has a
                <tag class="attribute">colname</tag>
                or
                <tag class="attribute">namest</tag>
                attribute, this template
                will determine the number of the column in which the entry should occur.
                For other<tag>entry</tag>s, nothing is returned.
            </para>
        </refdescription>
        <refparameter id="entry.colnum-params">
            <variablelist>
                <varlistentry>
                    <term>entry</term>
                    <listitem>
                        <para>The<tag>entry</tag>-element which is to be tested.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>

        <refreturn id="entry.colnum-returns">
            <para>This template returns the column number if it can be determined,
                or 0 (the empty string)
            </para>
        </refreturn>
    </doc:template>
    <xsl:template name="colspec.colnum">
        <xsl:param name="colspec" select="."/>
        <xsl:choose>
            <xsl:when test="$colspec/@colnum">
                <xsl:value-of select="$colspec/@colnum"/>
            </xsl:when>
            <xsl:when test="$colspec/preceding-sibling::colspec">
                <xsl:variable name="prec.colspec.colnum">
                    <xsl:call-template name="colspec.colnum">
                        <xsl:with-param name="colspec" select="$colspec/preceding-sibling::colspec[1]"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:value-of select="$prec.colspec.colnum + 1"/>
            </xsl:when>
            <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="calculate.colspan">
        <xsl:param name="entry" select="."/>
        <xsl:variable name="spanname" select="$entry/@spanname"/>
        <xsl:variable name="spanspec"
                      select="($entry/ancestor::tgroup/spanspec[@spanname=$spanname]                          |$entry/ancestor::entrytbl/spanspec[@spanname=$spanname])[last()]"/>

        <xsl:variable name="namest">
            <xsl:choose>
                <xsl:when test="@spanname">
                    <xsl:value-of select="$spanspec/@namest"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$entry/@namest"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="nameend">
            <xsl:choose>
                <xsl:when test="@spanname">
                    <xsl:value-of select="$spanspec/@nameend"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$entry/@nameend"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="scol">
            <xsl:call-template name="colspec.colnum">
                <xsl:with-param name="colspec"
                                select="($entry/ancestor::tgroup/colspec[@colname=$namest]                                |$entry/ancestor::entrytbl/colspec[@colname=$namest])[last()]"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="ecol">
            <xsl:call-template name="colspec.colnum">
                <xsl:with-param name="colspec"
                                select="($entry/ancestor::tgroup/colspec[@colname=$nameend]                                |$entry/ancestor::entrytbl/colspec[@colname=$nameend])[last()]"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$namest != '' and $nameend != ''">
                <xsl:choose>
                    <xsl:when test="number($ecol) &gt;= number($scol)">
                        <xsl:value-of select="number($ecol) - number($scol) + 1"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="number($scol) - number($ecol) + 1"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>1</xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="calculate.rowsep">
        <xsl:param name="entry" select="."/>
        <xsl:param name="colnum" select="0"/>

        <xsl:call-template name="inherited.table.attribute">
            <xsl:with-param name="entry" select="$entry"/>
            <xsl:with-param name="colnum" select="$colnum"/>
            <xsl:with-param name="attribute" select="'rowsep'"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="calculate.colsep">
        <xsl:param name="entry" select="."/>
        <xsl:param name="colnum" select="0"/>

        <xsl:call-template name="inherited.table.attribute">
            <xsl:with-param name="entry" select="$entry"/>
            <xsl:with-param name="colnum" select="$colnum"/>
            <xsl:with-param name="attribute" select="'colsep'"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="inherited.table.attribute">
        <xsl:param name="entry" select="."/>
        <xsl:param name="row" select="$entry/ancestor-or-self::row[1]"/>
        <xsl:param name="colnum" select="0"/>
        <xsl:param name="attribute" select="'colsep'"/>

        <xsl:variable name="tgroup" select="$row/parent::*/parent::tgroup[1]"/>
        <xsl:variable name="tbody" select="$row/parent::*[1]"/>

        <xsl:variable name="table"
                      select="($tgroup/ancestor::table                                      |$tgroup/ancestor::informaltable                                      |$entry/ancestor::entrytbl)[last()]"/>

        <xsl:variable name="entry.value">
            <xsl:call-template name="get-attribute">
                <xsl:with-param name="element" select="$entry"/>
                <xsl:with-param name="attribute" select="$attribute"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="row.value">
            <xsl:call-template name="get-attribute">
                <xsl:with-param name="element" select="$row"/>
                <xsl:with-param name="attribute" select="$attribute"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="span.value">
            <xsl:if test="$entry/@spanname">
                <xsl:variable name="spanname" select="$entry/@spanname"/>
                <xsl:variable name="spanspec" select="$tgroup/spanspec[@spanname=$spanname]"/>
                <xsl:variable name="span.colspec" select="$tgroup/colspec[@colname=$spanspec/@namest]"/>

                <xsl:variable name="spanspec.value">
                    <xsl:call-template name="get-attribute">
                        <xsl:with-param name="element" select="$spanspec"/>
                        <xsl:with-param name="attribute" select="$attribute"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="scolspec.value">
                    <xsl:call-template name="get-attribute">
                        <xsl:with-param name="element" select="$span.colspec"/>
                        <xsl:with-param name="attribute" select="$attribute"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:choose>
                    <xsl:when test="$spanspec.value != ''">
                        <xsl:value-of select="$spanspec.value"/>
                    </xsl:when>
                    <xsl:when test="$scolspec.value != ''">
                        <xsl:value-of select="$scolspec.value"/>
                    </xsl:when>
                    <xsl:otherwise/>
                </xsl:choose>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="namest.value">
            <xsl:if test="$entry/@namest">
                <xsl:variable name="namest" select="$entry/@namest"/>
                <xsl:variable name="colspec" select="$tgroup/colspec[@colname=$namest]"/>

                <xsl:variable name="inner.namest.value">
                    <xsl:call-template name="get-attribute">
                        <xsl:with-param name="element" select="$colspec"/>
                        <xsl:with-param name="attribute" select="$attribute"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:choose>
                    <xsl:when test="$inner.namest.value">
                        <xsl:value-of select="$inner.namest.value"/>
                    </xsl:when>
                    <xsl:otherwise/>
                </xsl:choose>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="tgroup.value">
            <xsl:call-template name="get-attribute">
                <xsl:with-param name="element" select="$tgroup"/>
                <xsl:with-param name="attribute" select="$attribute"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="tbody.value">
            <xsl:call-template name="get-attribute">
                <xsl:with-param name="element" select="$tbody"/>
                <xsl:with-param name="attribute" select="$attribute"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="table.value">
            <xsl:call-template name="get-attribute">
                <xsl:with-param name="element" select="$table"/>
                <xsl:with-param name="attribute" select="$attribute"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="default.value">
            <!-- This section used to say that rowsep and colsep have defaults based -->
            <!-- on the frame setting. Further reflection and closer examination of the -->
            <!-- CALS spec reveals I was mistaken. The default is "1" for rowsep and colsep. -->
            <!-- For everything else, the default is the tgroup value -->
            <xsl:choose>
                <xsl:when test="$tgroup.value != ''">
                    <xsl:value-of select="$tgroup.value"/>
                </xsl:when>
                <xsl:when test="$attribute = 'rowsep'">1</xsl:when>
                <xsl:when test="$attribute = 'colsep'">1</xsl:when>
                <xsl:otherwise><!-- empty --></xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="calc.colvalue">
            <xsl:if test="$colnum &gt; 0">
                <xsl:call-template name="colnum.colspec">
                    <xsl:with-param name="colnum" select="$colnum"/>
                    <xsl:with-param name="attribute" select="$attribute"/>
                </xsl:call-template>
            </xsl:if>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$entry.value != ''">
                <xsl:value-of select="$entry.value"/>
            </xsl:when>
            <xsl:when test="$row.value != ''">
                <xsl:value-of select="$row.value"/>
            </xsl:when>
            <xsl:when test="$span.value != ''">
                <xsl:value-of select="$span.value"/>
            </xsl:when>
            <xsl:when test="$namest.value != ''">
                <xsl:value-of select="$namest.value"/>
            </xsl:when>
            <xsl:when test="$calc.colvalue != ''">
                <xsl:value-of select="$calc.colvalue"/>
            </xsl:when>
            <xsl:when test="$tbody.value != ''">
                <xsl:value-of select="$tbody.value"/>
            </xsl:when>
            <xsl:when test="$tgroup.value != ''">
                <xsl:value-of select="$tgroup.value"/>
            </xsl:when>
            <xsl:when test="$table.value != ''">
                <xsl:value-of select="$table.value"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$default.value"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="colnum.colspec">
        <xsl:param name="colnum" select="0"/>
        <xsl:param name="attribute" select="'colname'"/>
        <xsl:param name="colspec.ancestor"
                   select="(ancestor::tgroup|ancestor::entrytbl)                      [position() = last()]"/>
        <xsl:param name="colspecs" select="$colspec.ancestor/colspec"/>
        <xsl:param name="count" select="1"/>

        <xsl:choose>
            <xsl:when test="not($colspecs) or $count &gt; $colnum">
                <!-- nop -->
            </xsl:when>
            <xsl:when test="$colspecs[1]/@colnum">
                <xsl:choose>
                    <xsl:when test="$colspecs[1]/@colnum = $colnum">
                        <xsl:call-template name="get-attribute">
                            <xsl:with-param name="element" select="$colspecs[1]"/>
                            <xsl:with-param name="attribute" select="$attribute"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="colnum.colspec">
                            <xsl:with-param name="colnum" select="$colnum"/>
                            <xsl:with-param name="attribute" select="$attribute"/>
                            <xsl:with-param name="colspecs" select="$colspecs[position()&gt;1]"/>
                            <xsl:with-param name="count" select="$colspecs[1]/@colnum+1"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="$count = $colnum">
                        <xsl:call-template name="get-attribute">
                            <xsl:with-param name="element" select="$colspecs[1]"/>
                            <xsl:with-param name="attribute" select="$attribute"/>
                        </xsl:call-template>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="colnum.colspec">
                            <xsl:with-param name="colnum" select="$colnum"/>
                            <xsl:with-param name="attribute" select="$attribute"/>
                            <xsl:with-param name="colspecs" select="$colspecs[position()&gt;1]"/>
                            <xsl:with-param name="count" select="$count+1"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="get-attribute">
        <xsl:param name="element" select="."/>
        <xsl:param name="attribute" select="''"/>

        <xsl:for-each select="$element/@*">
            <xsl:if test="local-name(.) = $attribute">
                <xsl:value-of select="."/>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>
    <xsl:template name="consume-row">
        <xsl:param name="spans"/>

        <xsl:if test="contains($spans,':')">
            <xsl:value-of select="substring-before($spans,':') - 1"/>
            <xsl:text>:</xsl:text>
            <xsl:call-template name="consume-row">
                <xsl:with-param name="spans" select="substring-after($spans,':')"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template name="tabstyle">
        <xsl:param name="node" select="."/>

        <xsl:variable name="tgroup"
                      select="$node/tgroup[1] |                                        $node/ancestor-or-self::tgroup[1]"/>

        <xsl:variable name="table"
                      select="($node/ancestor-or-self::table |                           $node/ancestor-or-self::informaltable)[last()]"/>

        <xsl:variable name="tabstyle">
            <xsl:choose>
                <xsl:when test="$table/@tabstyle != ''">
                    <xsl:value-of select="normalize-space($table/@tabstyle)"/>
                </xsl:when>
                <xsl:when test="$tgroup/@tgroupstyle != ''">
                    <xsl:value-of select="normalize-space($tgroup/@tgroupstyle)"/>
                </xsl:when>
                <xsl:otherwise>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:value-of select="$tabstyle"/>
    </xsl:template>
    <lxslt:component xmlns:lxslt="http://xml.apache.org/xslt" prefix="xtbl" functions="adjustColumnWidths"/>
    <xsl:template name="empty.table.cell">
        <xsl:param name="colnum" select="0"/>

        <xsl:variable name="rowsep">
            <xsl:choose>
                <!-- If this is the last row, rowsep never applies. -->
                <xsl:when
                        test="not(ancestor-or-self::row[1]/following-sibling::row                           or ancestor-or-self::thead/following-sibling::tbody                           or ancestor-or-self::tbody/preceding-sibling::tfoot)">
                    <xsl:value-of select="0"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="inherited.table.attribute">
                        <xsl:with-param name="entry" select="NOT-AN-ELEMENT-NAME"/>
                        <xsl:with-param name="row" select="ancestor-or-self::row[1]"/>
                        <xsl:with-param name="colnum" select="$colnum"/>
                        <xsl:with-param name="attribute" select="'rowsep'"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="colsep">
            <xsl:choose>
                <!-- If this is the last column, colsep never applies. -->
                <xsl:when test="number($colnum) &gt;= ancestor::tgroup/@cols">0</xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="inherited.table.attribute">
                        <xsl:with-param name="entry" select="NOT-AN-ELEMENT-NAME"/>
                        <xsl:with-param name="row" select="ancestor-or-self::row[1]"/>
                        <xsl:with-param name="colnum" select="$colnum"/>
                        <xsl:with-param name="attribute" select="'colsep'"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <td class="{$class.prefix}auto-generated">
            <xsl:if test="$table.borders.with.css != 0">
                <xsl:attribute name="style">
                    <xsl:if test="$colsep &gt; 0">
                        <xsl:call-template name="border">
                            <xsl:with-param name="side" select="'right'"/>
                        </xsl:call-template>
                    </xsl:if>
                    <xsl:if test="$rowsep &gt; 0">
                        <xsl:call-template name="border">
                            <xsl:with-param name="side" select="'bottom'"/>
                        </xsl:call-template>
                    </xsl:if>
                </xsl:attribute>
            </xsl:if>
            <xsl:text> </xsl:text>
        </td>
    </xsl:template>
    <xsl:template name="border">
        <xsl:param name="side" select="'left'"/>
        <xsl:param name="padding" select="0"/>
        <xsl:param name="style" select="$table.cell.border.style"/>
        <xsl:param name="color" select="$table.cell.border.color"/>
        <xsl:param name="thickness" select="$table.cell.border.thickness"/>

        <!-- Note: Some browsers (mozilla) require at least a width and style. -->

        <xsl:choose>
            <xsl:when
                    test="($thickness != ''                      and $style != ''                      and $color != '')                     or ($thickness != ''                         and $style != '')                     or ($thickness != '')">
                <!-- use the compound property if we can: -->
                <!-- it saves space and probably works more reliably -->
                <xsl:text>border-</xsl:text>
                <xsl:value-of select="$side"/>
                <xsl:text>: </xsl:text>
                <xsl:value-of select="$thickness"/>
                <xsl:text> </xsl:text>
                <xsl:value-of select="$style"/>
                <xsl:text> </xsl:text>
                <xsl:value-of select="$color"/>
                <xsl:text>; </xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <!-- we need to specify the styles individually -->
                <xsl:if test="$thickness != ''">
                    <xsl:text>border-</xsl:text>
                    <xsl:value-of select="$side"/>
                    <xsl:text>-width: </xsl:text>
                    <xsl:value-of select="$thickness"/>
                    <xsl:text>; </xsl:text>
                </xsl:if>

                <xsl:if test="$style != ''">
                    <xsl:text>border-</xsl:text>
                    <xsl:value-of select="$side"/>
                    <xsl:text>-style: </xsl:text>
                    <xsl:value-of select="$style"/>
                    <xsl:text>; </xsl:text>
                </xsl:if>

                <xsl:if test="$color != ''">
                    <xsl:text>border-</xsl:text>
                    <xsl:value-of select="$side"/>
                    <xsl:text>-color: </xsl:text>
                    <xsl:value-of select="$color"/>
                    <xsl:text>; </xsl:text>
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="tgroup/processing-instruction('dbhtml')">
        <xsl:variable name="summary">
            <xsl:call-template name="pi.dbhtml_table-summary"/>
        </xsl:variable>

        <!-- Suppress the table-summary PI -->
        <xsl:if test="$summary = ''">
            <xsl:processing-instruction name="dbhtml">
                <xsl:value-of select="."/>
            </xsl:processing-instruction>
        </xsl:if>
    </xsl:template>
    <xsl:template match="colspec"/>
    <xsl:template match="spanspec"/>
    <xsl:template match="thead|tfoot">
        <xsl:element name="{local-name(.)}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:if test="@align">
                <xsl:attribute name="align">
                    <xsl:value-of select="@align"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="@char">
                <xsl:attribute name="char">
                    <xsl:value-of select="@char"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="@charoff">
                <xsl:attribute name="charoff">
                    <xsl:value-of select="@charoff"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="@valign">
                <xsl:attribute name="valign">
                    <xsl:value-of select="@valign"/>
                </xsl:attribute>
            </xsl:if>

            <xsl:choose>
                <!-- recurse on rows only if @morerows is present -->
                <xsl:when test="row/entry/@morerows|row/entrytbl/@morerows">
                    <xsl:apply-templates select="row[1]">
                        <xsl:with-param name="spans">
                            <xsl:call-template name="blank.spans">
                                <xsl:with-param name="cols" select="../@cols"/>
                            </xsl:call-template>
                        </xsl:with-param>
                        <xsl:with-param name="browserows" select="'recurse'"/>
                    </xsl:apply-templates>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates select="row">
                        <xsl:with-param name="spans">
                            <xsl:call-template name="blank.spans">
                                <xsl:with-param name="cols" select="../@cols"/>
                            </xsl:call-template>
                        </xsl:with-param>
                        <xsl:with-param name="browserows" select="'loop'"/>
                    </xsl:apply-templates>
                </xsl:otherwise>
            </xsl:choose>

        </xsl:element>
    </xsl:template>
    <xsl:template match="tbody">
        <tbody>
            <xsl:if test="@align">
                <xsl:attribute name="align">
                    <xsl:value-of select="@align"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="@char">
                <xsl:attribute name="char">
                    <xsl:value-of select="@char"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="@charoff">
                <xsl:attribute name="charoff">
                    <xsl:value-of select="@charoff"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="@valign">
                <xsl:attribute name="valign">
                    <xsl:value-of select="@valign"/>
                </xsl:attribute>
            </xsl:if>

            <xsl:choose>
                <xsl:when test="row/entry/@morerows|row/entrytbl/@morerows">
                    <xsl:apply-templates select="row[1]">
                        <xsl:with-param name="spans">
                            <xsl:call-template name="blank.spans">
                                <xsl:with-param name="cols" select="../@cols"/>
                            </xsl:call-template>
                        </xsl:with-param>
                        <xsl:with-param name="browserows" select="'recurse'"/>
                    </xsl:apply-templates>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates select="row">
                        <xsl:with-param name="spans">
                            <xsl:call-template name="blank.spans">
                                <xsl:with-param name="cols" select="../@cols"/>
                            </xsl:call-template>
                        </xsl:with-param>
                        <xsl:with-param name="browserows" select="'loop'"/>
                    </xsl:apply-templates>
                </xsl:otherwise>
            </xsl:choose>

        </tbody>
    </xsl:template>
    <xsl:template match="row">
        <xsl:param name="spans"/>
        <xsl:param name="browserows"/>

        <xsl:choose>
            <xsl:when test="contains($spans, '0')">
                <xsl:call-template name="normal-row">
                    <xsl:with-param name="spans" select="$spans"/>
                    <xsl:with-param name="browserows" select="$browserows"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <!--
      <xsl:message>
        <xsl:text>Ignoring row: </xsl:text>
        <xsl:value-of select="$spans"/>
        <xsl:text> = </xsl:text>
        <xsl:call-template name="consume-row">
          <xsl:with-param name="spans" select="$spans"/>
        </xsl:call-template>
      </xsl:message>
      -->

                <xsl:if test="normalize-space(.//text()) != ''">
                    <xsl:message>Warning: overlapped row contains content!</xsl:message>
                </xsl:if>

                <tr>
                    <xsl:comment>This row intentionally left blank</xsl:comment>
                </tr>

                <xsl:if test="$browserows = 'recurse'">
                    <xsl:apply-templates select="following-sibling::row[1]">
                        <xsl:with-param name="spans">
                            <xsl:call-template name="consume-row">
                                <xsl:with-param name="spans" select="$spans"/>
                            </xsl:call-template>
                        </xsl:with-param>
                        <xsl:with-param name="browserows" select="$browserows"/>
                    </xsl:apply-templates>
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="normal-row">
        <xsl:param name="spans"/>
        <xsl:param name="browserows"/>

        <xsl:variable name="row-height">
            <xsl:if test="processing-instruction('dbhtml')">
                <xsl:call-template name="pi.dbhtml_row-height"/>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="bgcolor">
            <xsl:if test="processing-instruction('dbhtml')">
                <xsl:call-template name="pi.dbhtml_bgcolor"/>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="class">
            <xsl:if test="processing-instruction('dbhtml')">
                <xsl:call-template name="pi.dbhtml_class"/>
            </xsl:if>
        </xsl:variable>

        <tr>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="tr.attributes">
                <xsl:with-param name="rownum">
                    <xsl:number from="tgroup" count="row"/>
                </xsl:with-param>
            </xsl:call-template>

            <xsl:if test="$row-height != ''">
                <xsl:attribute name="height">
                    <xsl:value-of select="$row-height"/>
                </xsl:attribute>
            </xsl:if>

            <xsl:if test="$bgcolor != ''">
                <xsl:attribute name="bgcolor">
                    <xsl:value-of select="$bgcolor"/>
                </xsl:attribute>
            </xsl:if>

            <xsl:if test="$class != ''">
                <xsl:attribute name="class">
                    <xsl:value-of select="$class.prefix"/>
                    <xsl:value-of select="$class"/>
                </xsl:attribute>
            </xsl:if>

            <xsl:if test="$table.borders.with.css != 0">
                <xsl:if test="@rowsep = 1 and following-sibling::row">
                    <xsl:attribute name="style">
                        <xsl:call-template name="border">
                            <xsl:with-param name="side" select="'bottom'"/>
                        </xsl:call-template>
                    </xsl:attribute>
                </xsl:if>
            </xsl:if>

            <xsl:if test="@align">
                <xsl:attribute name="align">
                    <xsl:value-of select="@align"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="@char">
                <xsl:attribute name="char">
                    <xsl:value-of select="@char"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="@charoff">
                <xsl:attribute name="charoff">
                    <xsl:value-of select="@charoff"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="@valign">
                <xsl:attribute name="valign">
                    <xsl:value-of select="@valign"/>
                </xsl:attribute>
            </xsl:if>

            <xsl:apply-templates select="(entry|entrytbl)[1]">
                <xsl:with-param name="spans" select="$spans"/>
            </xsl:apply-templates>
        </tr>

        <xsl:if test="$browserows = 'recurse'">
            <xsl:if test="following-sibling::row">
                <xsl:variable name="nextspans">
                    <xsl:apply-templates select="(entry|entrytbl)[1]" mode="span">
                        <xsl:with-param name="spans" select="$spans"/>
                    </xsl:apply-templates>
                </xsl:variable>

                <xsl:apply-templates select="following-sibling::row[1]">
                    <xsl:with-param name="spans" select="$nextspans"/>
                    <xsl:with-param name="browserows" select="$browserows"/>
                </xsl:apply-templates>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    <xsl:template match="entry|entrytbl" name="entry">
        <xsl:param name="col">
            <xsl:choose>
                <xsl:when test="@revisionflag">
                    <xsl:number from="row"/>
                </xsl:when>
                <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
        </xsl:param>

        <xsl:param name="spans"/>

        <xsl:variable name="cellgi">
            <xsl:choose>
                <xsl:when test="ancestor::thead">th</xsl:when>
                <xsl:when test="ancestor::tfoot">th</xsl:when>
                <xsl:when
                        test="ancestor::tbody and                        (ancestor::table[@rowheader = 'firstcol'] or                       ancestor::informaltable[@rowheader = 'firstcol']) and                       ancestor-or-self::entry[1][count(preceding-sibling::entry) = 0]">
                    <xsl:text>th</xsl:text>
                </xsl:when>
                <xsl:otherwise>td</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="empty.cell" select="count(node()) = 0"/>

        <xsl:variable name="named.colnum">
            <xsl:call-template name="entry.colnum"/>
        </xsl:variable>

        <xsl:variable name="entry.colnum">
            <xsl:choose>
                <xsl:when test="$named.colnum &gt; 0">
                    <xsl:value-of select="$named.colnum"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$col"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="entry.colspan">
            <xsl:choose>
                <xsl:when test="@spanname or @namest">
                    <xsl:call-template name="calculate.colspan"/>
                </xsl:when>
                <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="following.spans">
            <xsl:call-template name="calculate.following.spans">
                <xsl:with-param name="colspan" select="$entry.colspan"/>
                <xsl:with-param name="spans" select="$spans"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="rowsep">
            <xsl:choose>
                <!-- If this is the last row, rowsep never applies. -->
                <xsl:when
                        test="ancestor::entrytbl                       and not (ancestor-or-self::row[1]/following-sibling::row)                       and not (ancestor::thead)">
                    <xsl:value-of select="0"/>
                </xsl:when>
                <xsl:when
                        test="not(ancestor-or-self::row[1]/following-sibling::row                           or ancestor-or-self::thead/following-sibling::tbody                           or ancestor-or-self::tbody/preceding-sibling::tfoot)">
                    <xsl:value-of select="0"/>
                </xsl:when>
                <xsl:when
                        test="@morerows and not(@morerows &lt;                   count(ancestor-or-self::row[1]/following-sibling::row))">
                    <xsl:value-of select="0"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="inherited.table.attribute">
                        <xsl:with-param name="entry" select="."/>
                        <xsl:with-param name="colnum" select="$entry.colnum"/>
                        <xsl:with-param name="attribute" select="'rowsep'"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="colsep">
            <xsl:choose>
                <!-- If this is the last column, colsep never applies. -->
                <xsl:when test="$following.spans = ''">0</xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="inherited.table.attribute">
                        <xsl:with-param name="entry" select="."/>
                        <xsl:with-param name="colnum" select="$entry.colnum"/>
                        <xsl:with-param name="attribute" select="'colsep'"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="valign">
            <xsl:call-template name="inherited.table.attribute">
                <xsl:with-param name="entry" select="."/>
                <xsl:with-param name="colnum" select="$entry.colnum"/>
                <xsl:with-param name="attribute" select="'valign'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="align">
            <xsl:call-template name="inherited.table.attribute">
                <xsl:with-param name="entry" select="."/>
                <xsl:with-param name="colnum" select="$entry.colnum"/>
                <xsl:with-param name="attribute" select="'align'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="char">
            <xsl:call-template name="inherited.table.attribute">
                <xsl:with-param name="entry" select="."/>
                <xsl:with-param name="colnum" select="$entry.colnum"/>
                <xsl:with-param name="attribute" select="'char'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="charoff">
            <xsl:call-template name="inherited.table.attribute">
                <xsl:with-param name="entry" select="."/>
                <xsl:with-param name="colnum" select="$entry.colnum"/>
                <xsl:with-param name="attribute" select="'charoff'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$spans != '' and not(starts-with($spans,'0:'))">
                <xsl:call-template name="entry">
                    <xsl:with-param name="col" select="$col+1"/>
                    <xsl:with-param name="spans" select="substring-after($spans,':')"/>
                </xsl:call-template>
            </xsl:when>

            <xsl:when test="number($entry.colnum) &gt; $col">
                <xsl:call-template name="empty.table.cell"/>
                <xsl:call-template name="entry">
                    <xsl:with-param name="col" select="$col+1"/>
                    <xsl:with-param name="spans" select="substring-after($spans,':')"/>
                </xsl:call-template>
            </xsl:when>

            <xsl:otherwise>
                <xsl:variable name="bgcolor">
                    <xsl:if test="processing-instruction('dbhtml')">
                        <xsl:call-template name="pi.dbhtml_bgcolor"/>
                    </xsl:if>
                </xsl:variable>

                <xsl:element name="{$cellgi}" namespace="http://www.w3.org/1999/xhtml">
                    <xsl:call-template name="id.attribute"/>
                    <xsl:if test="$bgcolor != ''">
                        <xsl:attribute name="bgcolor">
                            <xsl:value-of select="$bgcolor"/>
                        </xsl:attribute>
                    </xsl:if>

                    <xsl:call-template name="locale.html.attributes"/>
                    <xsl:choose>
                        <xsl:when test="$entry.propagates.style != 0 and @role">
                            <xsl:apply-templates select="." mode="class.attribute">
                                <xsl:with-param name="class" select="@role"/>
                            </xsl:apply-templates>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:apply-templates select="." mode="class.attribute">
                                <xsl:with-param name="class" select="''"/>
                            </xsl:apply-templates>
                        </xsl:otherwise>
                    </xsl:choose>

                    <xsl:if test="$show.revisionflag and @revisionflag">
                        <xsl:attribute name="class">
                            <xsl:value-of select="$class.prefix"/>
                            <xsl:value-of select="@revisionflag"/>
                        </xsl:attribute>
                    </xsl:if>

                    <xsl:if test="$table.borders.with.css != 0">
                        <xsl:attribute name="style">
                            <xsl:if test="$colsep &gt; 0">
                                <xsl:call-template name="border">
                                    <xsl:with-param name="side" select="'right'"/>
                                </xsl:call-template>
                            </xsl:if>
                            <xsl:if test="$rowsep &gt; 0">
                                <xsl:call-template name="border">
                                    <xsl:with-param name="side" select="'bottom'"/>
                                </xsl:call-template>
                            </xsl:if>
                        </xsl:attribute>
                    </xsl:if>

                    <xsl:if test="@morerows &gt; 0">
                        <xsl:attribute name="rowspan">
                            <xsl:value-of select="1+@morerows"/>
                        </xsl:attribute>
                    </xsl:if>

                    <xsl:if test="$entry.colspan &gt; 1">
                        <xsl:attribute name="colspan">
                            <xsl:value-of select="$entry.colspan"/>
                        </xsl:attribute>
                    </xsl:if>

                    <xsl:if test="$align != ''">
                        <xsl:attribute name="align">
                            <xsl:value-of select="$align"/>
                        </xsl:attribute>
                    </xsl:if>

                    <xsl:if test="$valign != ''">
                        <xsl:attribute name="valign">
                            <xsl:value-of select="$valign"/>
                        </xsl:attribute>
                    </xsl:if>

                    <xsl:if test="$char != ''">
                        <xsl:attribute name="char">
                            <xsl:value-of select="$char"/>
                        </xsl:attribute>
                    </xsl:if>

                    <xsl:if test="$charoff != ''">
                        <xsl:attribute name="charoff">
                            <xsl:value-of select="$charoff"/>
                        </xsl:attribute>
                    </xsl:if>

                    <xsl:if test="not(preceding-sibling::*) and                      (ancestor::row[1]/@id or ancestor::row[1]/@xml:id)">
                        <xsl:call-template name="anchor">
                            <xsl:with-param name="node" select="ancestor::row[1]"/>
                        </xsl:call-template>
                    </xsl:if>

                    <xsl:call-template name="anchor"/>

                    <xsl:choose>
                        <xsl:when test="$empty.cell">
                            <xsl:text> </xsl:text>
                        </xsl:when>
                        <xsl:when test="self::entrytbl">
                            <xsl:call-template name="tgroup"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:apply-templates/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:element>

                <xsl:choose>
                    <xsl:when test="following-sibling::entry|following-sibling::entrytbl">
                        <xsl:apply-templates
                                select="(following-sibling::entry                                        |following-sibling::entrytbl)[1]">
                            <xsl:with-param name="col" select="$col+$entry.colspan"/>
                            <xsl:with-param name="spans" select="$following.spans"/>
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="finaltd">
                            <xsl:with-param name="spans" select="$following.spans"/>
                            <xsl:with-param name="col" select="$col+$entry.colspan"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="entry|entrytbl" name="sentry" mode="span">
        <xsl:param name="col" select="1"/>
        <xsl:param name="spans"/>

        <xsl:variable name="entry.colnum">
            <xsl:call-template name="entry.colnum"/>
        </xsl:variable>

        <xsl:variable name="entry.colspan">
            <xsl:choose>
                <xsl:when test="@spanname or @namest">
                    <xsl:call-template name="calculate.colspan"/>
                </xsl:when>
                <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="following.spans">
            <xsl:call-template name="calculate.following.spans">
                <xsl:with-param name="colspan" select="$entry.colspan"/>
                <xsl:with-param name="spans" select="$spans"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$spans != '' and not(starts-with($spans,'0:'))">
                <xsl:value-of select="substring-before($spans,':')-1"/>
                <xsl:text>:</xsl:text>
                <xsl:call-template name="sentry">
                    <xsl:with-param name="col" select="$col+1"/>
                    <xsl:with-param name="spans" select="substring-after($spans,':')"/>
                </xsl:call-template>
            </xsl:when>

            <xsl:when test="number($entry.colnum) &gt; $col">
                <xsl:text>0:</xsl:text>
                <xsl:call-template name="sentry">
                    <xsl:with-param name="col" select="$col + 1"/>
                    <xsl:with-param name="spans" select="substring-after($spans,':')"/>
                </xsl:call-template>
            </xsl:when>

            <xsl:otherwise>
                <xsl:call-template name="copy-string">
                    <xsl:with-param name="count" select="$entry.colspan"/>
                    <xsl:with-param name="string">
                        <xsl:choose>
                            <xsl:when test="@morerows">
                                <xsl:value-of select="@morerows"/>
                            </xsl:when>
                            <xsl:otherwise>0</xsl:otherwise>
                        </xsl:choose>
                        <xsl:text>:</xsl:text>
                    </xsl:with-param>
                </xsl:call-template>

                <xsl:choose>
                    <xsl:when test="following-sibling::entry|following-sibling::entrytbl">
                        <xsl:apply-templates
                                select="(following-sibling::entry                                         |following-sibling::entrytbl)[1]"
                                mode="span">
                            <xsl:with-param name="col" select="$col+$entry.colspan"/>
                            <xsl:with-param name="spans" select="$following.spans"/>
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="sfinaltd">
                            <xsl:with-param name="spans" select="$following.spans"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="generate.colgroup">
        <xsl:param name="cols" select="1"/>
        <xsl:param name="count" select="1"/>
        <xsl:choose>
            <xsl:when test="$count &gt; $cols"/>
            <xsl:otherwise>
                <xsl:call-template name="generate.col">
                    <xsl:with-param name="countcol" select="$count"/>
                </xsl:call-template>
                <xsl:call-template name="generate.colgroup">
                    <xsl:with-param name="cols" select="$cols"/>
                    <xsl:with-param name="count" select="$count+1"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="generate.col">
        <xsl:param name="countcol">1</xsl:param>
        <xsl:param name="colspecs" select="./colspec"/>
        <xsl:param name="count">1</xsl:param>
        <xsl:param name="colnum">1</xsl:param>

        <xsl:choose>
            <xsl:when test="$count&gt;count($colspecs)">
                <col/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="colspec" select="$colspecs[$count=position()]"/>
                <xsl:variable name="colspec.colnum">
                    <xsl:choose>
                        <xsl:when test="$colspec/@colnum">
                            <xsl:value-of select="$colspec/@colnum"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$colnum"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>

                <xsl:choose>
                    <xsl:when test="$colspec.colnum=$countcol">
                        <col>
                            <xsl:choose>
                                <xsl:when
                                        test="$colspec/@colwidth                             and $use.extensions != 0                             and $tablecolumns.extension != 0">
                                    <xsl:attribute name="width">
                                        <xsl:choose>
                                            <xsl:when test="normalize-space($colspec/@colwidth) = '*'">
                                                <xsl:value-of select="'1*'"/>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:value-of select="$colspec/@colwidth"/>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                    </xsl:attribute>
                                </xsl:when>
                                <!-- pass through to HTML if no * in colspecs -->
                                <xsl:when
                                        test="$colspec/@colwidth and                              not($colspec/parent::*/colspec/@colwidth[contains(.,'*')])">
                                    <xsl:attribute name="width">
                                        <xsl:choose>
                                            <xsl:when test="normalize-space($colspec/@colwidth) = '*'">
                                                <xsl:value-of select="'1*'"/>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:value-of select="$colspec/@colwidth"/>
                                            </xsl:otherwise>
                                        </xsl:choose>
                                    </xsl:attribute>
                                </xsl:when>
                            </xsl:choose>

                            <xsl:choose>
                                <xsl:when test="$colspec/@align">
                                    <xsl:attribute name="align">
                                        <xsl:value-of select="$colspec/@align"/>
                                    </xsl:attribute>
                                </xsl:when>
                                <!-- Suggested by Pavel ZAMPACH <zampach@nemcb.cz> -->
                                <xsl:when test="$colspecs/ancestor::tgroup/@align">
                                    <xsl:attribute name="align">
                                        <xsl:value-of select="$colspecs/ancestor::tgroup/@align"/>
                                    </xsl:attribute>
                                </xsl:when>
                            </xsl:choose>

                            <xsl:if test="$colspec/@char">
                                <xsl:attribute name="char">
                                    <xsl:value-of select="$colspec/@char"/>
                                </xsl:attribute>
                            </xsl:if>

                            <xsl:if test="$colspec/@charoff">
                                <xsl:attribute name="charoff">
                                    <xsl:value-of select="$colspec/@charoff"/>
                                </xsl:attribute>
                            </xsl:if>

                            <xsl:if test="$colspec/@colname">
                                <xsl:attribute name="class">
                                    <xsl:value-of select="$class.prefix"/>
                                    <xsl:value-of select="$colspec/@colname"/>
                                </xsl:attribute>
                            </xsl:if>
                        </col>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="generate.col">
                            <xsl:with-param name="countcol" select="$countcol"/>
                            <xsl:with-param name="colspecs" select="$colspecs"/>
                            <xsl:with-param name="count" select="$count+1"/>
                            <xsl:with-param name="colnum">
                                <xsl:choose>
                                    <xsl:when test="$colspec/@colnum">
                                        <xsl:value-of select="$colspec/@colnum + 1"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:value-of select="$colnum + 1"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="colspec.colwidth">
        <!-- when this macro is called, the current context must be an entry -->
        <xsl:param name="colname"/>
        <!-- .. = row, ../.. = thead|tbody, ../../.. = tgroup -->
        <xsl:param name="colspecs" select="../../../../tgroup/colspec"/>
        <xsl:param name="count">1</xsl:param>
        <xsl:choose>
            <xsl:when test="$count&gt;count($colspecs)"/>
            <xsl:otherwise>
                <xsl:variable name="colspec" select="$colspecs[$count=position()]"/>
                <xsl:choose>
                    <xsl:when test="$colspec/@colname=$colname">
                        <xsl:value-of select="$colspec/@colwidth"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="colspec.colwidth">
                            <xsl:with-param name="colname" select="$colname"/>
                            <xsl:with-param name="colspecs" select="$colspecs"/>
                            <xsl:with-param name="count" select="$count+1"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="tr.attributes">
        <xsl:param name="row" select="."/>
        <xsl:param name="rownum" select="0"/>

        <!-- by default, do nothing. But you might want to say:

  <xsl:if test="$rownum mod 2 = 0">
    <xsl:attribute name="class">oddrow</xsl:attribute>
  </xsl:if>

  -->
    </xsl:template>
    <xsl:template match="table" mode="htmlTable">
        <xsl:element name="table" namespace="http://www.w3.org/1999/xhtml">
            <xsl:apply-templates select="@*" mode="htmlTableAtt"/>
            <xsl:call-template name="htmlTable"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="colgroup" mode="htmlTable">
        <xsl:element name="{local-name()}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:apply-templates select="@*" mode="htmlTableAtt"/>
            <xsl:apply-templates mode="htmlTable"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="col" mode="htmlTable">
        <xsl:element name="{local-name()}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:apply-templates select="@*" mode="htmlTableAtt"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="caption" mode="htmlTable"/>
    <xsl:template match="tbody|thead|tfoot|tr" mode="htmlTable">
        <xsl:element name="{local-name(.)}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:apply-templates select="@*" mode="htmlTableAtt"/>
            <xsl:apply-templates mode="htmlTable"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="th|td" mode="htmlTable">
        <xsl:element name="{local-name(.)}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:apply-templates select="@*" mode="htmlTableAtt"/>
            <xsl:apply-templates/>
            <!-- *not* mode=htmlTable -->
        </xsl:element>
    </xsl:template>
    <xsl:template mode="htmlTableAtt" match="@*"/>
    <xsl:template mode="htmlTableAtt"
                  match="@abbr                    | @align                    | @axis                    | @bgcolor                    | @border                    | @cellpadding                    | @cellspacing                    | @char                    | @charoff                    | @class                    | @dir                    | @frame                    | @headers                    | @height                    | @lang                    | @nowrap                    | @onclick                    | @ondblclick                    | @onkeydown                    | @onkeypress                    | @onkeyup                    | @onmousedown                    | @onmousemove                    | @onmouseout                    | @onmouseover                    | @onmouseup                    | @rules                    | @style                    | @summary                    | @title                    | @valign                    | @valign                    | @width                    | @xml:lang">
        <xsl:copy-of select="."/>
    </xsl:template>
    <xsl:template match="@span|@rowspan|@colspan" mode="htmlTableAtt">
        <!-- No need to copy through the DTD's default value "1" of the attribute -->
        <xsl:if test="number(.) != 1">
            <xsl:attribute name="{local-name(.)}">
                <xsl:value-of select="."/>
            </xsl:attribute>
        </xsl:if>
    </xsl:template>
    <xsl:template match="@floatstyle" mode="htmlTableAtt">
        <xsl:attribute name="style">
            <xsl:text>float: </xsl:text>
            <xsl:choose>
                <xsl:when test="contains(., 'left')">left</xsl:when>
                <xsl:when test="contains(., 'right')">right</xsl:when>
                <xsl:when test="contains(., 'start')">
                    <xsl:value-of select="$direction.align.start"/>
                </xsl:when>
                <xsl:when test="contains(., 'end')">
                    <xsl:value-of select="$direction.align.end"/>
                </xsl:when>
                <xsl:when test="contains(., 'inside')">
                    <xsl:value-of select="$direction.align.start"/>
                </xsl:when>
                <xsl:when test="contains(., 'outside')">
                    <xsl:value-of select="$direction.align.end"/>
                </xsl:when>
                <xsl:when test="contains(., 'before')">none</xsl:when>
                <xsl:when test="contains(., 'none')">none</xsl:when>
            </xsl:choose>
            <xsl:text>;</xsl:text>
        </xsl:attribute>
    </xsl:template>
    <xsl:template match="section">
        <xsl:variable name="depth" select="count(ancestor::section)+1"/>

        <xsl:call-template name="id.warning"/>

        <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:call-template name="section.titlepage"/>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:if test="contains($toc.params, 'toc')                   and $depth &lt;= $generate.section.toc.level">
                <xsl:call-template name="section.toc">
                    <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                </xsl:call-template>
                <xsl:call-template name="section.toc.separator"/>
            </xsl:if>
            <xsl:apply-templates/>
            <xsl:call-template name="process.chunk.footnotes"/>
        </xsl:element>
    </xsl:template>
    <xsl:template name="section.title">
        <!-- the context node should be the title of a section when called -->
        <xsl:variable name="section"
                      select="(ancestor::section                                         |ancestor::simplesect                                         |ancestor::sect1                                         |ancestor::sect2                                         |ancestor::sect3                                         |ancestor::sect4                                         |ancestor::sect5)[last()]"/>

        <xsl:variable name="renderas">
            <xsl:choose>
                <xsl:when test="$section/@renderas = 'sect1'">1</xsl:when>
                <xsl:when test="$section/@renderas = 'sect2'">2</xsl:when>
                <xsl:when test="$section/@renderas = 'sect3'">3</xsl:when>
                <xsl:when test="$section/@renderas = 'sect4'">4</xsl:when>
                <xsl:when test="$section/@renderas = 'sect5'">5</xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="''"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="level">
            <xsl:choose>
                <xsl:when test="$renderas != ''">
                    <xsl:value-of select="$renderas"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="section.level">
                        <xsl:with-param name="node" select="$section"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:call-template name="section.heading">
            <xsl:with-param name="section" select="$section"/>
            <xsl:with-param name="level" select="$level"/>
            <xsl:with-param name="title">
                <xsl:apply-templates select="$section" mode="object.title.markup">
                    <xsl:with-param name="allow-anchors" select="1"/>
                </xsl:apply-templates>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="section/title                     |section/info/title                     |sectioninfo/title"
                  mode="titlepage.mode" priority="2">
        <xsl:call-template name="section.title"/>
    </xsl:template>
    <xsl:template match="sect1">
        <xsl:call-template name="id.warning"/>

        <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:choose>
                <xsl:when test="@renderas = 'sect2'">
                    <xsl:call-template name="sect2.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect3'">
                    <xsl:call-template name="sect3.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect4'">
                    <xsl:call-template name="sect4.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect5'">
                    <xsl:call-template name="sect5.titlepage"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="sect1.titlepage"/>
                </xsl:otherwise>
            </xsl:choose>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:if test="contains($toc.params, 'toc')                   and $generate.section.toc.level &gt;= 1">
                <xsl:call-template name="section.toc">
                    <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                </xsl:call-template>
                <xsl:call-template name="section.toc.separator"/>
            </xsl:if>
            <xsl:apply-templates/>
            <xsl:call-template name="process.chunk.footnotes"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="sect1/title                     |sect1/info/title                     |sect1info/title"
                  mode="titlepage.mode" priority="2">
        <xsl:call-template name="section.title"/>
    </xsl:template>
    <xsl:template match="sect2">
        <xsl:call-template name="id.warning"/>

        <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:choose>
                <xsl:when test="@renderas = 'sect1'">
                    <xsl:call-template name="sect1.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect3'">
                    <xsl:call-template name="sect3.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect4'">
                    <xsl:call-template name="sect4.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect5'">
                    <xsl:call-template name="sect5.titlepage"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="sect2.titlepage"/>
                </xsl:otherwise>
            </xsl:choose>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:if test="contains($toc.params, 'toc')                   and $generate.section.toc.level &gt;= 2">
                <xsl:call-template name="section.toc">
                    <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                </xsl:call-template>
                <xsl:call-template name="section.toc.separator"/>
            </xsl:if>
            <xsl:apply-templates/>
            <xsl:call-template name="process.chunk.footnotes"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="sect2/title                     |sect2/info/title                     |sect2info/title"
                  mode="titlepage.mode" priority="2">
        <xsl:call-template name="section.title"/>
    </xsl:template>
    <xsl:template match="sect3">
        <xsl:call-template name="id.warning"/>

        <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:choose>
                <xsl:when test="@renderas = 'sect1'">
                    <xsl:call-template name="sect1.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect2'">
                    <xsl:call-template name="sect2.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect4'">
                    <xsl:call-template name="sect4.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect5'">
                    <xsl:call-template name="sect5.titlepage"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="sect3.titlepage"/>
                </xsl:otherwise>
            </xsl:choose>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:if test="contains($toc.params, 'toc')                   and $generate.section.toc.level &gt;= 3">
                <xsl:call-template name="section.toc">
                    <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                </xsl:call-template>
                <xsl:call-template name="section.toc.separator"/>
            </xsl:if>
            <xsl:apply-templates/>
            <xsl:call-template name="process.chunk.footnotes"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="sect3/title                     |sect3/info/title                     |sect3info/title"
                  mode="titlepage.mode" priority="2">
        <xsl:call-template name="section.title"/>
    </xsl:template>
    <xsl:template match="sect4">
        <xsl:call-template name="id.warning"/>

        <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:choose>
                <xsl:when test="@renderas = 'sect1'">
                    <xsl:call-template name="sect1.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect2'">
                    <xsl:call-template name="sect2.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect3'">
                    <xsl:call-template name="sect3.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect5'">
                    <xsl:call-template name="sect5.titlepage"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="sect4.titlepage"/>
                </xsl:otherwise>
            </xsl:choose>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:if test="contains($toc.params, 'toc')                   and $generate.section.toc.level &gt;= 4">
                <xsl:call-template name="section.toc">
                    <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                </xsl:call-template>
                <xsl:call-template name="section.toc.separator"/>
            </xsl:if>
            <xsl:apply-templates/>
            <xsl:call-template name="process.chunk.footnotes"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="sect4/title                     |sect4/info/title                     |sect4info/title"
                  mode="titlepage.mode" priority="2">
        <xsl:call-template name="section.title"/>
    </xsl:template>
    <xsl:template match="sect5">
        <xsl:call-template name="id.warning"/>

        <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:choose>
                <xsl:when test="@renderas = 'sect1'">
                    <xsl:call-template name="sect1.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect2'">
                    <xsl:call-template name="sect2.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect3'">
                    <xsl:call-template name="sect3.titlepage"/>
                </xsl:when>
                <xsl:when test="@renderas = 'sect4'">
                    <xsl:call-template name="sect4.titlepage"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="sect5.titlepage"/>
                </xsl:otherwise>
            </xsl:choose>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:if test="contains($toc.params, 'toc')                   and $generate.section.toc.level &gt;= 5">
                <xsl:call-template name="section.toc">
                    <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                </xsl:call-template>
                <xsl:call-template name="section.toc.separator"/>
            </xsl:if>
            <xsl:apply-templates/>
            <xsl:call-template name="process.chunk.footnotes"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="sect5/title                     |sect5/info/title                     |sect5info/title"
                  mode="titlepage.mode" priority="2">
        <xsl:call-template name="section.title"/>
    </xsl:template>
    <xsl:template match="simplesect">
        <xsl:call-template name="id.warning"/>

        <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:call-template name="simplesect.titlepage"/>
            <xsl:apply-templates/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="simplesect/title|simplesect/info/title" mode="titlepage.mode" priority="2">
        <xsl:call-template name="section.title"/>
    </xsl:template>
    <xsl:template match="section/title"/>
    <xsl:template match="section/titleabbrev"/>
    <xsl:template match="section/subtitle"/>
    <xsl:template match="sectioninfo"/>
    <xsl:template match="section/info"/>
    <xsl:template match="sect1/title"/>
    <xsl:template match="sect1/titleabbrev"/>
    <xsl:template match="sect1/subtitle"/>
    <xsl:template match="sect1info"/>
    <xsl:template match="sect1/info"/>
    <xsl:template match="sect2/title"/>
    <xsl:template match="sect2/subtitle"/>
    <xsl:template match="sect2/titleabbrev"/>
    <xsl:template match="sect2info"/>
    <xsl:template match="sect2/info"/>
    <xsl:template match="sect3/title"/>
    <xsl:template match="sect3/subtitle"/>
    <xsl:template match="sect3/titleabbrev"/>
    <xsl:template match="sect3info"/>
    <xsl:template match="sect3/info"/>
    <xsl:template match="sect4/title"/>
    <xsl:template match="sect4/subtitle"/>
    <xsl:template match="sect4/titleabbrev"/>
    <xsl:template match="sect4info"/>
    <xsl:template match="sect4/info"/>
    <xsl:template match="sect5/title"/>
    <xsl:template match="sect5/subtitle"/>
    <xsl:template match="sect5/titleabbrev"/>
    <xsl:template match="sect5info"/>
    <xsl:template match="sect5/info"/>
    <xsl:template match="simplesect/title"/>
    <xsl:template match="simplesect/subtitle"/>
    <xsl:template match="simplesect/titleabbrev"/>
    <xsl:template match="simplesect/info"/>
    <xsl:template name="section.heading">
        <xsl:param name="section" select="."/>
        <xsl:param name="level" select="1"/>
        <xsl:param name="allow-anchors" select="1"/>
        <xsl:param name="title"/>
        <xsl:param name="class" select="'title'"/>

        <xsl:variable name="id">
            <xsl:choose>
                <!-- Make sure the subtitle doesn't get the same id as the title -->
                <xsl:when test="self::subtitle">
                    <xsl:call-template name="object.id">
                        <xsl:with-param name="object" select="."/>
                    </xsl:call-template>
                </xsl:when>
                <!-- if title is in an *info wrapper, get the grandparent -->
                <xsl:when test="contains(local-name(..), 'info')">
                    <xsl:call-template name="object.id">
                        <xsl:with-param name="object" select="../.."/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="object.id">
                        <xsl:with-param name="object" select=".."/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <!-- HTML H level is one higher than section level -->
        <xsl:variable name="hlevel">
            <xsl:choose>
                <!-- highest valid HTML H level is H6; so anything nested deeper
           than 5 levels down just becomes H6 -->
                <xsl:when test="$level &gt; 5">6</xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$level + 1"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:element name="h{$hlevel}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:attribute name="class">
                <xsl:value-of select="$class.prefix"/><xsl:value-of select="$class"/>
            </xsl:attribute>
            <xsl:if test="$css.decoration != '0'">
                <xsl:if test="$hlevel&lt;3">
                    <xsl:attribute name="style">clear: both</xsl:attribute>
                </xsl:if>
            </xsl:if>
            <xsl:if test="$allow-anchors != 0">
                <xsl:call-template name="anchor">
                    <xsl:with-param name="node" select="$section"/>
                    <xsl:with-param name="conditional" select="0"/>
                </xsl:call-template>
            </xsl:if>
            <xsl:copy-of select="$title"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="bridgehead">
        <xsl:variable name="container"
                      select="(ancestor::appendix                         |ancestor::article                         |ancestor::bibliography                         |ancestor::chapter                         |ancestor::glossary                         |ancestor::glossdiv                         |ancestor::index                         |ancestor::partintro                         |ancestor::preface                         |ancestor::refsect1                         |ancestor::refsect2                         |ancestor::refsect3                         |ancestor::sect1                         |ancestor::sect2                         |ancestor::sect3                         |ancestor::sect4                         |ancestor::sect5                         |ancestor::section                         |ancestor::setindex                         |ancestor::simplesect)[last()]"/>

        <xsl:variable name="clevel">
            <xsl:choose>
                <xsl:when
                        test="local-name($container) = 'appendix'                       or local-name($container) = 'chapter'                       or local-name($container) = 'article'                       or local-name($container) = 'bibliography'                       or local-name($container) = 'glossary'                       or local-name($container) = 'index'                       or local-name($container) = 'partintro'                       or local-name($container) = 'preface'                       or local-name($container) = 'setindex'">
                    1
                </xsl:when>
                <xsl:when test="local-name($container) = 'glossdiv'">
                    <xsl:value-of select="count(ancestor::glossdiv)+1"/>
                </xsl:when>
                <xsl:when
                        test="local-name($container) = 'sect1'                       or local-name($container) = 'sect2'                       or local-name($container) = 'sect3'                       or local-name($container) = 'sect4'                       or local-name($container) = 'sect5'                       or local-name($container) = 'refsect1'                       or local-name($container) = 'refsect2'                       or local-name($container) = 'refsect3'                       or local-name($container) = 'section'                       or local-name($container) = 'simplesect'">
                    <xsl:variable name="slevel">
                        <xsl:call-template name="section.level">
                            <xsl:with-param name="node" select="$container"/>
                        </xsl:call-template>
                    </xsl:variable>
                    <xsl:value-of select="$slevel + 1"/>
                </xsl:when>
                <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <!-- HTML H level is one higher than section level -->
        <xsl:variable name="hlevel">
            <xsl:choose>
                <xsl:when test="@renderas = 'sect1'">2</xsl:when>
                <xsl:when test="@renderas = 'sect2'">3</xsl:when>
                <xsl:when test="@renderas = 'sect3'">4</xsl:when>
                <xsl:when test="@renderas = 'sect4'">5</xsl:when>
                <xsl:when test="@renderas = 'sect5'">6</xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$clevel + 1"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:element name="h{$hlevel}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:call-template name="anchor">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:apply-templates/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="section/subtitle" mode="titlepage.mode" priority="2">
        <xsl:call-template name="section.subtitle"/>
    </xsl:template>
    <xsl:template match="simplesect/subtitle" mode="titlepage.mode" priority="2">
        <xsl:call-template name="section.subtitle"/>
    </xsl:template>
    <xsl:template match="sect1/subtitle" mode="titlepage.mode" priority="2">
        <xsl:call-template name="section.subtitle"/>
    </xsl:template>
    <xsl:template match="sect2/subtitle" mode="titlepage.mode" priority="2">
        <xsl:call-template name="section.subtitle"/>
    </xsl:template>
    <xsl:template match="sect3/subtitle" mode="titlepage.mode" priority="2">
        <xsl:call-template name="section.subtitle"/>
    </xsl:template>
    <xsl:template match="sect4/subtitle" mode="titlepage.mode" priority="2">
        <xsl:call-template name="section.subtitle"/>
    </xsl:template>
    <xsl:template match="sect5/subtitle" mode="titlepage.mode" priority="2">
        <xsl:call-template name="section.subtitle"/>
    </xsl:template>
    <xsl:template name="section.subtitle">
        <!-- the context node should be the subtitle of a section when called -->
        <xsl:variable name="section"
                      select="(ancestor::section                                         |ancestor::simplesect                                         |ancestor::sect1                                         |ancestor::sect2                                         |ancestor::sect3                                         |ancestor::sect4                                         |ancestor::sect5)[last()]"/>

        <xsl:variable name="level">
            <xsl:call-template name="section.level">
                <xsl:with-param name="node" select="$section"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:call-template name="section.heading">
            <xsl:with-param name="section" select=".."/>
            <xsl:with-param name="allow-anchors" select="0"/>
            <!-- subtitle heading level one higher than section level -->
            <xsl:with-param name="level" select="$level + 1"/>
            <xsl:with-param name="class" select="'subtitle'"/>
            <xsl:with-param name="title">
                <xsl:apply-templates select="$section" mode="object.subtitle.markup">
                    <xsl:with-param name="allow-anchors" select="0"/>
                </xsl:apply-templates>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:key name="glossentries" match="glossentry" use="normalize-space(glossterm)"/>
    <xsl:key name="glossentries" match="glossentry" use="normalize-space(glossterm/@baseform)"/>
    <xsl:template name="simple.xlink">
        <xsl:param name="node" select="."/>
        <xsl:param name="content">
            <xsl:apply-templates/>
        </xsl:param>
        <xsl:param name="linkend" select="$node/@linkend"/>
        <xsl:param name="xhref" select="$node/@xlink:href"/>

        <!-- Support for @xlink:show -->
        <xsl:variable name="target.show">
            <xsl:choose>
                <xsl:when test="$node/@xlink:show = 'new'">_blank</xsl:when>
                <xsl:when test="$node/@xlink:show = 'replace'">_top</xsl:when>
                <xsl:otherwise/>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="link">
            <xsl:choose>
                <xsl:when
                        test="$xhref and                        (not($node/@xlink:type) or                             $node/@xlink:type='simple')">

                    <!-- Is it a local idref or a uri? -->
                    <xsl:variable name="is.idref">
                        <xsl:choose>
                            <!-- if the href starts with # and does not contain an "(" -->
                            <!-- or if the href starts with #xpointer(id(, it's just an ID -->
                            <xsl:when
                                    test="starts-with($xhref,'#')                             and (not(contains($xhref,'('))                             or starts-with($xhref,                                        '#xpointer(id('))">
                                1
                            </xsl:when>
                            <xsl:otherwise>0</xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>

                    <!-- Is it an olink ? -->
                    <xsl:variable name="is.olink">
                        <xsl:choose>
                            <!-- If xlink:role="http://docbook.org/xlink/role/olink" -->
                            <!-- and if the href contains # -->
                            <xsl:when test="contains($xhref,'#') and                  @xlink:role = $xolink.role">1
                            </xsl:when>
                            <xsl:otherwise>0</xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>

                    <xsl:choose>
                        <xsl:when test="$is.olink = 1">
                            <xsl:call-template name="olink">
                                <xsl:with-param name="content" select="$content"/>
                            </xsl:call-template>
                        </xsl:when>

                        <xsl:when test="$is.idref = 1">

                            <xsl:variable name="idref">
                                <xsl:call-template name="xpointer.idref">
                                    <xsl:with-param name="xpointer" select="$xhref"/>
                                </xsl:call-template>
                            </xsl:variable>

                            <xsl:variable name="targets" select="key('id',$idref)"/>
                            <xsl:variable name="target" select="$targets[1]"/>

                            <xsl:call-template name="check.id.unique">
                                <xsl:with-param name="linkend" select="$idref"/>
                            </xsl:call-template>

                            <xsl:choose>
                                <xsl:when test="count($target) = 0">
                                    <xsl:message>
                                        <xsl:text>XLink to nonexistent id: </xsl:text>
                                        <xsl:value-of select="$idref"/>
                                    </xsl:message>
                                    <xsl:copy-of select="$content"/>
                                </xsl:when>

                                <xsl:otherwise>
                                    <a>
                                        <xsl:apply-templates select="." mode="common.html.attributes"/>
                                        <xsl:call-template name="id.attribute"/>

                                        <xsl:attribute name="href">
                                            <xsl:call-template name="href.target">
                                                <xsl:with-param name="object" select="$target"/>
                                            </xsl:call-template>
                                        </xsl:attribute>

                                        <xsl:choose>
                                            <xsl:when test="$node/@xlink:title">
                                                <xsl:attribute name="title">
                                                    <xsl:value-of select="$node/@xlink:title"/>
                                                </xsl:attribute>
                                            </xsl:when>
                                            <xsl:otherwise>
                                                <xsl:apply-templates select="$target" mode="html.title.attribute"/>
                                            </xsl:otherwise>
                                        </xsl:choose>

                                        <xsl:if test="$target.show !=''">
                                            <xsl:attribute name="target">
                                                <xsl:value-of select="$target.show"/>
                                            </xsl:attribute>
                                        </xsl:if>

                                        <xsl:copy-of select="$content"/>

                                    </a>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>

                        <!-- otherwise it's a URI -->
                        <xsl:otherwise>
                            <a>
                                <xsl:apply-templates select="." mode="common.html.attributes"/>
                                <xsl:call-template name="id.attribute"/>
                                <xsl:attribute name="href">
                                    <xsl:value-of select="$xhref"/>
                                </xsl:attribute>
                                <xsl:if test="$node/@xlink:title">
                                    <xsl:attribute name="title">
                                        <xsl:value-of select="$node/@xlink:title"/>
                                    </xsl:attribute>
                                </xsl:if>

                                <!-- For URIs, use @xlink:show if defined, otherwise use ulink.target -->
                                <xsl:choose>
                                    <xsl:when test="$target.show !=''">
                                        <xsl:attribute name="target">
                                            <xsl:value-of select="$target.show"/>
                                        </xsl:attribute>
                                    </xsl:when>
                                    <xsl:when test="$ulink.target !=''">
                                        <xsl:attribute name="target">
                                            <xsl:value-of select="$ulink.target"/>
                                        </xsl:attribute>
                                    </xsl:when>
                                </xsl:choose>

                                <xsl:copy-of select="$content"/>
                            </a>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>

                <xsl:when test="$linkend">
                    <xsl:variable name="targets" select="key('id',$linkend)"/>
                    <xsl:variable name="target" select="$targets[1]"/>

                    <xsl:call-template name="check.id.unique">
                        <xsl:with-param name="linkend" select="$linkend"/>
                    </xsl:call-template>

                    <a>
                        <xsl:apply-templates select="." mode="common.html.attributes"/>
                        <xsl:call-template name="id.attribute"/>
                        <xsl:attribute name="href">
                            <xsl:call-template name="href.target">
                                <xsl:with-param name="object" select="$target"/>
                            </xsl:call-template>
                        </xsl:attribute>

                        <xsl:apply-templates select="$target" mode="html.title.attribute"/>

                        <xsl:copy-of select="$content"/>

                    </a>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:copy-of select="$content"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="function-available('suwl:unwrapLinks')">
                <xsl:copy-of select="suwl:unwrapLinks($link)"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="$link"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="inline.charseq">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:apply-templates/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:param>
        <!-- * if you want output from the inline.charseq template wrapped in -->
        <!-- * something other than a Span, call the template with some value -->
        <!-- * for the 'wrapper-name' param -->
        <xsl:param name="wrapper-name">span</xsl:param>
        <xsl:element name="{$wrapper-name}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:attribute name="class">
                <xsl:value-of select="$class.prefix"/>
                <xsl:value-of select="local-name(.)"/>
            </xsl:attribute>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="dir"/>
            <xsl:call-template name="generate.html.title"/>
            <xsl:copy-of select="$content"/>
            <xsl:call-template name="apply-annotations"/>
        </xsl:element>
    </xsl:template>
    <xsl:template name="inline.monoseq">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:apply-templates/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:param>
        <code>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:copy-of select="$content"/>
            <xsl:call-template name="apply-annotations"/>
        </code>
    </xsl:template>
    <xsl:template name="inline.boldseq">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:apply-templates/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:param>

        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>

            <!-- don't put <strong> inside figure, example, or table titles -->
            <xsl:choose>
                <xsl:when
                        test="local-name(..) = 'title'                       and (local-name(../..) = 'figure'                       or local-name(../..) = 'example'                       or local-name(../..) = 'table')">
                    <xsl:copy-of select="$content"/>
                </xsl:when>
                <xsl:otherwise>
                    <strong>
                        <xsl:copy-of select="$content"/>
                    </strong>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:call-template name="apply-annotations"/>
        </span>
    </xsl:template>
    <xsl:template name="inline.italicseq">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:apply-templates/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:param>
        <em>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:copy-of select="$content"/>
            <xsl:call-template name="apply-annotations"/>
        </em>
    </xsl:template>
    <xsl:template name="inline.boldmonoseq">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:apply-templates/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:param>
        <!-- don't put <strong> inside figure, example, or table titles -->
        <!-- or other titles that may already be represented with <strong>'s. -->
        <xsl:choose>
            <xsl:when
                    test="local-name(..) = 'title'                     and (local-name(../..) = 'figure'                          or local-name(../..) = 'example'                          or local-name(../..) = 'table'                          or local-name(../..) = 'formalpara')">
                <code>
                    <xsl:call-template name="common.html.attributes"/>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:copy-of select="$content"/>
                    <xsl:call-template name="apply-annotations"/>
                </code>
            </xsl:when>
            <xsl:otherwise>
                <strong>
                    <xsl:call-template name="common.html.attributes"/>
                    <xsl:call-template name="id.attribute"/>
                    <code>
                        <xsl:call-template name="generate.html.title"/>
                        <xsl:call-template name="dir"/>
                        <xsl:copy-of select="$content"/>
                    </code>
                    <xsl:call-template name="apply-annotations"/>
                </strong>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="inline.italicmonoseq">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:apply-templates/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:param>
        <em>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <code>
                <xsl:call-template name="generate.html.title"/>
                <xsl:call-template name="dir"/>
                <xsl:copy-of select="$content"/>
                <xsl:call-template name="apply-annotations"/>
            </code>
        </em>
    </xsl:template>
    <xsl:template name="inline.superscriptseq">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:apply-templates/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:param>
        <sup>
            <xsl:call-template name="generate.html.title"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="dir"/>
            <xsl:copy-of select="$content"/>
            <xsl:call-template name="apply-annotations"/>
        </sup>
    </xsl:template>
    <xsl:template name="inline.subscriptseq">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:apply-templates/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:param>
        <sub>
            <xsl:call-template name="generate.html.title"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="dir"/>
            <xsl:copy-of select="$content"/>
            <xsl:call-template name="apply-annotations"/>
        </sub>
    </xsl:template>
    <xsl:template match="author">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:call-template name="person.name"/>
                </xsl:with-param>
            </xsl:call-template>
            <xsl:call-template name="apply-annotations"/>
        </xsl:param>

        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:copy-of select="$content"/>
        </span>
    </xsl:template>
    <xsl:template match="editor">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:call-template name="person.name"/>
                </xsl:with-param>
            </xsl:call-template>
            <xsl:call-template name="apply-annotations"/>
        </xsl:param>

        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:copy-of select="$content"/>
        </span>
    </xsl:template>
    <xsl:template match="othercredit">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:call-template name="person.name"/>
                </xsl:with-param>
            </xsl:call-template>
            <xsl:call-template name="apply-annotations"/>
        </xsl:param>

        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:copy-of select="$content"/>
        </span>
    </xsl:template>
    <xsl:template match="authorinitials">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="accel">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="action">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="application">
        <xsl:call-template name="inline.boldseq"/>
    </xsl:template>
    <xsl:template match="classname">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="exceptionname">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="interfacename">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="methodname">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="command">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="computeroutput">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="constant">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="database">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="date">
        <!-- should this support locale-specific formatting? how? -->
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="errorcode">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="errorname">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="errortype">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="errortext">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="envar">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="filename">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="function">
        <xsl:choose>
            <xsl:when test="$function.parens != '0'                     and (parameter or function or replaceable)">
                <xsl:variable name="nodes" select="text()|*"/>
                <xsl:call-template name="inline.monoseq">
                    <xsl:with-param name="content">
                        <xsl:call-template name="simple.xlink">
                            <xsl:with-param name="content">
                                <xsl:apply-templates select="$nodes[1]"/>
                            </xsl:with-param>
                        </xsl:call-template>
                    </xsl:with-param>
                </xsl:call-template>
                <xsl:text>(</xsl:text>
                <xsl:apply-templates select="$nodes[position()&gt;1]"/>
                <xsl:text>)</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="inline.monoseq"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="function/parameter" priority="2">
        <xsl:call-template name="inline.italicmonoseq"/>
        <xsl:if test="$function.parens != 0 and following-sibling::*">
            <xsl:text>, </xsl:text>
        </xsl:if>
    </xsl:template>
    <xsl:template match="function/replaceable" priority="2">
        <xsl:call-template name="inline.italicmonoseq"/>
        <xsl:if test="$function.parens != 0 and following-sibling::*">
            <xsl:text>, </xsl:text>
        </xsl:if>
    </xsl:template>
    <xsl:template match="guibutton">
        <xsl:call-template name="inline.boldseq"/>
    </xsl:template>
    <xsl:template match="guiicon">
        <xsl:call-template name="inline.boldseq"/>
    </xsl:template>
    <xsl:template match="guilabel">
        <xsl:call-template name="inline.boldseq"/>
    </xsl:template>
    <xsl:template match="guimenu">
        <xsl:call-template name="inline.boldseq"/>
    </xsl:template>
    <xsl:template match="guimenuitem">
        <xsl:call-template name="inline.boldseq"/>
    </xsl:template>
    <xsl:template match="guisubmenu">
        <xsl:call-template name="inline.boldseq"/>
    </xsl:template>
    <xsl:template match="hardware">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="interface">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="interfacedefinition">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="keycap">
        <xsl:choose>
            <xsl:when test="@function and normalize-space(.) = ''">
                <xsl:call-template name="inline.boldseq">
                    <xsl:with-param name="content">
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="context" select="'keycap'"/>
                            <xsl:with-param name="name" select="@function"/>
                        </xsl:call-template>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="inline.boldseq"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="keycode">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="keysym">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="literal">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="code">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="medialabel">
        <xsl:call-template name="inline.italicseq"/>
    </xsl:template>
    <xsl:template match="shortcut">
        <xsl:call-template name="inline.boldseq"/>
    </xsl:template>
    <xsl:template match="mousebutton">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="option">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="package">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="parameter">
        <xsl:call-template name="inline.italicmonoseq"/>
    </xsl:template>
    <xsl:template match="property">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="prompt">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="replaceable" priority="1">
        <xsl:call-template name="inline.italicmonoseq"/>
    </xsl:template>
    <xsl:template match="returnvalue">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="structfield">
        <xsl:call-template name="inline.italicmonoseq"/>
    </xsl:template>
    <xsl:template match="structname">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="symbol">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="systemitem">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="token">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="type">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="userinput">
        <xsl:call-template name="inline.boldmonoseq"/>
    </xsl:template>
    <xsl:template match="abbrev">
        <xsl:call-template name="inline.charseq">
            <xsl:with-param name="wrapper-name">abbr</xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="acronym">
        <xsl:call-template name="inline.charseq">
            <xsl:with-param name="wrapper-name">acronym</xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="citerefentry">
        <xsl:choose>
            <xsl:when test="$citerefentry.link != '0'">
                <a>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:attribute name="href">
                        <xsl:call-template name="generate.citerefentry.link"/>
                    </xsl:attribute>
                    <xsl:call-template name="inline.charseq"/>
                </a>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="inline.charseq"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="generate.citerefentry.link">
        <!-- nop -->
    </xsl:template>
    <xsl:template name="x.generate.citerefentry.link">
        <xsl:text>http://example.com/cgi-bin/man.cgi?</xsl:text>
        <xsl:value-of select="refentrytitle"/>
        <xsl:text>(</xsl:text>
        <xsl:value-of select="manvolnum"/>
        <xsl:text>)</xsl:text>
    </xsl:template>
    <xsl:template match="citetitle">
        <xsl:choose>
            <xsl:when test="@pubwork = 'article'">
                <xsl:call-template name="gentext.startquote"/>
                <xsl:call-template name="inline.charseq"/>
                <xsl:call-template name="gentext.endquote"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="inline.italicseq"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="emphasis">
        <span>
            <xsl:call-template name="id.attribute"/>
            <xsl:choose>
                <!-- We don't want empty @class values, so do not propagate empty @roles -->
                <xsl:when
                        test="@role  and                       normalize-space(@role) != '' and                       $emphasis.propagates.style != 0">
                    <xsl:apply-templates select="." mode="common.html.attributes">
                        <xsl:with-param name="class" select="@role"/>
                    </xsl:apply-templates>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:call-template name="anchor"/>

            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:choose>
                        <xsl:when test="@role = 'bold' or @role='strong'">
                            <!-- backwards compatibility: make bold into b elements, but -->
                            <!-- don't put bold inside figure, example, or table titles -->
                            <xsl:choose>
                                <xsl:when
                                        test="local-name(..) = 'title'                               and (local-name(../..) = 'figure'                               or local-name(../..) = 'example'                               or local-name(../..) = 'table')">
                                    <xsl:apply-templates/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <strong>
                                        <xsl:apply-templates/>
                                    </strong>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:when test="@role and $emphasis.propagates.style != 0">
                            <xsl:apply-templates/>
                        </xsl:when>
                        <xsl:otherwise>
                            <em>
                                <xsl:apply-templates/>
                            </em>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:with-param>
            </xsl:call-template>
        </span>
    </xsl:template>
    <xsl:template match="foreignphrase">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="inline.italicseq"/>
        </span>
    </xsl:template>
    <xsl:template match="markup">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="phrase">
        <span>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="locale.html.attributes"/>
            <!-- We don't want empty @class values, so do not propagate empty @roles -->
            <xsl:choose>
                <xsl:when
                        test="@role and                       normalize-space(@role) != '' and                      $phrase.propagates.style != 0">
                    <xsl:apply-templates select="." mode="class.attribute">
                        <xsl:with-param name="class" select="@role"/>
                    </xsl:apply-templates>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates select="." mode="class.attribute"/>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:call-template name="dir"/>
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:apply-templates/>
                </xsl:with-param>
            </xsl:call-template>
            <xsl:call-template name="apply-annotations"/>
        </span>
    </xsl:template>
    <xsl:template match="quote">
        <xsl:variable name="depth">
            <xsl:call-template name="dot.count">
                <xsl:with-param name="string">
                    <xsl:number level="multiple"/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:variable>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:choose>
                <xsl:when test="$depth mod 2 = 0">
                    <xsl:call-template name="gentext.startquote"/>
                    <xsl:call-template name="inline.charseq"/>
                    <xsl:call-template name="gentext.endquote"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="gentext.nestedstartquote"/>
                    <xsl:call-template name="inline.charseq"/>
                    <xsl:call-template name="gentext.nestedendquote"/>
                </xsl:otherwise>
            </xsl:choose>
        </span>
    </xsl:template>
    <xsl:template match="varname">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="wordasword">
        <xsl:call-template name="inline.italicseq"/>
    </xsl:template>
    <xsl:template match="lineannotation">
        <em>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="inline.charseq"/>
        </em>
    </xsl:template>
    <xsl:template match="superscript">
        <xsl:call-template name="inline.superscriptseq"/>
    </xsl:template>
    <xsl:template match="subscript">
        <xsl:call-template name="inline.subscriptseq"/>
    </xsl:template>
    <xsl:template match="trademark">
        <xsl:call-template name="inline.charseq"/>
        <xsl:choose>
            <xsl:when test="@class = 'copyright'                     or @class = 'registered'">
                <xsl:call-template name="dingbat">
                    <xsl:with-param name="dingbat" select="@class"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="@class = 'service'">
                <sup>SM</sup>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="dingbat">
                    <xsl:with-param name="dingbat" select="'trademark'"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="firstterm">
        <xsl:call-template name="glossterm">
            <xsl:with-param name="firstterm" select="1"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="glossterm" name="glossterm">
        <xsl:param name="firstterm" select="0"/>

        <!-- To avoid extra <a name=""> anchor from inline.italicseq -->
        <xsl:variable name="content">
            <xsl:apply-templates/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="($firstterm.only.link = 0 or $firstterm = 1) and @linkend">
                <xsl:variable name="targets" select="key('id',@linkend)"/>
                <xsl:variable name="target" select="$targets[1]"/>

                <xsl:call-template name="check.id.unique">
                    <xsl:with-param name="linkend" select="@linkend"/>
                </xsl:call-template>

                <xsl:choose>
                    <xsl:when test="$target">
                        <a>
                            <xsl:apply-templates select="." mode="common.html.attributes"/>
                            <xsl:if test="@id or @xml:id">
                                <xsl:attribute name="id">
                                    <xsl:value-of select="(@id|@xml:id)[1]"/>
                                </xsl:attribute>
                            </xsl:if>

                            <xsl:attribute name="href">
                                <xsl:call-template name="href.target">
                                    <xsl:with-param name="object" select="$target"/>
                                </xsl:call-template>
                            </xsl:attribute>

                            <xsl:call-template name="inline.italicseq">
                                <xsl:with-param name="content" select="$content"/>
                            </xsl:call-template>
                        </a>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="inline.italicseq">
                            <xsl:with-param name="content" select="$content"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>

            <xsl:when
                    test="not(@linkend)                     and ($firstterm.only.link = 0 or $firstterm = 1)                     and ($glossterm.auto.link != 0)                     and $glossary.collection != ''">
                <xsl:variable name="term">
                    <xsl:choose>
                        <xsl:when test="@baseform">
                            <xsl:value-of select="@baseform"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="."/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>

                <xsl:variable name="cterm" select="(document($glossary.collection,.)//glossentry[glossterm=$term])[1]"/>

                <!-- HACK HACK HACK! But it works... -->
                <!-- You'd need to do more work if you wanted to chunk on glossdiv, though -->

                <xsl:variable name="glossary" select="//glossary[@role='auto']"/>

                <xsl:if test="count($glossary) != 1">
                    <xsl:message>
                        <xsl:text>Warning: glossary.collection specified, but there are </xsl:text>
                        <xsl:value-of select="count($glossary)"/>
                        <xsl:text> automatic glossaries</xsl:text>
                    </xsl:message>
                </xsl:if>

                <xsl:variable name="glosschunk">
                    <xsl:call-template name="href.target">
                        <xsl:with-param name="object" select="$glossary"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="chunkbase">
                    <xsl:choose>
                        <xsl:when test="contains($glosschunk, '#')">
                            <xsl:value-of select="substring-before($glosschunk, '#')"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$glosschunk"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>

                <xsl:choose>
                    <xsl:when test="not($cterm)">
                        <xsl:message>
                            <xsl:text>There's no entry for </xsl:text>
                            <xsl:value-of select="$term"/>
                            <xsl:text> in </xsl:text>
                            <xsl:value-of select="$glossary.collection"/>
                        </xsl:message>
                        <xsl:call-template name="inline.italicseq"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:variable name="id">
                            <xsl:call-template name="object.id">
                                <xsl:with-param name="object" select="$cterm"/>
                            </xsl:call-template>
                        </xsl:variable>
                        <a href="{$chunkbase}#{$id}">
                            <xsl:apply-templates select="." mode="common.html.attributes"/>
                            <xsl:call-template name="inline.italicseq">
                                <xsl:with-param name="content" select="$content"/>
                            </xsl:call-template>
                        </a>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>

            <xsl:when
                    test="not(@linkend)                     and ($firstterm.only.link = 0 or $firstterm = 1)                     and $glossterm.auto.link != 0">
                <xsl:variable name="term">
                    <xsl:choose>
                        <xsl:when test="@baseform">
                            <xsl:value-of select="normalize-space(@baseform)"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="normalize-space(.)"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>
                <xsl:variable name="targets" select="key('glossentries', $term)"/>
                <xsl:variable name="target" select="$targets[1]"/>

                <xsl:choose>
                    <xsl:when test="count($targets)=0">
                        <xsl:message>
                            <xsl:text>Error: no glossentry for glossterm: </xsl:text>
                            <xsl:value-of select="."/>
                            <xsl:text>.</xsl:text>
                        </xsl:message>
                        <xsl:call-template name="inline.italicseq"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <a>
                            <xsl:apply-templates select="." mode="common.html.attributes"/>
                            <xsl:if test="@id or @xml:id">
                                <xsl:attribute name="id">
                                    <xsl:value-of select="(@id|@xml:id)[1]"/>
                                </xsl:attribute>
                            </xsl:if>

                            <xsl:attribute name="href">
                                <xsl:call-template name="href.target">
                                    <xsl:with-param name="object" select="$target"/>
                                </xsl:call-template>
                            </xsl:attribute>

                            <xsl:call-template name="inline.italicseq">
                                <xsl:with-param name="content" select="$content"/>
                            </xsl:call-template>
                        </a>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>

            <xsl:otherwise>
                <xsl:call-template name="inline.italicseq"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="termdef">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'termdef'"/>
                <xsl:with-param name="name" select="'prefix'"/>
            </xsl:call-template>
            <xsl:apply-templates/>
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'termdef'"/>
                <xsl:with-param name="name" select="'suffix'"/>
            </xsl:call-template>
        </span>
    </xsl:template>
    <xsl:template match="sgmltag|tag">
        <xsl:call-template name="format.sgmltag"/>
    </xsl:template>
    <xsl:template name="format.sgmltag">
        <xsl:param name="class">
            <xsl:choose>
                <xsl:when test="@class">
                    <xsl:value-of select="@class"/>
                </xsl:when>
                <xsl:otherwise>element</xsl:otherwise>
            </xsl:choose>
        </xsl:param>

        <xsl:variable name="content">
            <xsl:choose>
                <xsl:when test="$class='attribute'">
                    <xsl:apply-templates/>
                </xsl:when>
                <xsl:when test="$class='attvalue'">
                    <xsl:apply-templates/>
                </xsl:when>
                <xsl:when test="$class='element'">
                    <xsl:apply-templates/>
                </xsl:when>
                <xsl:when test="$class='endtag'">
                    <xsl:text>&lt;/</xsl:text>
                    <xsl:apply-templates/>
                    <xsl:text>&gt;</xsl:text>
                </xsl:when>
                <xsl:when test="$class='genentity'">
                    <xsl:text>&amp;</xsl:text>
                    <xsl:apply-templates/>
                    <xsl:text>;</xsl:text>
                </xsl:when>
                <xsl:when test="$class='numcharref'">
                    <xsl:text>&amp;#</xsl:text>
                    <xsl:apply-templates/>
                    <xsl:text>;</xsl:text>
                </xsl:when>
                <xsl:when test="$class='paramentity'">
                    <xsl:text>%</xsl:text>
                    <xsl:apply-templates/>
                    <xsl:text>;</xsl:text>
                </xsl:when>
                <xsl:when test="$class='pi'">
                    <xsl:text>&lt;?</xsl:text>
                    <xsl:apply-templates/>
                    <xsl:text>&gt;</xsl:text>
                </xsl:when>
                <xsl:when test="$class='xmlpi'">
                    <xsl:text>&lt;?</xsl:text>
                    <xsl:apply-templates/>
                    <xsl:text>?&gt;</xsl:text>
                </xsl:when>
                <xsl:when test="$class='starttag'">
                    <xsl:text>&lt;</xsl:text>
                    <xsl:apply-templates/>
                    <xsl:text>&gt;</xsl:text>
                </xsl:when>
                <xsl:when test="$class='emptytag'">
                    <xsl:text>&lt;</xsl:text>
                    <xsl:apply-templates/>
                    <xsl:text>/&gt;</xsl:text>
                </xsl:when>
                <xsl:when test="$class='sgmlcomment' or $class='comment'">
                    <xsl:text>&lt;!--</xsl:text>
                    <xsl:apply-templates/>
                    <xsl:text>--&gt;</xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <code>
            <xsl:apply-templates select="." mode="common.html.attributes">
                <xsl:with-param name="class" select="concat('sgmltag-', $class)"/>
            </xsl:apply-templates>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content" select="$content"/>
            </xsl:call-template>
        </code>
    </xsl:template>
    <xsl:template match="email">
        <xsl:call-template name="inline.monoseq">
            <xsl:with-param name="content">
                <xsl:if test="not($email.delimiters.enabled = 0)">
                    <xsl:text>&lt;</xsl:text>
                </xsl:if>
                <a>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:attribute name="href">
                        <xsl:text>mailto:</xsl:text>
                        <xsl:value-of select="."/>
                    </xsl:attribute>
                    <xsl:apply-templates/>
                </a>
                <xsl:if test="not($email.delimiters.enabled = 0)">
                    <xsl:text>&gt;</xsl:text>
                </xsl:if>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="keycombo">
        <xsl:variable name="action" select="@action"/>
        <xsl:variable name="joinchar">
            <xsl:choose>
                <xsl:when test="$action='seq'">
                    <xsl:text> </xsl:text>
                </xsl:when>
                <xsl:when test="$action='simul'">+</xsl:when>
                <xsl:when test="$action='press'">-</xsl:when>
                <xsl:when test="$action='click'">-</xsl:when>
                <xsl:when test="$action='double-click'">-</xsl:when>
                <xsl:when test="$action='other'"/>
                <xsl:otherwise>+</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:for-each select="*">
            <xsl:if test="position()&gt;1">
                <xsl:value-of select="$joinchar"/>
            </xsl:if>
            <xsl:apply-templates select="."/>
        </xsl:for-each>
    </xsl:template>
    <xsl:template match="uri">
        <xsl:call-template name="inline.monoseq"/>
    </xsl:template>
    <xsl:template match="menuchoice">
        <xsl:variable name="shortcut" select="./shortcut"/>
        <xsl:call-template name="process.menuchoice"/>
        <xsl:if test="$shortcut">
            <xsl:text> (</xsl:text>
            <xsl:apply-templates select="$shortcut"/>
            <xsl:text>)</xsl:text>
        </xsl:if>
    </xsl:template>
    <xsl:template name="process.menuchoice">
        <xsl:param name="nodelist" select="guibutton|guiicon|guilabel|guimenu|guimenuitem|guisubmenu|interface"/>
        <!-- not(shortcut) -->
        <xsl:param name="count" select="1"/>

        <xsl:choose>
            <xsl:when test="$count&gt;count($nodelist)"/>
            <xsl:when test="$count=1">
                <xsl:apply-templates select="$nodelist[$count=position()]"/>
                <xsl:call-template name="process.menuchoice">
                    <xsl:with-param name="nodelist" select="$nodelist"/>
                    <xsl:with-param name="count" select="$count+1"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="node" select="$nodelist[$count=position()]"/>
                <xsl:choose>
                    <xsl:when
                            test="local-name($node)='guimenuitem'                         or local-name($node)='guisubmenu'">
                        <xsl:value-of select="$menuchoice.menu.separator"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$menuchoice.separator"/>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:apply-templates select="$node"/>
                <xsl:call-template name="process.menuchoice">
                    <xsl:with-param name="nodelist" select="$nodelist"/>
                    <xsl:with-param name="count" select="$count+1"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="optional">
        <xsl:value-of select="$arg.choice.opt.open.str"/>
        <xsl:call-template name="inline.charseq"/>
        <xsl:value-of select="$arg.choice.opt.close.str"/>
    </xsl:template>
    <xsl:template match="citation">
        <!-- todo: integrate with bibliography collection -->
        <xsl:variable name="targets" select="(//biblioentry | //bibliomixed)[abbrev = string(current())]"/>
        <xsl:variable name="target" select="$targets[1]"/>

        <xsl:choose>
            <!-- try automatic linking based on match to abbrev -->
            <xsl:when test="$target and not(xref) and not(link)">

                <xsl:text>[</xsl:text>
                <a>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:attribute name="href">
                        <xsl:call-template name="href.target">
                            <xsl:with-param name="object" select="$target"/>
                        </xsl:call-template>
                    </xsl:attribute>

                    <xsl:choose>
                        <xsl:when test="$bibliography.numbered != 0">
                            <xsl:call-template name="id.attribute"/>
                            <xsl:apply-templates select="$target" mode="citation"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:call-template name="inline.charseq"/>
                        </xsl:otherwise>
                    </xsl:choose>

                </a>
                <xsl:text>]</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>[</xsl:text>
                <xsl:call-template name="inline.charseq"/>
                <xsl:text>]</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="citebiblioid">
        <xsl:variable name="targets" select="//*[biblioid = string(current())]"/>
        <xsl:variable name="target" select="$targets[1]"/>

        <xsl:choose>
            <!-- try automatic linking based on match to parent of biblioid -->
            <xsl:when test="$target and not(xref) and not(link)">

                <xsl:text>[</xsl:text>
                <a>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:attribute name="href">
                        <xsl:call-template name="href.target">
                            <xsl:with-param name="object" select="$target"/>
                        </xsl:call-template>
                    </xsl:attribute>

                    <xsl:call-template name="inline.charseq"/>

                </a>
                <xsl:text>]</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>[</xsl:text>
                <xsl:call-template name="inline.charseq"/>
                <xsl:text>]</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="biblioentry|bibliomixed" mode="citation">
        <xsl:number from="bibliography" count="biblioentry|bibliomixed" level="any" format="1"/>
    </xsl:template>
    <xsl:template
            match="comment[parent::answer|parent::appendix|parent::article|parent::bibliodiv|                                 parent::bibliography|parent::blockquote|parent::caution|parent::chapter|                                 parent::glossary|parent::glossdiv|parent::important|parent::index|                                 parent::indexdiv|parent::listitem|parent::note|parent::orderedlist|                                 parent::partintro|parent::preface|parent::procedure|parent::qandadiv|                                 parent::qandaset|parent::question|parent::refentry|parent::refnamediv|                                 parent::refsect1|parent::refsect2|parent::refsect3|parent::refsection|                                 parent::refsynopsisdiv|parent::sect1|parent::sect2|parent::sect3|parent::sect4|                                 parent::sect5|parent::section|parent::setindex|parent::sidebar|                                 parent::simplesect|parent::taskprerequisites|parent::taskrelated|                                 parent::tasksummary|parent::warning|parent::topic]|remark[parent::answer|parent::appendix|parent::article|parent::bibliodiv|                                 parent::bibliography|parent::blockquote|parent::caution|parent::chapter|                                 parent::glossary|parent::glossdiv|parent::important|parent::index|                                 parent::indexdiv|parent::listitem|parent::note|parent::orderedlist|                                 parent::partintro|parent::preface|parent::procedure|parent::qandadiv|                                 parent::qandaset|parent::question|parent::refentry|parent::refnamediv|                                 parent::refsect1|parent::refsect2|parent::refsect3|parent::refsection|                                 parent::refsynopsisdiv|parent::sect1|parent::sect2|parent::sect3|parent::sect4|                                 parent::sect5|parent::section|parent::setindex|parent::sidebar|                                 parent::simplesect|parent::taskprerequisites|parent::taskrelated|                                 parent::tasksummary|parent::warning|parent::topic]">
        <xsl:if test="$show.comments != 0">
            <p class="{$class.prefix}remark">
                <em>
                    <xsl:call-template name="inline.charseq"/>
                </em>
            </p>
        </xsl:if>
    </xsl:template>
    <xsl:template match="comment|remark">
        <xsl:if test="$show.comments != 0">
            <em>
                <xsl:call-template name="inline.charseq"/>
            </em>
        </xsl:if>
    </xsl:template>
    <xsl:template match="productname">
        <xsl:call-template name="inline.charseq"/>
        <xsl:if test="@class">
            <xsl:call-template name="dingbat">
                <xsl:with-param name="dingbat" select="@class"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template match="productnumber">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="pob|street|city|state|postcode|country|otheraddr">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="phone|fax">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="honorific|firstname|surname|lineage|othername">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="person">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:apply-templates select="personname"/>
                </xsl:with-param>
            </xsl:call-template>
            <xsl:call-template name="apply-annotations"/>
        </xsl:param>

        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:copy-of select="$content"/>
        </span>
    </xsl:template>
    <xsl:template match="personname">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:call-template name="person.name"/>
                </xsl:with-param>
            </xsl:call-template>
            <xsl:call-template name="apply-annotations"/>
        </xsl:param>

        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:copy-of select="$content"/>
        </span>
    </xsl:template>
    <xsl:template match="org">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:apply-templates/>
                </xsl:with-param>
            </xsl:call-template>
            <xsl:call-template name="apply-annotations"/>
        </xsl:param>

        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:copy-of select="$content"/>
        </span>
    </xsl:template>
    <xsl:template match="orgname">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:apply-templates/>
                </xsl:with-param>
            </xsl:call-template>
            <xsl:call-template name="apply-annotations"/>
        </xsl:param>

        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:copy-of select="$content"/>
        </span>
    </xsl:template>
    <xsl:template match="orgdiv">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:apply-templates/>
                </xsl:with-param>
            </xsl:call-template>
            <xsl:call-template name="apply-annotations"/>
        </xsl:param>

        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:copy-of select="$content"/>
        </span>
    </xsl:template>
    <xsl:template match="affiliation">
        <xsl:param name="content">
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="simple.xlink">
                <xsl:with-param name="content">
                    <xsl:call-template name="person.name"/>
                </xsl:with-param>
            </xsl:call-template>
            <xsl:call-template name="apply-annotations"/>
        </xsl:param>

        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:copy-of select="$content"/>
        </span>
    </xsl:template>
    <xsl:template match="beginpage">
        <!-- does nothing; this *is not* markup to force a page break. -->
    </xsl:template>
    <xsl:template match="footnoteref">
        <xsl:variable name="targets" select="key('id',@linkend)"/>
        <xsl:variable name="footnote" select="$targets[1]"/>

        <xsl:if test="not(local-name($footnote) = 'footnote')">
            <xsl:message terminate="yes">
                ERROR: A footnoteref element has a linkend that points to an element that is not a footnote.
                Typically this happens when an id attribute is accidentally applied to the child of a footnote element.
                target element:
                <xsl:value-of select="local-name($footnote)"/>
                linkend/id:
                <xsl:value-of select="@linkend"/>
            </xsl:message>
        </xsl:if>

        <xsl:variable name="target.href">
            <xsl:call-template name="href.target">
                <xsl:with-param name="object" select="$footnote"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="href">
            <xsl:value-of select="substring-before($target.href, '#')"/>
            <xsl:text>#ftn.</xsl:text>
            <xsl:value-of select="substring-after($target.href, '#')"/>
        </xsl:variable>

        <a href="{$href}">
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:call-template name="id.attribute"/>
            <sup>
                <xsl:apply-templates select="." mode="class.attribute"/>
                <xsl:text>[</xsl:text>
                <xsl:apply-templates select="$footnote" mode="footnote.number"/>
                <xsl:text>]</xsl:text>
            </sup>
        </a>
    </xsl:template>
    <xsl:template match="footnote" mode="footnote.number">
        <xsl:choose>
            <xsl:when test="string-length(@label) != 0">
                <xsl:value-of select="@label"/>
            </xsl:when>
            <xsl:when test="ancestor::table or ancestor::informaltable">
                <xsl:variable name="tfnum">
                    <xsl:number level="any" from="table|informaltable" format="1"/>
                </xsl:variable>

                <xsl:choose>
                    <xsl:when test="string-length($table.footnote.number.symbols) &gt;= $tfnum">
                        <xsl:value-of select="substring($table.footnote.number.symbols, $tfnum, 1)"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:number level="any" from="table | informaltable" format="{$table.footnote.number.format}"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="pfoot" select="preceding::footnote[not(@label)]"/>
                <xsl:variable name="ptfoot"
                              select="preceding::table//footnote |                                           preceding::informaltable//footnote"/>
                <xsl:variable name="fnum" select="count($pfoot) - count($ptfoot) + 1"/>

                <xsl:choose>
                    <xsl:when test="string-length($footnote.number.symbols) &gt;= $fnum">
                        <xsl:value-of select="substring($footnote.number.symbols, $fnum, 1)"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:number value="$fnum" format="{$footnote.number.format}"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="footnote/para[1]|footnote/simpara[1]" priority="2">
        <!-- this only works if the first thing in a footnote is a para, -->
        <!-- which is ok, because it usually is. -->
        <xsl:variable name="href">
            <xsl:text>#</xsl:text>
            <xsl:call-template name="object.id">
                <xsl:with-param name="object" select="ancestor::footnote"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:call-template name="paragraph">
            <xsl:with-param name="class">
                <xsl:if test="@role and $para.propagates.style != 0">
                    <xsl:value-of select="@role"/>
                </xsl:if>
            </xsl:with-param>
            <xsl:with-param name="content">
                <a href="{$href}">
                    <xsl:apply-templates select="." mode="class.attribute"/>
                    <sup>
                        <xsl:apply-templates select="." mode="class.attribute"/>
                        <xsl:text>[</xsl:text>
                        <xsl:apply-templates select="ancestor::footnote" mode="footnote.number"/>
                        <xsl:text>] </xsl:text>
                    </sup>
                </a>
                <xsl:apply-templates/>
            </xsl:with-param>
        </xsl:call-template>

    </xsl:template>
    <xsl:template match="*" mode="footnote.body.number">
        <xsl:variable name="name">
            <xsl:text>ftn.</xsl:text>
            <xsl:call-template name="object.id">
                <xsl:with-param name="object" select="ancestor::footnote"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="href">
            <xsl:text>#</xsl:text>
            <xsl:call-template name="object.id">
                <xsl:with-param name="object" select="ancestor::footnote"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="footnote.mark">
            <a href="{$href}">
                <xsl:apply-templates select="." mode="class.attribute"/>
                <xsl:choose>
                    <xsl:when test="$generate.id.attributes = 0">
                        <xsl:if test="@id or @xml:id">
                            <xsl:attribute name="id">
                                <xsl:value-of select="@id|@xml:id"/>
                            </xsl:attribute>
                        </xsl:if>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="id.attribute"/>
                    </xsl:otherwise>
                </xsl:choose>
                <sup>
                    <xsl:text>[</xsl:text>
                    <xsl:apply-templates select="ancestor::footnote" mode="footnote.number"/>
                    <xsl:text>] </xsl:text>
                </sup>
            </a>
        </xsl:variable>

        <xsl:variable name="html">
            <xsl:apply-templates select="."/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$exsl.node.set.available != 0">
                <xsl:variable name="html-nodes" select="exsl:node-set($html)"/>
                <xsl:choose>
                    <xsl:when test="$html-nodes//p">
                        <xsl:apply-templates select="$html-nodes" mode="insert.html.p">
                            <xsl:with-param name="mark" select="$footnote.mark"/>
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="$html-nodes" mode="insert.html.text">
                            <xsl:with-param name="mark" select="$footnote.mark"/>
                        </xsl:apply-templates>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="$html"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="process.footnotes">
        <xsl:variable name="footnotes" select=".//footnote"/>
        <xsl:variable name="table.footnotes" select=".//table//footnote | .//informaltable//footnote"/>

        <!-- Only bother to do this if there's at least one non-table footnote -->
        <xsl:if test="count($footnotes)&gt;count($table.footnotes)">
            <div class="{$class.prefix}footnotes">
                <xsl:call-template name="footnotes.attributes"/>
                <br/>
                <hr>
                    <xsl:choose>
                        <xsl:when test="$make.clean.html != 0">
                            <xsl:attribute name="class"><xsl:value-of select="$class.prefix"/>footnote-hr
                            </xsl:attribute>
                        </xsl:when>
                        <xsl:when test="$css.decoration != 0">
                            <xsl:attribute name="style">
                                <xsl:value-of
                                        select="concat('width:100; text-align:',                                             $direction.align.start,                                             ';',          'margin-', $direction.align.start, ': 0')"/>
                            </xsl:attribute>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:attribute name="width">100</xsl:attribute>
                            <xsl:attribute name="align">
                                <xsl:value-of select="$direction.align.start"/>
                            </xsl:attribute>
                        </xsl:otherwise>
                    </xsl:choose>
                </hr>
                <xsl:apply-templates select="$footnotes" mode="process.footnote.mode"/>
            </div>
        </xsl:if>

        <xsl:if test="$annotation.support != 0 and //annotation">
            <div class="{$class.prefix}annotation-list">
                <div class="{$class.prefix}annotation-nocss">
                    <p>The following annotations are from this essay. You are seeing
                        them here because your browser doesn’t support the user-interface
                        techniques used to make them appear as ‘popups’ on modern browsers.
                    </p>
                </div>

                <xsl:apply-templates select="//annotation" mode="annotation-popup"/>
            </div>
        </xsl:if>
    </xsl:template>
    <xsl:template name="footnotes.attributes">
        <!-- customizable for footnotes attributes -->
    </xsl:template>
    <xsl:template name="process.chunk.footnotes">
        <!-- nop -->
    </xsl:template>
    <xsl:template match="footnote" name="process.footnote" mode="process.footnote.mode">
        <xsl:variable name="id">
            <xsl:text>ftn.</xsl:text>
            <xsl:call-template name="object.id">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="local-name(*[1]) = 'para' or local-name(*[1]) = 'simpara'">
                <div id="{$id}">
                    <xsl:call-template name="common.html.attributes"/>
                    <xsl:apply-templates/>
                </div>
            </xsl:when>

            <xsl:when test="$html.cleanup != 0 and                      $exsl.node.set.available != 0">
                <div id="{$id}">
                    <xsl:call-template name="common.html.attributes"/>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:apply-templates select="*[1]" mode="footnote.body.number"/>
                    <xsl:apply-templates select="*[position() &gt; 1]"/>
                </div>
            </xsl:when>

            <xsl:otherwise>
                <xsl:message>
                    <xsl:text>Warning: footnote number may not be generated </xsl:text>
                    <xsl:text>correctly; </xsl:text>
                    <xsl:value-of select="local-name(*[1])"/>
                    <xsl:text> unexpected as first child of footnote.</xsl:text>
                </xsl:message>
                <div id="{$id}">
                    <xsl:call-template name="common.html.attributes"/>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:apply-templates/>
                </div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template match="table//footnote | informaltable//footnote" mode="process.footnote.mode">
    </xsl:template>

    <xsl:template match="footnote" mode="table.footnote.mode">
        <xsl:call-template name="process.footnote"/>
    </xsl:template>

    <xsl:variable name="direction.align.start">
        <xsl:choose>
            <xsl:when test="starts-with($writing.mode, 'lr')">left</xsl:when>
            <xsl:when test="starts-with($writing.mode, 'rl')">right</xsl:when>
            <xsl:otherwise>left</xsl:otherwise>
        </xsl:choose>
    </xsl:variable>
    <xsl:variable name="direction.align.end">
        <xsl:choose>
            <xsl:when test="starts-with($writing.mode, 'lr')">right</xsl:when>
            <xsl:when test="starts-with($writing.mode, 'rl')">left</xsl:when>
            <xsl:otherwise>right</xsl:otherwise>
        </xsl:choose>
    </xsl:variable>
    <xsl:variable name="direction.mode">
        <xsl:choose>
            <xsl:when test="starts-with($writing.mode, 'lr')">ltr</xsl:when>
            <xsl:when test="starts-with($writing.mode, 'rl')">rtl</xsl:when>
            <xsl:otherwise>ltr</xsl:otherwise>
        </xsl:choose>
    </xsl:variable>
    <xsl:variable name="div.element">div</xsl:variable>
    <xsl:variable name="table.border.off">0</xsl:variable>
    <xsl:template name="generate.html.title">
        <xsl:apply-templates select="." mode="html.title.attribute"/>
    </xsl:template>
    <xsl:template match="acronym|abbrev" mode="html.title.attribute">
        <xsl:if test="alt">
            <xsl:attribute name="title">
                <xsl:value-of select="normalize-space(alt)"/>
            </xsl:attribute>
        </xsl:if>
    </xsl:template>
    <xsl:template match="qandaentry" mode="html.title.attribute">
        <xsl:apply-templates select="question" mode="html.title.attribute"/>
    </xsl:template>
    <xsl:template match="question" mode="html.title.attribute">
        <xsl:variable name="label.text">
            <xsl:apply-templates select="." mode="qanda.label"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="string-length($label.text) != 0">
                <xsl:attribute name="title">
                    <xsl:value-of select="$label.text"/>
                </xsl:attribute>
            </xsl:when>
            <!-- Fall back to alt if available -->
            <xsl:when test="alt">
                <xsl:attribute name="title">
                    <xsl:value-of select="normalize-space(alt)"/>
                </xsl:attribute>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="dir">
        <xsl:param name="inherit" select="0"/>

        <xsl:variable name="dir">
            <xsl:choose>
                <xsl:when test="@dir">
                    <xsl:value-of select="@dir"/>
                </xsl:when>
                <xsl:when test="$inherit != 0">
                    <xsl:value-of select="ancestor::*/@dir[1]"/>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:if test="$dir != ''">
            <xsl:attribute name="dir">
                <xsl:value-of select="$dir"/>
            </xsl:attribute>
        </xsl:if>
    </xsl:template>
    <xsl:template name="anchor">
        <xsl:param name="node" select="."/>
        <xsl:param name="conditional" select="1"/>

        <xsl:choose>
            <xsl:when test="$generate.id.attributes != 0">
                <!-- No named anchors output when this param is set -->
            </xsl:when>
            <xsl:when test="$conditional = 0 or $node/@id or $node/@xml:id">
                <a>
                    <xsl:attribute name="id">
                        <xsl:call-template name="object.id">
                            <xsl:with-param name="object" select="$node"/>
                        </xsl:call-template>
                    </xsl:attribute>
                </a>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="id.attribute">
        <xsl:param name="node" select="."/>
        <xsl:param name="conditional" select="1"/>
        <xsl:choose>
            <xsl:when test="$generate.id.attributes = 0">
                <!-- No id attributes when this param is zero -->
            </xsl:when>
            <xsl:when test="$conditional = 0 or $node/@id or $node/@xml:id">
                <xsl:attribute name="id">
                    <xsl:call-template name="object.id">
                        <xsl:with-param name="object" select="$node"/>
                    </xsl:call-template>
                </xsl:attribute>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="href.target.uri">
        <xsl:param name="context" select="."/>
        <xsl:param name="object" select="."/>
        <xsl:text>#</xsl:text>
        <xsl:call-template name="object.id">
            <xsl:with-param name="object" select="$object"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="href.target">
        <xsl:param name="context" select="."/>
        <xsl:param name="object" select="."/>
        <xsl:text>#</xsl:text>
        <xsl:call-template name="object.id">
            <xsl:with-param name="object" select="$object"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="href.target.with.base.dir">
        <xsl:param name="context" select="."/>
        <xsl:param name="object" select="."/>
        <xsl:if test="$manifest.in.base.dir = 0">
            <xsl:value-of select="$chunk.base.dir"/>
        </xsl:if>
        <xsl:call-template name="href.target">
            <xsl:with-param name="context" select="$context"/>
            <xsl:with-param name="object" select="$object"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="dingbat">
        <xsl:param name="dingbat">bullet</xsl:param>
        <xsl:call-template name="dingbat.characters">
            <xsl:with-param name="dingbat" select="$dingbat"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="dingbat.characters">
        <!-- now that I'm using the real serializer, all that dingbat malarky -->
        <!-- isn't necessary anymore... -->
        <xsl:param name="dingbat">bullet</xsl:param>
        <xsl:choose>
            <xsl:when test="$dingbat='bullet'">•</xsl:when>
            <xsl:when test="$dingbat='copyright'">©</xsl:when>
            <xsl:when test="$dingbat='trademark'">™</xsl:when>
            <xsl:when test="$dingbat='trade'">™</xsl:when>
            <xsl:when test="$dingbat='registered'">®</xsl:when>
            <xsl:when test="$dingbat='service'">(SM)</xsl:when>
            <xsl:when test="$dingbat='nbsp'"></xsl:when>
            <xsl:when test="$dingbat='ldquo'">“</xsl:when>
            <xsl:when test="$dingbat='rdquo'">”</xsl:when>
            <xsl:when test="$dingbat='lsquo'">‘</xsl:when>
            <xsl:when test="$dingbat='rsquo'">’</xsl:when>
            <xsl:when test="$dingbat='em-dash'">—</xsl:when>
            <xsl:when test="$dingbat='mdash'">—</xsl:when>
            <xsl:when test="$dingbat='en-dash'">–</xsl:when>
            <xsl:when test="$dingbat='ndash'">–</xsl:when>
            <xsl:otherwise>
                <xsl:text>•</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="id.warning">
        <xsl:if test="$id.warnings != 0 and not(@id) and not(@xml:id) and parent::*">
            <xsl:variable name="title">
                <xsl:choose>
                    <xsl:when test="title">
                        <xsl:value-of select="title[1]"/>
                    </xsl:when>
                    <xsl:when
                            test="substring(local-name(*[1]),                                   string-length(local-name(*[1])-3) = 'info')                         and *[1]/title">
                        <xsl:value-of select="*[1]/title[1]"/>
                    </xsl:when>
                    <xsl:when test="refmeta/refentrytitle">
                        <xsl:value-of select="refmeta/refentrytitle"/>
                    </xsl:when>
                    <xsl:when test="refnamediv/refname">
                        <xsl:value-of select="refnamediv/refname[1]"/>
                    </xsl:when>
                </xsl:choose>
            </xsl:variable>

            <xsl:message>
                <xsl:text>ID recommended on </xsl:text>
                <xsl:value-of select="local-name(.)"/>
                <xsl:if test="$title != ''">
                    <xsl:text>: </xsl:text>
                    <xsl:choose>
                        <xsl:when test="string-length($title) &gt; 40">
                            <xsl:value-of select="substring($title,1,40)"/>
                            <xsl:text>...</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$title"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:if>
            </xsl:message>
        </xsl:if>
    </xsl:template>
    <xsl:template name="generate.class.attribute">
        <xsl:param name="class" select="local-name(.)"/>
        <xsl:apply-templates select="." mode="class.attribute">
            <xsl:with-param name="class" select="$class"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="*" mode="class.value">
        <xsl:param name="class" select="local-name(.)"/>
        <!-- permit customization of class value only -->
        <!-- Use element name by default -->
        <xsl:if test="$class != ''">
            <xsl:text>docbook-</xsl:text>
        </xsl:if>
        <xsl:value-of select="$class"/>
    </xsl:template>
    <xsl:template name="common.html.attributes">
        <xsl:param name="inherit" select="0"/>
        <xsl:param name="class" select="local-name(.)"/>
        <xsl:apply-templates select="." mode="common.html.attributes">
            <xsl:with-param name="class" select="$class"/>
            <xsl:with-param name="inherit" select="$inherit"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="*" mode="common.html.attributes">
        <xsl:param name="class" select="local-name(.)"/>
        <xsl:param name="inherit" select="0"/>
        <xsl:call-template name="generate.html.lang"/>
        <xsl:call-template name="dir">
            <xsl:with-param name="inherit" select="$inherit"/>
        </xsl:call-template>
        <xsl:apply-templates select="." mode="class.attribute">
            <xsl:with-param name="class" select="$class"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template name="locale.html.attributes">
        <xsl:apply-templates select="." mode="locale.html.attributes"/>
    </xsl:template>
    <xsl:template match="*" mode="locale.html.attributes">
        <xsl:call-template name="generate.html.lang"/>
        <xsl:call-template name="dir"/>
    </xsl:template>
    <xsl:template name="generate.html.lang">
        <xsl:apply-templates select="." mode="html.lang.attribute"/>
    </xsl:template>
    <xsl:template match="*" mode="html.lang.attribute">
        <!-- match the attribute name to the output type -->
        <xsl:choose>
            <xsl:when test="@lang and $stylesheet.result.type = 'html'">
                <xsl:attribute name="lang">
                    <xsl:value-of select="@lang"/>
                </xsl:attribute>
            </xsl:when>
            <xsl:when test="@lang and $stylesheet.result.type = 'xhtml'">
                <xsl:attribute name="xml:lang">
                    <xsl:value-of select="@lang"/>
                </xsl:attribute>
            </xsl:when>
            <xsl:when test="@xml:lang and $stylesheet.result.type = 'html'">
                <xsl:attribute name="lang">
                    <xsl:value-of select="@xml:lang"/>
                </xsl:attribute>
            </xsl:when>
            <xsl:when test="@xml:lang and $stylesheet.result.type = 'xhtml'">
                <xsl:attribute name="xml:lang">
                    <xsl:value-of select="@xml:lang"/>
                </xsl:attribute>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="generate.css">
        <xsl:choose>
            <xsl:when test="$generate.css.header = 0">
                <xsl:call-template name="generate.css.links"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="generate.css.headers"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="generate.css.headers">
        <xsl:call-template name="generate.default.css.header"/>
        <xsl:call-template name="generate.custom.css.header"/>
    </xsl:template>

    <xsl:template name="generate.default.css.header">
        <xsl:if test="$make.clean.html != 0 and                  $docbook.css != ''">
            <style type="text/css">
                <xsl:copy-of select="$docbook.css"/>
            </style>
        </xsl:if>
    </xsl:template>

    <xsl:template name="generate.custom.css.header">
        <xsl:if test="$custom.css != ''">
            <style type="text/css">
                <xsl:copy-of select="$custom.css"/>
            </style>
        </xsl:if>
    </xsl:template>

    <xsl:template name="output.css.header">
        <xsl:param name="css.node"/>

        <xsl:choose>
            <xsl:when test="count($css.node) = 0">
            </xsl:when>
            <xsl:otherwise>
                <style type="text/css">
                    <xsl:copy-of select="$css.node/text()"/>
                </style>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="generate.css.links">
        <xsl:call-template name="generate.default.css.link"/>
        <xsl:call-template name="generate.custom.css.link"/>
    </xsl:template>

    <xsl:template name="generate.default.css.link">
        <xsl:if test="$make.clean.html != 0 and                  $docbook.css.link != 0 and                 $docbook.css.filename != ''">
            <xsl:call-template name="make.css.link">
                <xsl:with-param name="css.filename" select="$docbook.css.filename"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>

    <xsl:template name="generate.custom.css.link">
        <xsl:if test="$custom.css.filename != ''">
            <xsl:call-template name="make.css.link">
                <xsl:with-param name="css.filename" select="$custom.css.filename"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>

    <xsl:template name="make.css.link">
        <xsl:param name="css.filename" select="''"/>

        <xsl:variable name="href">
            <xsl:call-template name="relative.path.link">
                <xsl:with-param name="target.pathname" select="$css.filename"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:if test="string-length($css.filename) != 0">
            <link rel="stylesheet" type="text/css" href="{$href}"/>
        </xsl:if>
    </xsl:template>
    <xsl:template name="make.script.link">
        <xsl:param name="script.filename" select="''"/>

        <xsl:variable name="src">
            <xsl:call-template name="relative.path.link">
                <xsl:with-param name="target.pathname" select="$script.filename"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:if test="string-length($script.filename) != 0">
            <script>
                <xsl:attribute name="src">
                    <xsl:value-of select="$src"/>
                </xsl:attribute>
                <xsl:attribute name="type">
                    <xsl:value-of select="$html.script.type"/>
                </xsl:attribute>
                <xsl:call-template name="other.script.attributes">
                    <xsl:with-param name="script.filename" select="$script.filename"/>
                </xsl:call-template>
            </script>
        </xsl:if>
    </xsl:template>
    <xsl:template name="other.script.attributes">
        <xsl:param name="script.filename"/>
        <!-- Placeholder template to allow customization to 
       insert additional script element attributes if needed -->
    </xsl:template>
    <xsl:template name="relative.path.link">
        <xsl:param name="target.pathname"/>

        <xsl:variable name="href.to.uri" select="$target.pathname"/>

        <xsl:variable name="href.from.uri">
            <xsl:call-template name="href.target.uri">
                <xsl:with-param name="object" select="."/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="href.to">
            <xsl:call-template name="trim.common.uri.paths">
                <xsl:with-param name="uriA" select="$href.to.uri"/>
                <xsl:with-param name="uriB" select="$href.from.uri"/>
                <xsl:with-param name="return" select="'A'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="href.from">
            <xsl:call-template name="trim.common.uri.paths">
                <xsl:with-param name="uriA" select="$href.to.uri"/>
                <xsl:with-param name="uriB" select="$href.from.uri"/>
                <xsl:with-param name="return" select="'B'"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="depth">
            <xsl:call-template name="count.uri.path.depth">
                <xsl:with-param name="filename" select="$href.from"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="href">
            <xsl:call-template name="copy-string">
                <xsl:with-param name="string" select="'../'"/>
                <xsl:with-param name="count" select="$depth"/>
            </xsl:call-template>
            <xsl:value-of select="$href.to"/>
        </xsl:variable>

        <xsl:value-of select="$href"/>
    </xsl:template>

    <xsl:template name="generate.css.files">
        <xsl:call-template name="generate.default.css.file"/>
        <xsl:call-template name="generate.custom.css.file"/>
    </xsl:template>

    <xsl:template name="generate.default.css.file">
        <xsl:if test="$make.clean.html != 0 and                  $generate.css.header = 0 and                 $docbook.css != ''">
            <xsl:call-template name="generate.css.file">
                <xsl:with-param name="filename" select="$docbook.css.filename"/>
                <xsl:with-param name="src" select="$docbook.css"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>

    <xsl:template name="generate.custom.css.file">
        <xsl:if test="$custom.css != '' and                 $generate.css.header = 0">
            <xsl:call-template name="generate.css.file">
                <xsl:with-param name="filename" select="$custom.css.filename"/>
                <xsl:with-param name="src" select="$custom.css"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>

    <xsl:template name="generate.css.file">
        <xsl:param name="src" select="''"/>
        <xsl:param name="filename"/>

        <xsl:call-template name="write.text.chunk">
            <xsl:with-param name="filename" select="$filename"/>
            <xsl:with-param name="content" select="$src"/>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="css.output.filename">
        <xsl:param name="content"/>
        <xsl:param name="src" select="''"/>

        <xsl:variable name="candidate">
            <xsl:choose>
                <xsl:when test="string-length($src) = 0">
                    <xsl:message>
                        <xsl:text>ERROR: missing CSS input filename.</xsl:text>
                    </xsl:message>
                </xsl:when>
                <xsl:when test="substring($src,string-length($src)-3) = '.xml'">
                    <xsl:value-of select="substring($src, 1, string-length($src) - 4)"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$src"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:value-of select="$candidate"/>
    </xsl:template>

    <xsl:template name="css.output.pathname">
        <xsl:param name="content"/>
        <xsl:param name="src" select="''"/>

        <xsl:variable name="file">
            <xsl:call-template name="css.output.filename">
                <xsl:with-param name="content" select="$content"/>
                <xsl:with-param name="src" select="$src"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="path" select="concat($chunk.base.dir, $file)"/>
        <xsl:value-of select="$path"/>

    </xsl:template>

    <xsl:template match="corpauthor">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates/>
        </span>
    </xsl:template>
    <xsl:template match="jobtitle">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates/>
        </span>
    </xsl:template>
    <xsl:template match="keywordset"/>
    <xsl:template match="subjectset"/>
    <xsl:template match="keywordset" mode="html.header">
        <meta name="keywords">
            <xsl:attribute name="content">
                <xsl:apply-templates select="keyword" mode="html.header"/>
            </xsl:attribute>
        </meta>
    </xsl:template>
    <xsl:template match="keyword" mode="html.header">
        <xsl:apply-templates/>
        <xsl:if test="following-sibling::keyword">,</xsl:if>
    </xsl:template>
    <xsl:template match="set">
        <xsl:call-template name="id.warning"/>

        <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:call-template name="dir">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="language.attribute"/>
            <xsl:if test="$generate.id.attributes != 0">
                <xsl:attribute name="id">
                    <xsl:call-template name="object.id"/>
                </xsl:attribute>
            </xsl:if>

            <xsl:call-template name="set.titlepage"/>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:call-template name="make.lots">
                <xsl:with-param name="toc.params" select="$toc.params"/>
                <xsl:with-param name="toc">
                    <xsl:call-template name="set.toc">
                        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                    </xsl:call-template>
                </xsl:with-param>
            </xsl:call-template>

            <xsl:apply-templates/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="set/setinfo"/>
    <xsl:template match="set/title"/>
    <xsl:template match="set/titleabbrev"/>
    <xsl:template match="set/subtitle"/>
    <xsl:template match="book">
        <xsl:call-template name="id.warning"/>

        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:call-template name="book.titlepage"/>

            <xsl:apply-templates select="dedication" mode="dedication"/>
            <xsl:apply-templates select="acknowledgements" mode="acknowledgements"/>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:call-template name="make.lots">
                <xsl:with-param name="toc.params" select="$toc.params"/>
                <xsl:with-param name="toc">
                    <xsl:call-template name="division.toc">
                        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                    </xsl:call-template>
                </xsl:with-param>
            </xsl:call-template>

            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="book/bookinfo"/>
    <xsl:template match="book/info"/>
    <xsl:template match="book/title"/>
    <xsl:template match="book/titleabbrev"/>
    <xsl:template match="book/subtitle"/>
    <xsl:template match="part">
        <xsl:call-template name="id.warning"/>

        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:call-template name="part.titlepage"/>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>
            <xsl:if test="not(partintro) and contains($toc.params, 'toc')">
                <xsl:call-template name="division.toc"/>
            </xsl:if>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="part" mode="make.part.toc">
        <xsl:call-template name="division.toc"/>
    </xsl:template>
    <xsl:template match="reference" mode="make.part.toc">
        <xsl:call-template name="division.toc"/>
    </xsl:template>
    <xsl:template match="part/docinfo"/>
    <xsl:template match="part/partinfo"/>
    <xsl:template match="part/info"/>
    <xsl:template match="part/title"/>
    <xsl:template match="part/titleabbrev"/>
    <xsl:template match="part/subtitle"/>
    <xsl:template match="partintro">
        <xsl:call-template name="id.warning"/>

        <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:call-template name="partintro.titlepage"/>
            <xsl:apply-templates/>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="node" select="parent::*"/>
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>
            <xsl:if test="contains($toc.params, 'toc')">
                <!-- not ancestor::part because partintro appears in reference -->
                <xsl:apply-templates select="parent::*" mode="make.part.toc"/>
            </xsl:if>
            <xsl:call-template name="process.footnotes"/>
        </div>
    </xsl:template>
    <xsl:template match="partintro/title"/>
    <xsl:template match="partintro/titleabbrev"/>
    <xsl:template match="partintro/subtitle"/>
    <xsl:template match="partintro/title" mode="partintro.title.mode">
        <h2>
            <xsl:apply-templates/>
        </h2>
    </xsl:template>
    <xsl:template match="partintro/subtitle" mode="partintro.title.mode">
        <h3>
            <em>
                <xsl:apply-templates/>
            </em>
        </h3>
    </xsl:template>
    <xsl:template match="book" mode="division.number">
        <xsl:number from="set" count="book" format="1."/>
    </xsl:template>
    <xsl:template match="part" mode="division.number">
        <xsl:number from="book" count="part" format="I."/>
    </xsl:template>
    <xsl:template name="division.title">
        <xsl:param name="node" select="."/>

        <h1>
            <xsl:attribute name="class"><xsl:value-of select="$class.prefix"/>title
            </xsl:attribute>
            <xsl:call-template name="anchor">
                <xsl:with-param name="node" select="$node"/>
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:apply-templates select="$node" mode="object.title.markup">
                <xsl:with-param name="allow-anchors" select="1"/>
            </xsl:apply-templates>
        </h1>
    </xsl:template>
    <xsl:template match="set/toc | book/toc | part/toc">
        <xsl:variable name="toc.params">
            <xsl:call-template name="find.path.params">
                <xsl:with-param name="node" select="parent::*"/>
                <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
            </xsl:call-template>
        </xsl:variable>

        <!-- Do not output the toc element if one is already generated
       by the use of $generate.toc parameter, or if
       generating a source toc is turned off -->
        <xsl:if test="not(contains($toc.params, 'toc')) and                 ($process.source.toc != 0 or $process.empty.source.toc != 0)">
            <xsl:variable name="content">
                <xsl:choose>
                    <xsl:when test="* and $process.source.toc != 0">
                        <xsl:apply-templates/>
                    </xsl:when>
                    <xsl:when test="count(*) = 0 and $process.empty.source.toc != 0">
                        <!-- trick to switch context node to parent element -->
                        <xsl:for-each select="parent::*">
                            <xsl:choose>
                                <xsl:when test="self::set">
                                    <xsl:call-template name="set.toc">
                                        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                                    </xsl:call-template>
                                </xsl:when>
                                <xsl:when test="self::book">
                                    <xsl:call-template name="division.toc">
                                        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                                    </xsl:call-template>
                                </xsl:when>
                                <xsl:when test="self::part">
                                    <xsl:call-template name="division.toc">
                                        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                                    </xsl:call-template>
                                </xsl:when>
                            </xsl:choose>
                        </xsl:for-each>
                    </xsl:when>
                </xsl:choose>
            </xsl:variable>

            <xsl:if test="string-length(normalize-space($content)) != 0">
                <xsl:copy-of select="$content"/>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    <xsl:template match="chapter/toc | appendix/toc | preface/toc | article/toc">
        <xsl:variable name="toc.params">
            <xsl:call-template name="find.path.params">
                <xsl:with-param name="node" select="parent::*"/>
                <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
            </xsl:call-template>
        </xsl:variable>

        <!-- Do not output the toc element if one is already generated
       by the use of $generate.toc parameter, or if
       generating a source toc is turned off -->
        <xsl:if test="not(contains($toc.params, 'toc')) and                 ($process.source.toc != 0 or $process.empty.source.toc != 0)">
            <xsl:choose>
                <xsl:when test="* and $process.source.toc != 0">
                    <div>
                        <xsl:apply-templates select="." mode="common.html.attributes"/>
                        <xsl:call-template name="id.attribute"/>
                        <xsl:apply-templates select="title"/>
                        <dl>
                            <xsl:apply-templates select="." mode="common.html.attributes"/>
                            <xsl:apply-templates select="*[not(self::title)]"/>
                        </dl>
                    </div>
                    <xsl:call-template name="component.toc.separator"/>
                </xsl:when>
                <xsl:when test="count(*) = 0 and $process.empty.source.toc != 0">
                    <!-- trick to switch context node to section element -->
                    <xsl:for-each select="parent::*">
                        <xsl:call-template name="component.toc">
                            <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                        </xsl:call-template>
                    </xsl:for-each>
                    <xsl:call-template name="component.toc.separator"/>
                </xsl:when>
            </xsl:choose>
        </xsl:if>
    </xsl:template>
    <xsl:template
            match="section/toc                     |sect1/toc                     |sect2/toc                     |sect3/toc                     |sect4/toc                     |sect5/toc">

        <xsl:variable name="toc.params">
            <xsl:call-template name="find.path.params">
                <xsl:with-param name="node" select="parent::*"/>
                <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
            </xsl:call-template>
        </xsl:variable>

        <!-- Do not output the toc element if one is already generated
       by the use of $generate.toc parameter, or if
       generating a source toc is turned off -->
        <xsl:if test="not(contains($toc.params, 'toc')) and                 ($process.source.toc != 0 or $process.empty.source.toc != 0)">
            <xsl:choose>
                <xsl:when test="* and $process.source.toc != 0">
                    <div>
                        <xsl:apply-templates select="." mode="common.html.attributes"/>
                        <xsl:call-template name="id.attribute"/>
                        <xsl:apply-templates select="title"/>
                        <dl>
                            <xsl:apply-templates select="." mode="common.html.attributes"/>
                            <xsl:apply-templates select="*[not(self::title)]"/>
                        </dl>
                    </div>
                    <xsl:call-template name="section.toc.separator"/>
                </xsl:when>
                <xsl:when test="count(*) = 0 and $process.empty.source.toc != 0">
                    <!-- trick to switch context node to section element -->
                    <xsl:for-each select="parent::*">
                        <xsl:call-template name="section.toc">
                            <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                        </xsl:call-template>
                    </xsl:for-each>
                    <xsl:call-template name="section.toc.separator"/>
                </xsl:when>
            </xsl:choose>
        </xsl:if>
    </xsl:template>
    <xsl:template match="tocpart|tocchap                      |toclevel1|toclevel2|toclevel3|toclevel4|toclevel5">
        <xsl:variable name="sub-toc">
            <xsl:if test="tocchap|toclevel1|toclevel2|toclevel3|toclevel4|toclevel5">
                <xsl:choose>
                    <xsl:when test="$toc.list.type = 'dl'">
                        <dd>
                            <xsl:apply-templates select="." mode="common.html.attributes"/>
                            <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
                                <xsl:apply-templates select="." mode="common.html.attributes"/>
                                <xsl:apply-templates
                                        select="tocchap|toclevel1|toclevel2|                                            toclevel3|toclevel4|toclevel5"/>
                            </xsl:element>
                        </dd>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:element name="{$toc.list.type}" namespace="http://www.w3.org/1999/xhtml">
                            <xsl:apply-templates select="." mode="common.html.attributes"/>
                            <xsl:apply-templates
                                    select="tocchap|toclevel1|toclevel2|                                          toclevel3|toclevel4|toclevel5"/>
                        </xsl:element>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:if>
        </xsl:variable>

        <xsl:apply-templates select="tocentry[position() != last()]"/>

        <xsl:choose>
            <xsl:when test="$toc.list.type = 'dl'">
                <dt>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:apply-templates select="tocentry[position() = last()]"/>
                </dt>
                <xsl:copy-of select="$sub-toc"/>
            </xsl:when>
            <xsl:otherwise>
                <li>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:apply-templates select="tocentry[position() = last()]"/>
                    <xsl:copy-of select="$sub-toc"/>
                </li>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="tocentry|tocdiv|lotentry|tocfront|tocback">
        <xsl:choose>
            <xsl:when test="$toc.list.type = 'dl'">
                <dt>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:call-template name="tocentry-content"/>
                </dt>
            </xsl:when>
            <xsl:otherwise>
                <li>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:call-template name="tocentry-content"/>
                </li>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="tocentry[position() = last()]" priority="2">
        <xsl:call-template name="tocentry-content"/>
    </xsl:template>
    <xsl:template name="tocentry-content">
        <xsl:variable name="targets" select="key('id',@linkend)"/>
        <xsl:variable name="target" select="$targets[1]"/>

        <xsl:choose>
            <xsl:when test="@linkend">
                <xsl:call-template name="check.id.unique">
                    <xsl:with-param name="linkend" select="@linkend"/>
                </xsl:call-template>
                <a>
                    <xsl:attribute name="href">
                        <xsl:call-template name="href.target">
                            <xsl:with-param name="object" select="$target"/>
                        </xsl:call-template>
                    </xsl:attribute>
                    <xsl:apply-templates/>
                </a>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="toc/title">
        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="toc/subtitle">
        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="toc/titleabbrev">
    </xsl:template>
    <xsl:template match="book/lot | part/lot">
        <!-- Don't generate a page sequence unless there is content -->
        <xsl:variable name="content">
            <xsl:choose>
                <xsl:when test="* and $process.source.toc != 0">
                    <div>
                        <xsl:apply-templates select="." mode="common.html.attributes"/>
                        <xsl:apply-templates/>
                    </div>
                </xsl:when>
                <xsl:when test="not(child::*) and $process.empty.source.toc != 0">
                    <xsl:call-template name="process.empty.lot"/>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:if test="string-length(normalize-space($content)) != 0">
            <xsl:copy-of select="$content"/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="chapter/lot | appendix/lot | preface/lot | article/lot">
        <xsl:choose>
            <xsl:when test="* and $process.source.toc != 0">
                <div>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:apply-templates/>
                </div>
                <xsl:call-template name="component.toc.separator"/>
            </xsl:when>
            <xsl:when test="not(child::*) and $process.empty.source.toc != 0">
                <xsl:call-template name="process.empty.lot"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template
            match="section/lot                     |sect1/lot                     |sect2/lot                     |sect3/lot                     |sect4/lot                     |sect5/lot">
        <xsl:choose>
            <xsl:when test="* and $process.source.toc != 0">
                <div>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:apply-templates/>
                </div>
                <xsl:call-template name="section.toc.separator"/>
            </xsl:when>
            <xsl:when test="not(child::*) and $process.empty.source.toc != 0">
                <xsl:call-template name="process.empty.lot"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="process.empty.lot">
        <!-- An empty lot element does not provide any information to indicate
       what should be included in it.  You can customize this
       template to generate a lot based on @role or something -->
        <xsl:message>
            <xsl:text>Warning: don't know what to generate for </xsl:text>
            <xsl:text>lot that has no children.</xsl:text>
        </xsl:message>
    </xsl:template>
    <xsl:template match="lot/title">
        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="lot/subtitle">
        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="lot/titleabbrev">
    </xsl:template>
    <xsl:template match="index">
        <!-- some implementations use completely empty index tags to indicate -->
        <!-- where an automatically generated index should be inserted. so -->
        <!-- if the index is completely empty, skip it. Unless generate.index -->
        <!-- is non-zero, in which case, this is where the automatically -->
        <!-- generated index should go. -->

        <xsl:call-template name="id.warning"/>

        <xsl:if test="count(*)&gt;0 or $generate.index != '0'">
            <div>
                <xsl:apply-templates select="." mode="common.html.attributes"/>
                <xsl:call-template name="id.attribute">
                    <xsl:with-param name="conditional" select="0"/>
                </xsl:call-template>

                <xsl:call-template name="index.titlepage"/>
                <xsl:choose>
                    <xsl:when test="indexdiv">
                        <xsl:apply-templates/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="*[not(self::indexentry)]"/>
                        <!-- Because it's actually valid for Index to have neither any -->
                        <!-- Indexdivs nor any Indexentries, we need to check and make -->
                        <!-- sure that at least one Indexentry exists, and generate a -->
                        <!-- wrapper dl if there is at least one; otherwise, do nothing. -->
                        <xsl:if test="indexentry">
                            <!-- The indexentry template assumes a parent dl wrapper has -->
                            <!-- been generated; for Indexes that have Indexdivs, the dl -->
                            <!-- wrapper is generated by the indexdiv template; however, -->
                            <!-- for Indexes that lack Indexdivs, if we don't generate a -->
                            <!-- dl here, HTML output will not be valid. -->
                            <dl>
                                <xsl:apply-templates select="indexentry"/>
                            </dl>
                        </xsl:if>
                    </xsl:otherwise>
                </xsl:choose>

                <xsl:if test="count(indexentry) = 0 and count(indexdiv) = 0">
                    <xsl:call-template name="generate-index">
                        <xsl:with-param name="scope" select="(ancestor::book|/)[last()]"/>
                    </xsl:call-template>
                </xsl:if>

                <xsl:if test="not(parent::article)">
                    <xsl:call-template name="process.footnotes"/>
                </xsl:if>
            </div>
        </xsl:if>
    </xsl:template>
    <xsl:template match="setindex">
        <!-- some implementations use completely empty index tags to indicate -->
        <!-- where an automatically generated index should be inserted. so -->
        <!-- if the index is completely empty, skip it. Unless generate.index -->
        <!-- is non-zero, in which case, this is where the automatically -->
        <!-- generated index should go. -->

        <xsl:call-template name="id.warning"/>

        <xsl:if test="count(*)&gt;0 or $generate.index != '0'">
            <div>
                <xsl:apply-templates select="." mode="common.html.attributes"/>
                <xsl:call-template name="id.attribute">
                    <xsl:with-param name="conditional" select="0"/>
                </xsl:call-template>

                <xsl:call-template name="setindex.titlepage"/>
                <xsl:apply-templates/>

                <xsl:if test="count(indexentry) = 0 and count(indexdiv) = 0">
                    <xsl:call-template name="generate-index">
                        <xsl:with-param name="scope" select="/"/>
                    </xsl:call-template>
                </xsl:if>

                <xsl:if test="not(parent::article)">
                    <xsl:call-template name="process.footnotes"/>
                </xsl:if>
            </div>
        </xsl:if>
    </xsl:template>
    <xsl:template match="index/indexinfo"/>
    <xsl:template match="index/info"/>
    <xsl:template match="index/title"/>
    <xsl:template match="index/subtitle"/>
    <xsl:template match="index/titleabbrev"/>
    <xsl:template match="indexdiv">
        <xsl:call-template name="id.warning"/>

        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:apply-templates select="*[not(self::indexentry)]"/>
            <dl>
                <xsl:apply-templates select="indexentry"/>
            </dl>
        </div>
    </xsl:template>
    <xsl:template match="indexdiv/title">
        <h3>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:apply-templates/>
        </h3>
    </xsl:template>
    <xsl:template match="indexterm">
        <!-- this one must have a name, even if it doesn't have an ID -->
        <xsl:variable name="id">
            <xsl:call-template name="object.id"/>
        </xsl:variable>

        <a id="{$id}" class="{$class.prefix}indexterm"/>
    </xsl:template>
    <xsl:template match="primary|secondary|tertiary|see|seealso">
    </xsl:template>
    <xsl:template match="indexentry">
        <xsl:apply-templates select="primaryie"/>
    </xsl:template>
    <xsl:template match="primaryie">
        <dt>
            <xsl:apply-templates/>
        </dt>
        <dd>
            <xsl:apply-templates
                    select="following-sibling::seeie                                    [not(preceding-sibling::secondaryie)]"
                    mode="indexentry"/>
            <xsl:apply-templates
                    select="following-sibling::seealsoie                                    [not(preceding-sibling::secondaryie)]"
                    mode="indexentry"/>
            <xsl:apply-templates select="following-sibling::secondaryie" mode="indexentry"/>
        </dd>
    </xsl:template>
    <xsl:template match="secondaryie">
    </xsl:template>
    <xsl:template match="tertiaryie">
    </xsl:template>
    <xsl:template match="seeie|seealsoie">
    </xsl:template>
    <xsl:template match="secondaryie" mode="indexentry">
        <dl>
            <dt>
                <xsl:apply-templates/>
            </dt>
            <dd>
                <!-- select following see* elements up to next secondaryie or tertiary or end -->
                <xsl:variable name="after.this" select="following-sibling::*"/>
                <xsl:variable name="next.entry"
                              select="(following-sibling::secondaryie|following-sibling::tertiaryie)[1]"/>
                <xsl:variable name="before.entry" select="$next.entry/preceding-sibling::*"/>
                <xsl:variable name="see.intersection"
                              select="$after.this[count(.|$before.entry) = count($before.entry)]                                 [self::seeie or self::seealsoie]"/>
                <xsl:choose>
                    <xsl:when test="count($see.intersection) != 0">
                        <xsl:apply-templates select="$see.intersection" mode="indexentry"/>
                    </xsl:when>
                    <xsl:when test="count($next.entry) = 0">
                        <xsl:apply-templates select="following-sibling::seeie" mode="indexentry"/>
                        <xsl:apply-templates select="following-sibling::seealsoie" mode="indexentry"/>
                    </xsl:when>
                </xsl:choose>

                <!-- now process any tertiaryie before the next secondaryie -->
                <xsl:variable name="before.next.secondary"
                              select="following-sibling::secondaryie[1]/preceding-sibling::*"/>
                <xsl:variable name="tertiary.intersection"
                              select="$after.this[count(.|$before.next.secondary) =                                   count($before.next.secondary)]                                 [not(self::seeie) and not(self::seealsoie)]"/>
                <xsl:choose>
                    <xsl:when test="count($tertiary.intersection) != 0">
                        <xsl:apply-templates select="$tertiary.intersection" mode="indexentry"/>
                    </xsl:when>
                    <xsl:when test="not(following-sibling::secondaryie)">
                        <xsl:apply-templates select="following-sibling::tertiaryie" mode="indexentry"/>
                    </xsl:when>
                </xsl:choose>
            </dd>
        </dl>
    </xsl:template>
    <xsl:template match="tertiaryie" mode="indexentry">
        <dl>
            <dt>
                <xsl:apply-templates/>
            </dt>
            <dd>
                <!-- select following see* elements up to next secondaryie or tertiary or end -->
                <xsl:variable name="after.this" select="following-sibling::*"/>
                <xsl:variable name="next.entry"
                              select="(following-sibling::secondaryie|following-sibling::tertiaryie)[1]"/>
                <xsl:variable name="before.entry" select="$next.entry/preceding-sibling::*"/>
                <xsl:variable name="see.intersection"
                              select="$after.this[count(.|$before.entry) = count($before.entry)]                                 [self::seeie or self::seealsoie]"/>
                <xsl:choose>
                    <xsl:when test="count($see.intersection) != 0">
                        <xsl:apply-templates select="$see.intersection" mode="indexentry"/>
                    </xsl:when>
                    <xsl:when test="count($next.entry) = 0">
                        <xsl:apply-templates select="following-sibling::seeie" mode="indexentry"/>
                        <xsl:apply-templates select="following-sibling::seealsoie" mode="indexentry"/>
                    </xsl:when>
                </xsl:choose>
            </dd>
        </dl>
    </xsl:template>
    <xsl:template match="seeie" mode="indexentry">
        <dt>
            <xsl:text>(</xsl:text>
            <xsl:call-template name="gentext">
                <xsl:with-param name="key" select="'see'"/>
            </xsl:call-template>
            <xsl:text> </xsl:text>
            <xsl:apply-templates/>
            <xsl:text>)</xsl:text>
        </dt>
    </xsl:template>
    <xsl:template match="seealsoie" mode="indexentry">
        <div>
            <xsl:text>(</xsl:text>
            <xsl:call-template name="gentext">
                <xsl:with-param name="key" select="'seealso'"/>
            </xsl:call-template>
            <xsl:text> </xsl:text>
            <xsl:apply-templates/>
            <xsl:text>)</xsl:text>
        </div>
    </xsl:template>
    <xsl:template match="reference">
        <xsl:call-template name="id.warning"/>

        <div>
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:call-template name="reference.titlepage"/>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:if test="not(partintro) and contains($toc.params, 'toc')">
                <xsl:call-template name="division.toc"/>
            </xsl:if>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="reference" mode="division.number">
        <xsl:number from="book" count="reference" format="I."/>
    </xsl:template>
    <xsl:template match="reference/docinfo"/>
    <xsl:template match="reference/referenceinfo"/>
    <xsl:template match="reference/title"/>
    <xsl:template match="reference/subtitle"/>
    <xsl:template match="reference/titleabbrev"/>
    <xsl:template name="refentry.title">
        <xsl:param name="node" select="."/>
        <xsl:variable name="refmeta" select="$node//refmeta"/>
        <xsl:variable name="refentrytitle" select="$refmeta//refentrytitle"/>
        <xsl:variable name="refnamediv" select="$node//refnamediv"/>
        <xsl:variable name="refname" select="$refnamediv//refname"/>
        <xsl:variable name="refdesc" select="$refnamediv//refdescriptor"/>
        <xsl:variable name="title">
            <xsl:choose>
                <xsl:when test="$refentrytitle">
                    <xsl:apply-templates select="$refentrytitle[1]" mode="title"/>
                </xsl:when>
                <xsl:when test="$refdesc">
                    <xsl:apply-templates select="$refdesc[1]" mode="title"/>
                </xsl:when>
                <xsl:when test="$refname">
                    <xsl:apply-templates select="$refname[1]" mode="title"/>
                </xsl:when>
                <xsl:otherwise/>
            </xsl:choose>
        </xsl:variable>

        <h1 class="{$class.prefix}title">
            <xsl:copy-of select="$title"/>
        </h1>
    </xsl:template>
    <xsl:template match="refentry">
        <xsl:call-template name="id.warning"/>

        <div>
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:if test="$refentry.separator != 0 and preceding-sibling::refentry">
                <div class="{$class.prefix}refentry.separator">
                    <hr/>
                </div>
            </xsl:if>
            <xsl:call-template name="anchor">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:call-template name="refentry.titlepage"/>
            <xsl:apply-templates/>
            <xsl:call-template name="process.footnotes"/>
        </div>
    </xsl:template>
    <xsl:template match="refentry/docinfo|refentry/refentryinfo"/>
    <xsl:template match="refentry/info"/>
    <xsl:template match="refentrytitle|refname|refdescriptor" mode="title">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="refmeta">
    </xsl:template>
    <xsl:template match="manvolnum">
        <xsl:if test="$refentry.xref.manvolnum != 0">
            <xsl:text>(</xsl:text>
            <xsl:apply-templates/>
            <xsl:text>)</xsl:text>
        </xsl:if>
    </xsl:template>
    <xsl:template match="refmiscinfo">
    </xsl:template>
    <xsl:template match="refentrytitle">
        <xsl:call-template name="inline.charseq"/>
    </xsl:template>
    <xsl:template match="refnamediv">
        <div>
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>

            <xsl:choose>
                <xsl:when test="preceding-sibling::refnamediv">
                    <!-- no title on secondary refnamedivs! -->
                </xsl:when>
                <xsl:when test="$refentry.generate.name != 0">
                    <h2>
                        <xsl:call-template name="gentext">
                            <xsl:with-param name="key" select="'RefName'"/>
                        </xsl:call-template>
                    </h2>
                </xsl:when>
                <xsl:when test="$refentry.generate.title != 0">
                    <h2>
                        <xsl:choose>
                            <xsl:when test="../refmeta/refentrytitle">
                                <xsl:apply-templates select="../refmeta/refentrytitle"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:apply-templates select="refname[1]"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </h2>
                </xsl:when>
            </xsl:choose>

            <p>
                <xsl:apply-templates/>
            </p>
        </div>
    </xsl:template>
    <xsl:template match="refname">
        <xsl:if test="not(preceding-sibling::refdescriptor)">
            <xsl:apply-templates/>
            <xsl:if test="following-sibling::refname">
                <xsl:text>, </xsl:text>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    <xsl:template match="refpurpose">
        <xsl:if test="node()">
            <xsl:text> </xsl:text>
            <xsl:call-template name="dingbat">
                <xsl:with-param name="dingbat">em-dash</xsl:with-param>
            </xsl:call-template>
            <xsl:text> </xsl:text>
            <xsl:apply-templates/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="refdescriptor">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="refclass">
        <xsl:if test="$refclass.suppress = 0">
            <strong>
                <xsl:if test="@role">
                    <xsl:value-of select="@role"/>
                    <xsl:text>: </xsl:text>
                </xsl:if>
                <xsl:apply-templates/>
            </strong>
        </xsl:if>
    </xsl:template>
    <xsl:template match="refsynopsisdiv">
        <div>
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <h2>
                <xsl:choose>
                    <xsl:when test="refsynopsisdiv/title|title">
                        <xsl:apply-templates select="(refsynopsisdiv/title|title)[1]" mode="titlepage.mode"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="gentext">
                            <xsl:with-param name="key" select="'RefSynopsisDiv'"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </h2>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="refsynopsisdivinfo"/>
    <xsl:template match="refsynopsisdiv/title">
    </xsl:template>
    <xsl:template match="refsynopsisdiv/title" mode="titlepage.mode">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="refsection|refsect1|refsect2|refsect3">
        <div>
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:call-template name="anchor">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <!-- pick up info title -->
            <xsl:apply-templates select="(title|info/title)[1]"/>
            <xsl:apply-templates select="node()[not(self::title) and not(self::info)]"/>
        </div>
    </xsl:template>
    <xsl:template match="refsection/title|refsection/info/title">
        <!-- the ID is output in the block.object call for refsect1 -->
        <xsl:variable name="level" select="count(ancestor-or-self::refsection)"/>
        <xsl:variable name="refsynopsisdiv">
            <xsl:text>0</xsl:text>
            <xsl:if test="ancestor::refsynopsisdiv">1</xsl:if>
        </xsl:variable>
        <xsl:variable name="hlevel">
            <xsl:choose>
                <xsl:when test="$level+$refsynopsisdiv &gt; 5">6</xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$level+1+$refsynopsisdiv"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:element name="h{$hlevel}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:apply-templates/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="refsect1/title|refsect1/info/title">
        <!-- the ID is output in the block.object call for refsect1 -->
        <h2>
            <xsl:apply-templates/>
        </h2>
    </xsl:template>
    <xsl:template match="refsect2/title|refsect2/info/title">
        <!-- the ID is output in the block.object call for refsect2 -->
        <h3>
            <xsl:apply-templates/>
        </h3>
    </xsl:template>
    <xsl:template match="refsect3/title|refsect3/info/title">
        <!-- the ID is output in the block.object call for refsect3 -->
        <h4>
            <xsl:apply-templates/>
        </h4>
    </xsl:template>
    <xsl:template match="refsectioninfo|refsection/info"/>
    <xsl:template match="refsect1info|refsect1/info"/>
    <xsl:template match="refsect2info|refsect2/info"/>
    <xsl:template match="refsect3info|refsect3/info"/>
    <xsl:template match="inlineequation">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="alt">
    </xsl:template>
    <xsl:template match="mathphrase">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates/>
        </span>
    </xsl:template>
    <xsl:template match="mml:*">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:apply-templates/>
        </xsl:copy>
    </xsl:template>
    <xsl:template match="*" mode="collect.tex.math">
        <xsl:call-template name="write.text.chunk">
            <xsl:with-param name="filename" select="$tex.math.file"/>
            <xsl:with-param name="method" select="'text'"/>
            <xsl:with-param name="content">
                <xsl:choose>
                    <xsl:when test="$tex.math.in.alt = 'plain'">
                        <xsl:call-template name="tex.math.plain.head"/>
                        <xsl:apply-templates select="." mode="collect.tex.math.plain"/>
                        <xsl:call-template name="tex.math.plain.tail"/>
                    </xsl:when>
                    <xsl:when test="$tex.math.in.alt = 'latex'">
                        <xsl:call-template name="tex.math.latex.head"/>
                        <xsl:apply-templates select="." mode="collect.tex.math.latex"/>
                        <xsl:call-template name="tex.math.latex.tail"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message>
                            Unsupported TeX math notation:
                            <xsl:value-of select="$tex.math.in.alt"/>
                        </xsl:message>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:with-param>
            <xsl:with-param name="encoding" select="$chunker.output.encoding"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="tex.math.plain.head">
  <xsl:text>\nopagenumbers 
</xsl:text>
    </xsl:template>
    <xsl:template name="tex.math.plain.tail">
  <xsl:text>\bye 
</xsl:text>
    </xsl:template>
    <xsl:template match="inlineequation" mode="collect.tex.math.plain">
        <xsl:variable name="filename">
            <xsl:choose>
                <xsl:when test="graphic">
                    <xsl:call-template name="mediaobject.filename">
                        <xsl:with-param name="object" select="graphic"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="select.mediaobject.filename">
                        <xsl:with-param name="olist" select="inlinemediaobject/*"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="output.delims">
            <xsl:call-template name="tex.math.output.delims"/>
        </xsl:variable>
        <xsl:variable name="tex" select="alt[@role='tex'] | inlinemediaobject/textobject[@role='tex']"/>
        <xsl:if test="$tex">
            <xsl:text>\special{dvi2bitmap outputfile </xsl:text>
            <xsl:value-of select="$filename"/>
    <xsl:text>} 
</xsl:text>
            <xsl:if test="$output.delims != 0">
                <xsl:text>$</xsl:text>
            </xsl:if>
            <xsl:value-of select="$tex"/>
            <xsl:if test="$output.delims != 0">
      <xsl:text>$ 
</xsl:text>
            </xsl:if>
    <xsl:text>\vfill\eject 
</xsl:text>
        </xsl:if>
    </xsl:template>
    <xsl:template match="equation|informalequation" mode="collect.tex.math.plain">
        <xsl:variable name="filename">
            <xsl:choose>
                <xsl:when test="graphic">
                    <xsl:call-template name="mediaobject.filename">
                        <xsl:with-param name="object" select="graphic"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="select.mediaobject.filename">
                        <xsl:with-param name="olist" select="mediaobject/*"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="output.delims">
            <xsl:call-template name="tex.math.output.delims"/>
        </xsl:variable>
        <xsl:variable name="tex" select="alt[@role='tex'] | mediaobject/textobject[@role='tex']"/>
        <xsl:if test="$tex">
            <xsl:text>\special{dvi2bitmap outputfile </xsl:text>
            <xsl:value-of select="$filename"/>
    <xsl:text>} 
</xsl:text>
            <xsl:if test="$output.delims != 0">
                <xsl:text>$$</xsl:text>
            </xsl:if>
            <xsl:value-of select="$tex"/>
            <xsl:if test="$output.delims != 0">
      <xsl:text>$$ 
</xsl:text>
            </xsl:if>
    <xsl:text>\vfill\eject 
</xsl:text>
        </xsl:if>
    </xsl:template>
    <xsl:template match="text()" mode="collect.tex.math.plain"/>
    <xsl:template name="tex.math.latex.head">
  <xsl:text>\documentclass{article} 
</xsl:text>
  <xsl:text>\pagestyle{empty} 
</xsl:text>
  <xsl:text>\begin{document} 
</xsl:text>
    </xsl:template>
    <xsl:template name="tex.math.latex.tail">
  <xsl:text>\end{document} 
</xsl:text>
    </xsl:template>
    <xsl:template match="inlineequation" mode="collect.tex.math.latex">
        <xsl:variable name="filename">
            <xsl:choose>
                <xsl:when test="graphic">
                    <xsl:call-template name="mediaobject.filename">
                        <xsl:with-param name="object" select="graphic"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="select.mediaobject.filename">
                        <xsl:with-param name="olist" select="inlinemediaobject/*"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="output.delims">
            <xsl:call-template name="tex.math.output.delims"/>
        </xsl:variable>
        <xsl:variable name="tex" select="alt[@role='tex'] | inlinemediaobject/textobject[@role='tex']"/>
        <xsl:if test="$tex">
            <xsl:text>\special{dvi2bitmap outputfile </xsl:text>
            <xsl:value-of select="$filename"/>
    <xsl:text>} 
</xsl:text>
            <xsl:if test="$output.delims != 0">
                <xsl:text>$</xsl:text>
            </xsl:if>
            <xsl:value-of select="$tex"/>
            <xsl:if test="$output.delims != 0">  
      <xsl:text>$ 
</xsl:text>
            </xsl:if>
    <xsl:text>\newpage 
</xsl:text>
        </xsl:if>
    </xsl:template>
    <xsl:template match="equation|informalequation" mode="collect.tex.math.latex">
        <xsl:variable name="filename">
            <xsl:choose>
                <xsl:when test="graphic">
                    <xsl:call-template name="mediaobject.filename">
                        <xsl:with-param name="object" select="graphic"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="select.mediaobject.filename">
                        <xsl:with-param name="olist" select="mediaobject/*"/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="output.delims">
            <xsl:call-template name="tex.math.output.delims"/>
        </xsl:variable>
        <xsl:variable name="tex" select="alt[@role='tex'] | mediaobject/textobject[@role='tex']"/>
        <xsl:if test="$tex">
            <xsl:text>\special{dvi2bitmap outputfile </xsl:text>
            <xsl:value-of select="$filename"/>
    <xsl:text>} 
</xsl:text>
            <xsl:if test="$output.delims != 0">
                <xsl:text>$$</xsl:text>
            </xsl:if>
            <xsl:value-of select="$tex"/>
            <xsl:if test="$output.delims != 0">
      <xsl:text>$$ 
</xsl:text>
            </xsl:if>
    <xsl:text>\newpage 
</xsl:text>
        </xsl:if>
    </xsl:template>
    <xsl:template match="text()" mode="collect.tex.math.latex"/>
    <xsl:template name="select.mediaobject.filename">
        <xsl:param name="olist"
                   select="imageobject|imageobjectco                      |videoobject|audioobject|textobject"/>

        <xsl:variable name="mediaobject.index">
            <xsl:call-template name="select.mediaobject.index">
                <xsl:with-param name="olist" select="$olist"/>
                <xsl:with-param name="count" select="1"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:if test="$mediaobject.index != ''">
            <xsl:call-template name="mediaobject.filename">
                <xsl:with-param name="object" select="$olist[position() = $mediaobject.index]"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template name="tex.math.output.delims">
        <xsl:variable name="pi.delims">
            <xsl:call-template name="pi.dbtex_delims">
                <xsl:with-param name="node" select="descendant-or-self::*"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="result">
            <xsl:choose>
                <xsl:when test="$pi.delims = 'no'">0</xsl:when>
                <xsl:when test="$pi.delims = '' and $tex.math.delims = 0">0</xsl:when>
                <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:value-of select="$result"/>
    </xsl:template>
    <xsl:template match="*" mode="admon.graphic.width">
        <xsl:param name="node" select="."/>
        <xsl:text>25</xsl:text>
    </xsl:template>
    <xsl:template match="note|important|warning|caution|tip">
        <xsl:choose>
            <xsl:when test="$admon.graphics != 0">
                <xsl:call-template name="graphical.admonition"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="nongraphical.admonition"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="admon.graphic">
        <xsl:param name="node" select="."/>
        <xsl:value-of select="$admon.graphics.path"/>
        <xsl:choose>
            <xsl:when test="local-name($node)='note'">note</xsl:when>
            <xsl:when test="local-name($node)='warning'">warning</xsl:when>
            <xsl:when test="local-name($node)='caution'">caution</xsl:when>
            <xsl:when test="local-name($node)='tip'">tip</xsl:when>
            <xsl:when test="local-name($node)='important'">important</xsl:when>
            <xsl:otherwise>note</xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$admon.graphics.extension"/>
    </xsl:template>
    <xsl:template name="nongraphical.admonition">
        <div>
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute"/>
            <xsl:if test="$admon.style != '' and $make.clean.html = 0">
                <xsl:attribute name="style">
                    <xsl:value-of select="$admon.style"/>
                </xsl:attribute>
            </xsl:if>

            <xsl:if test="$admon.textlabel != 0 or title or info/title">
                <h3 class="{$class.prefix}title">
                    <xsl:call-template name="anchor"/>
                    <xsl:apply-templates select="." mode="object.title.markup"/>
                </h3>
            </xsl:if>

            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="note/title"/>
    <xsl:template match="important/title"/>
    <xsl:template match="warning/title"/>
    <xsl:template match="caution/title"/>
    <xsl:template match="tip/title"/>
    <xsl:param name="component.heading.level" select="2"/>
    <xsl:template name="component.title">
        <xsl:param name="node" select="."/>

        <!-- This handles the case where a component (bibliography, for example)
       occurs inside a section; will we need parameters for this? -->

        <!-- This "level" is a section level.  To compute <h> level, add 1. -->
        <xsl:variable name="level">
            <xsl:choose>
                <!-- chapters and other book children should get <h1> -->
                <xsl:when test="$node/parent::book">0</xsl:when>
                <xsl:when test="ancestor::section">
                    <xsl:value-of select="count(ancestor::section)+1"/>
                </xsl:when>
                <xsl:when test="ancestor::sect5">6</xsl:when>
                <xsl:when test="ancestor::sect4">5</xsl:when>
                <xsl:when test="ancestor::sect3">4</xsl:when>
                <xsl:when test="ancestor::sect2">3</xsl:when>
                <xsl:when test="ancestor::sect1">2</xsl:when>
                <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:element name="h{$level+1}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:attribute name="class"><xsl:value-of select="$class.prefix"/>title
            </xsl:attribute>
            <xsl:call-template name="anchor">
                <xsl:with-param name="node" select="$node"/>
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:apply-templates select="$node" mode="object.title.markup">
                <xsl:with-param name="allow-anchors" select="1"/>
            </xsl:apply-templates>
        </xsl:element>
    </xsl:template>
    <xsl:template name="component.subtitle">
        <xsl:param name="node" select="."/>
        <xsl:variable name="subtitle"
                      select="($node/docinfo/subtitle                         |$node/info/subtitle                         |$node/prefaceinfo/subtitle                         |$node/chapterinfo/subtitle                         |$node/appendixinfo/subtitle                         |$node/articleinfo/subtitle                         |$node/artheader/subtitle                         |$node/subtitle)[1]"/>

        <xsl:if test="$subtitle">
            <h3 class="{$class.prefix}subtitle">
                <xsl:call-template name="id.attribute"/>
                <em>
                    <xsl:apply-templates select="$node" mode="object.subtitle.markup"/>
                </em>
            </h3>
        </xsl:if>
    </xsl:template>
    <xsl:template name="component.separator">
    </xsl:template>
    <xsl:template match="dedication" mode="dedication">
        <xsl:call-template name="id.warning"/>

        <div>
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:call-template name="dedication.titlepage"/>
            <xsl:apply-templates/>
            <xsl:call-template name="process.footnotes"/>
        </div>
    </xsl:template>
    <xsl:template match="dedication/title|dedication/info/title" mode="titlepage.mode" priority="2">
        <xsl:call-template name="component.title">
            <xsl:with-param name="node" select="ancestor::dedication[1]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="dedication/subtitle|dedication/info/subtitle" mode="titlepage.mode" priority="2">
        <xsl:call-template name="component.subtitle">
            <xsl:with-param name="node" select="ancestor::dedication[1]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="dedication"/>
    <xsl:template match="dedication/title"/>
    <xsl:template match="dedication/subtitle"/>
    <xsl:template match="dedication/titleabbrev"/>
    <xsl:template match="acknowledgements" mode="acknowledgements">
        <xsl:call-template name="id.warning"/>

        <div>
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:call-template name="acknowledgements.titlepage"/>
            <xsl:apply-templates/>
            <xsl:call-template name="process.footnotes"/>
        </div>
    </xsl:template>
    <xsl:template match="acknowledgements/title|acknowledgements/info/title" mode="titlepage.mode" priority="2">
        <xsl:call-template name="component.title">
            <xsl:with-param name="node" select="ancestor::acknowledgements[1]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="acknowledgements/subtitle|acknowledgements/info/subtitle" mode="titlepage.mode" priority="2">
        <xsl:call-template name="component.subtitle">
            <xsl:with-param name="node" select="ancestor::acknowledgements[1]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="acknowledgements"/>
    <xsl:template match="acknowledgements/title"/>
    <xsl:template match="acknowledgements/subtitle"/>
    <xsl:template match="acknowledgements/titleabbrev"/>
    <xsl:template match="colophon">
        <xsl:call-template name="id.warning"/>

        <div>
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:call-template name="component.separator"/>
            <xsl:call-template name="component.title"/>
            <xsl:call-template name="component.subtitle"/>

            <xsl:apply-templates/>
            <xsl:call-template name="process.footnotes"/>
        </div>
    </xsl:template>
    <xsl:template match="colophon/title"/>
    <xsl:template match="colophon/subtitle"/>
    <xsl:template match="colophon/titleabbrev"/>
    <xsl:template match="preface">
        <xsl:call-template name="id.warning"/>

        <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:call-template name="component.separator"/>
            <xsl:call-template name="preface.titlepage"/>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:if test="contains($toc.params, 'toc')">
                <xsl:call-template name="component.toc">
                    <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                </xsl:call-template>
                <xsl:call-template name="component.toc.separator"/>
            </xsl:if>
            <xsl:apply-templates/>
            <xsl:call-template name="process.footnotes"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="preface/title" mode="titlepage.mode" priority="2">
        <xsl:call-template name="component.title">
            <xsl:with-param name="node" select="ancestor::preface[1]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template
            match="preface/subtitle                      |preface/prefaceinfo/subtitle                      |preface/info/subtitle                      |preface/docinfo/subtitle"
            mode="titlepage.mode" priority="2">
        <xsl:call-template name="component.subtitle">
            <xsl:with-param name="node" select="ancestor::preface[1]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="preface/docinfo|prefaceinfo"/>
    <xsl:template match="preface/info"/>
    <xsl:template match="preface/title"/>
    <xsl:template match="preface/titleabbrev"/>
    <xsl:template match="preface/subtitle"/>
    <xsl:template match="chapter">
        <xsl:call-template name="id.warning"/>

        <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:call-template name="component.separator"/>
            <xsl:call-template name="chapter.titlepage"/>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>
            <xsl:if test="contains($toc.params, 'toc')">
                <xsl:call-template name="component.toc">
                    <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                </xsl:call-template>
                <xsl:call-template name="component.toc.separator"/>
            </xsl:if>
            <xsl:apply-templates/>
            <xsl:call-template name="process.footnotes"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="chapter/title|chapter/chapterinfo/title|chapter/info/title" mode="titlepage.mode" priority="2">
        <xsl:call-template name="component.title">
            <xsl:with-param name="node" select="ancestor::chapter[1]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template
            match="chapter/subtitle                      |chapter/chapterinfo/subtitle                      |chapter/info/subtitle                      |chapter/docinfo/subtitle"
            mode="titlepage.mode" priority="2">
        <xsl:call-template name="component.subtitle">
            <xsl:with-param name="node" select="ancestor::chapter[1]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="chapter/docinfo|chapterinfo"/>
    <xsl:template match="chapter/info"/>
    <xsl:template match="chapter/title"/>
    <xsl:template match="chapter/titleabbrev"/>
    <xsl:template match="chapter/subtitle"/>
    <xsl:template match="appendix">
        <xsl:variable name="ischunk">
            <xsl:call-template name="chunk"/>
        </xsl:variable>

        <xsl:call-template name="id.warning"/>

        <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:choose>
                <xsl:when test="parent::article and $ischunk = 0">
                    <xsl:call-template name="section.heading">
                        <xsl:with-param name="level" select="1"/>
                        <xsl:with-param name="title">
                            <xsl:apply-templates select="." mode="object.title.markup"/>
                        </xsl:with-param>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="component.separator"/>
                    <xsl:call-template name="appendix.titlepage"/>
                </xsl:otherwise>
            </xsl:choose>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:if test="contains($toc.params, 'toc')">
                <xsl:call-template name="component.toc">
                    <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                </xsl:call-template>
                <xsl:call-template name="component.toc.separator"/>
            </xsl:if>

            <xsl:apply-templates/>

            <xsl:if test="not(parent::article) or $ischunk != 0">
                <xsl:call-template name="process.footnotes"/>
            </xsl:if>
        </xsl:element>
    </xsl:template>
    <xsl:template match="appendix/title|appendix/appendixinfo/title" mode="titlepage.mode" priority="2">
        <xsl:call-template name="component.title">
            <xsl:with-param name="node" select="ancestor::appendix[1]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template
            match="appendix/subtitle                      |appendix/appendixinfo/subtitle                      |appendix/info/subtitle                      |appendix/docinfo/subtitle"
            mode="titlepage.mode" priority="2">
        <xsl:call-template name="component.subtitle">
            <xsl:with-param name="node" select="ancestor::appendix[1]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="appendix/docinfo|appendixinfo"/>
    <xsl:template match="appendix/info"/>
    <xsl:template match="appendix/title"/>
    <xsl:template match="appendix/titleabbrev"/>
    <xsl:template match="appendix/subtitle"/>
    <xsl:template match="article">
        <xsl:call-template name="id.warning"/>

        <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:call-template name="article.titlepage"/>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:call-template name="make.lots">
                <xsl:with-param name="toc.params" select="$toc.params"/>
                <xsl:with-param name="toc">
                    <xsl:call-template name="component.toc">
                        <xsl:with-param name="toc.title.p" select="contains($toc.params, 'title')"/>
                    </xsl:call-template>
                </xsl:with-param>
            </xsl:call-template>

            <xsl:apply-templates/>
            <xsl:call-template name="process.footnotes"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="article/title|article/articleinfo/title" mode="titlepage.mode" priority="2">
        <xsl:call-template name="component.title">
            <xsl:with-param name="node" select="ancestor::article[1]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template
            match="article/subtitle                      |article/articleinfo/subtitle                      |article/info/subtitle                      |article/artheader/subtitle"
            mode="titlepage.mode" priority="2">
        <xsl:call-template name="component.subtitle">
            <xsl:with-param name="node" select="ancestor::article[1]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="article/artheader|article/articleinfo"/>
    <xsl:template match="article/info"/>
    <xsl:template match="article/title"/>
    <xsl:template match="article/titleabbrev"/>
    <xsl:template match="article/subtitle"/>
    <xsl:template match="topic">
        <xsl:call-template name="id.warning"/>

        <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:call-template name="topic.titlepage"/>

            <xsl:variable name="toc.params">
                <xsl:call-template name="find.path.params">
                    <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:apply-templates/>

            <xsl:call-template name="process.footnotes"/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="topic/title|topic/info/title" mode="titlepage.mode" priority="2">
        <xsl:call-template name="component.title">
            <xsl:with-param name="node" select="ancestor::topic[1]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="topic/subtitle                      |topic/info/subtitle" mode="titlepage.mode" priority="2">
        <xsl:call-template name="component.subtitle">
            <xsl:with-param name="node" select="ancestor::topic[1]"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="topic/info"/>
    <xsl:template match="topic/title"/>
    <xsl:template match="topic/titleabbrev"/>
    <xsl:template match="topic/subtitle"/>
    <xsl:template match="bibliography">
        <xsl:call-template name="id.warning"/>

        <div>
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="1"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:call-template name="bibliography.titlepage"/>

            <xsl:apply-templates/>

            <xsl:if test="not(parent::article)">
                <xsl:call-template name="process.footnotes"/>
            </xsl:if>
        </div>
    </xsl:template>
    <xsl:template match="bibliography/bibliographyinfo"/>
    <xsl:template match="bibliography/info"/>
    <xsl:template match="bibliography/title"/>
    <xsl:template match="bibliography/subtitle"/>
    <xsl:template match="bibliography/titleabbrev"/>
    <xsl:template match="bibliodiv">
        <xsl:call-template name="id.warning"/>

        <div>
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="0"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="bibliodiv/title">
        <h3>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="anchor">
                <xsl:with-param name="node" select=".."/>
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:apply-templates/>
        </h3>
    </xsl:template>
    <xsl:template match="bibliolist">
        <div>
            <xsl:call-template name="common.html.attributes">
                <xsl:with-param name="inherit" select="0"/>
            </xsl:call-template>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:if test="blockinfo/title|info/title|title">
                <xsl:call-template name="formal.object.heading"/>
            </xsl:if>
            <xsl:apply-templates
                    select="*[not(self::blockinfo)                                    and not(self::info)                                    and not(self::title)                                    and not(self::titleabbrev)                                    and not(self::biblioentry)                                    and not(self::bibliomixed)]"/>
            <xsl:apply-templates select="biblioentry|bibliomixed"/>
        </div>
    </xsl:template>
    <xsl:template match="biblioentry">
        <xsl:param name="label">
            <xsl:call-template name="biblioentry.label"/>
        </xsl:param>

        <xsl:variable name="id">
            <xsl:call-template name="object.id"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="string(.) = ''">
                <xsl:variable name="bib" select="document($bibliography.collection,.)"/>
                <xsl:variable name="entry"
                              select="$bib/bibliography//                                          *[@id=$id or @xml:id=$id][1]"/>
                <xsl:choose>
                    <xsl:when test="$entry">
                        <xsl:choose>
                            <xsl:when test="$bibliography.numbered != 0">
                                <xsl:apply-templates select="$entry">
                                    <xsl:with-param name="label" select="$label"/>
                                </xsl:apply-templates>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:apply-templates select="$entry"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message>
                            <xsl:text>No bibliography entry: </xsl:text>
                            <xsl:value-of select="$id"/>
                            <xsl:text> found in </xsl:text>
                            <xsl:value-of select="$bibliography.collection"/>
                        </xsl:message>
                        <div>
                            <xsl:call-template name="common.html.attributes"/>
                            <xsl:call-template name="id.attribute"/>
                            <xsl:call-template name="anchor"/>
                            <p>
                                <xsl:copy-of select="$label"/>
                                <xsl:text>Error: no bibliography entry: </xsl:text>
                                <xsl:value-of select="$id"/>
                                <xsl:text> found in </xsl:text>
                                <xsl:value-of select="$bibliography.collection"/>
                            </p>
                        </div>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <div>
                    <xsl:call-template name="common.html.attributes"/>
                    <xsl:call-template name="id.attribute">
                        <xsl:with-param name="conditional" select="0"/>
                    </xsl:call-template>
                    <xsl:call-template name="anchor">
                        <xsl:with-param name="conditional" select="0"/>
                    </xsl:call-template>
                    <p>
                        <xsl:copy-of select="$label"/>
                        <xsl:choose>
                            <xsl:when test="$bibliography.style = 'iso690'">
                                <xsl:call-template name="iso690.makecitation"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:apply-templates mode="bibliography.mode"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </p>
                </div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="bibliomixed">
        <xsl:param name="label">
            <xsl:call-template name="biblioentry.label"/>
        </xsl:param>

        <xsl:variable name="id">
            <xsl:call-template name="object.id"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="string(.) = ''">
                <xsl:variable name="bib" select="document($bibliography.collection,.)"/>
                <xsl:variable name="entry"
                              select="$bib/bibliography//                                          *[@id=$id or @xml:id=$id][1]"/>
                <xsl:choose>
                    <xsl:when test="$entry">
                        <xsl:choose>
                            <xsl:when test="$bibliography.numbered != 0">
                                <xsl:apply-templates select="$entry">
                                    <xsl:with-param name="label" select="$label"/>
                                </xsl:apply-templates>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:apply-templates select="$entry"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message>
                            <xsl:text>No bibliography entry: </xsl:text>
                            <xsl:value-of select="$id"/>
                            <xsl:text> found in </xsl:text>
                            <xsl:value-of select="$bibliography.collection"/>
                        </xsl:message>
                        <div>
                            <xsl:call-template name="common.html.attributes"/>
                            <xsl:call-template name="id.attribute"/>
                            <xsl:call-template name="anchor"/>
                            <p>
                                <xsl:copy-of select="$label"/>
                                <xsl:text>Error: no bibliography entry: </xsl:text>
                                <xsl:value-of select="$id"/>
                                <xsl:text> found in </xsl:text>
                                <xsl:value-of select="$bibliography.collection"/>
                            </p>
                        </div>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <div>
                    <xsl:call-template name="common.html.attributes"/>
                    <xsl:call-template name="id.attribute">
                        <xsl:with-param name="conditional" select="0"/>
                    </xsl:call-template>
                    <xsl:call-template name="anchor">
                        <xsl:with-param name="conditional" select="0"/>
                    </xsl:call-template>
                    <p>
                        <xsl:call-template name="common.html.attributes"/>
                        <xsl:copy-of select="$label"/>
                        <xsl:apply-templates mode="bibliomixed.mode"/>
                    </p>
                </div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="biblioentry.label">
        <xsl:param name="node" select="."/>

        <xsl:choose>
            <xsl:when test="$bibliography.numbered != 0">
                <xsl:text>[</xsl:text>
                <xsl:number from="bibliography" count="biblioentry|bibliomixed" level="any" format="1"/>
                <xsl:text>] </xsl:text>
            </xsl:when>
            <xsl:when test="local-name($node/child::*[1]) = 'abbrev'">
                <xsl:text>[</xsl:text>
                <xsl:apply-templates select="$node/abbrev[1]"/>
                <xsl:text>] </xsl:text>
            </xsl:when>
            <xsl:when test="$node/@xreflabel">
                <xsl:text>[</xsl:text>
                <xsl:value-of select="$node/@xreflabel"/>
                <xsl:text>] </xsl:text>
            </xsl:when>
            <xsl:when test="$node/@id">
                <xsl:text>[</xsl:text>
                <xsl:value-of select="$node/@id"/>
                <xsl:text>] </xsl:text>
            </xsl:when>
            <xsl:when test="$node/@xml:id">
                <xsl:text>[</xsl:text>
                <xsl:value-of select="$node/@xml:id"/>
                <xsl:text>] </xsl:text>
            </xsl:when>
            <xsl:otherwise><!-- nop --></xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*" mode="bibliography.mode">
        <xsl:apply-templates select="."/>
        <!-- try the default mode -->
    </xsl:template>
    <xsl:template match="abbrev" mode="bibliography.mode">
        <xsl:if test="preceding-sibling::*">
            <xsl:apply-templates mode="bibliography.mode"/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="abstract" mode="bibliography.mode">
        <!-- suppressed -->
    </xsl:template>
    <xsl:template match="address" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="affiliation" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="shortaffil" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="jobtitle" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="artheader|articleinfo|info" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="artpagenums" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="author" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:choose>
                <xsl:when test="orgname">
                    <xsl:apply-templates select="orgname" mode="bibliography.mode"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="person.name"/>
                    <xsl:copy-of select="$biblioentry.item.separator"/>
                </xsl:otherwise>
            </xsl:choose>
        </span>
    </xsl:template>
    <xsl:template match="authorblurb|personblurb" mode="bibliography.mode">
        <!-- suppressed -->
    </xsl:template>
    <xsl:template match="authorgroup" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="person.name.list"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="authorinitials" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="bibliomisc" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="bibliomset" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="biblioset" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="biblioset/title|biblioset/citetitle" mode="bibliography.mode">
        <xsl:variable name="relation" select="../@relation"/>
        <xsl:choose>
            <xsl:when test="$relation='article' or @pubwork='article'">
                <xsl:call-template name="gentext.startquote"/>
                <xsl:apply-templates/>
                <xsl:call-template name="gentext.endquote"/>
            </xsl:when>
            <xsl:otherwise>
                <em>
                    <xsl:apply-templates/>
                </em>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:copy-of select="$biblioentry.item.separator"/>
    </xsl:template>
    <xsl:template match="citetitle" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:choose>
                <xsl:when test="@pubwork = 'article'">
                    <xsl:call-template name="gentext.startquote"/>
                    <xsl:call-template name="inline.charseq"/>
                    <xsl:call-template name="gentext.endquote"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="inline.italicseq"/>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="collab" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="collabname" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="confgroup" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="confdates" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="conftitle" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="confnum" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="confsponsor" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="contractnum" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="contractsponsor" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="contrib" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="copyright" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="gentext">
                <xsl:with-param name="key" select="'Copyright'"/>
            </xsl:call-template>
            <xsl:call-template name="gentext.space"/>
            <xsl:call-template name="dingbat">
                <xsl:with-param name="dingbat">copyright</xsl:with-param>
            </xsl:call-template>
            <xsl:call-template name="gentext.space"/>
            <xsl:apply-templates select="year" mode="bibliography.mode"/>
            <xsl:if test="holder">
                <xsl:call-template name="gentext.space"/>
                <xsl:apply-templates select="holder" mode="bibliography.mode"/>
            </xsl:if>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="year" mode="bibliography.mode">
        <xsl:apply-templates/>
        <xsl:text>, </xsl:text>
    </xsl:template>
    <xsl:template match="year[position()=last()]" mode="bibliography.mode">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="holder" mode="bibliography.mode">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="corpauthor" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="corpcredit" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="corpname" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="date" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="edition" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="editor" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="person.name"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="firstname" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="honorific" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="indexterm" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="invpartnumber" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="isbn" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="issn" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="issuenum" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="lineage" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="orgname" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="orgdiv" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="othercredit" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="othername" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="pagenums" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="printhistory" mode="bibliography.mode">
        <!-- suppressed -->
    </xsl:template>
    <xsl:template match="productname" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="productnumber" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="pubdate" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="publisher" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="publishername" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="pubsnumber" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="revhistory" mode="bibliography.mode">
        <!-- suppressed; how could this be represented? -->
    </xsl:template>
    <xsl:template match="seriesinfo" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="seriesvolnums" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="subtitle" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="surname" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="title" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <em>
                <xsl:apply-templates mode="bibliography.mode"/>
            </em>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="titleabbrev" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="volumenum" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="bibliocoverage|biblioid|bibliorelation|bibliosource" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliography.mode"/>
            <xsl:copy-of select="$biblioentry.item.separator"/>
        </span>
    </xsl:template>
    <xsl:template match="biblioid[@class='doi']" mode="bibliography.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <a href="{concat('http://dx.doi.org/', .)}">doi:<xsl:value-of select="."/>
            </a>
        </span>
    </xsl:template>
    <xsl:template match="*" mode="bibliomixed.mode">
        <xsl:apply-templates select="."/>
        <!-- try the default mode -->
    </xsl:template>
    <xsl:template match="abbrev" mode="bibliomixed.mode">
        <xsl:if test="preceding-sibling::*">
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="abstract" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="address" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="affiliation" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="shortaffil" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="jobtitle" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="artpagenums" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="author" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:choose>
                <xsl:when test="orgname">
                    <xsl:apply-templates select="orgname" mode="bibliomixed.mode"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="person.name"/>
                </xsl:otherwise>
            </xsl:choose>
        </span>
    </xsl:template>
    <xsl:template match="authorblurb|personblurb" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="authorgroup" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="authorinitials" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="bibliomisc" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="bibliomset" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="bibliomset/title|bibliomset/citetitle" mode="bibliomixed.mode">
        <xsl:variable name="relation" select="../@relation"/>
        <xsl:choose>
            <xsl:when test="$relation='article' or @pubwork='article'">
                <xsl:call-template name="gentext.startquote"/>
                <xsl:apply-templates/>
                <xsl:call-template name="gentext.endquote"/>
            </xsl:when>
            <xsl:otherwise>
                <em>
                    <xsl:apply-templates/>
                </em>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="biblioset" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="citetitle" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:choose>
                <xsl:when test="@pubwork = 'article'">
                    <xsl:call-template name="gentext.startquote"/>
                    <xsl:call-template name="inline.charseq"/>
                    <xsl:call-template name="gentext.endquote"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="inline.italicseq"/>
                </xsl:otherwise>
            </xsl:choose>
        </span>
    </xsl:template>
    <xsl:template match="collab" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="confgroup" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="contractnum" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="contractsponsor" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="contrib" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="copyright" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="corpauthor" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="corpcredit" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="corpname" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="date" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="edition" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="editor" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="firstname" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="honorific" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="indexterm" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="invpartnumber" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="isbn" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="issn" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="issuenum" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="lineage" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="orgname" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="othercredit" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="othername" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="pagenums" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="printhistory" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="productname" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="productnumber" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="pubdate" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="publisher" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="publishername" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="pubsnumber" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="revhistory" mode="bibliomixed.mode">
        <!-- suppressed; how could this be represented? -->
    </xsl:template>
    <xsl:template match="seriesvolnums" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="subtitle" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="surname" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="title" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="titleabbrev" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="volumenum" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="bibliocoverage|biblioid|bibliorelation|bibliosource" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="bibliomixed.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="biblioid[@class='doi']" mode="bibliomixed.mode">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <a href="{concat('http://dx.doi.org/', .)}">doi:<xsl:value-of select="."/>
            </a>
        </span>
    </xsl:template>
    <xsl:param name="biblioentry.alt.primary.seps" select="0"/>
    <xsl:param name="biblioentry.primary.count" select="1"/>
    <xsl:template name="iso690.makecitation">
        <!-- Types of resources -->
        <xsl:choose>

            <!-- SYSTEMS OF ELECTRONIC COMMUNICATION : ENTIRE MESSAGE SYSTEM -->
            <!-- same as Monographs -->
            <xsl:when test="./@role='messagesystem'">
                <xsl:call-template name="iso690.monogr"/>
            </xsl:when>

            <!-- SYSTEMS OF ELECTRONIC COMMUNICATION : ELECTRONIC MESSAGES -->
            <!-- same as Contributions to Monographs -->
            <xsl:when test="./@role='message'">
                <xsl:call-template name="iso690.paper.mon"/>
            </xsl:when>

            <!-- SERIALS -->
            <xsl:when test="./@role='serial' or ./biblioid/@class='issn' or ./issn">
                <xsl:call-template name="iso690.serial"/>
            </xsl:when>

            <!-- PARTS OF MONOGRAPHS -->
            <xsl:when test="./@role='part' or (./bibliomisc[@role='secnum']|./bibliomisc[@role='sectitle'])">
                <xsl:call-template name="iso690.monogr.part"/>
            </xsl:when>

            <!-- CONTRIBUTIONS TO MONOGRAPHS -->
            <xsl:when test="./@role='contribution' or (./biblioset/@relation='part' and ./biblioset/@relation='book')">
                <xsl:call-template name="iso690.paper.mon"/>
            </xsl:when>

            <!-- ARTICLES, ETC., IN SERIALS -->
            <xsl:when test="./@role='article' or (./biblioset/@relation='journal' and ./biblioset/@relation='article')">
                <xsl:call-template name="iso690.article"/>
            </xsl:when>

            <!-- PATENT DOCUMENTS -->
            <xsl:when test="./@role='patent' or (./bibliomisc[@role='patenttype'] and ./bibliomisc[@role='patentnum'])">
                <xsl:call-template name="iso690.patent"/>
            </xsl:when>

            <!-- MONOGRAPHS -->
            <xsl:otherwise>
                <xsl:call-template name="iso690.monogr"/>
            </xsl:otherwise>

        </xsl:choose>
    </xsl:template>
    <xsl:template name="iso690.monogr">
        <!-- Primary responsibility -->
        <xsl:call-template name="iso690.primary"/>
        <!-- Title and Type of medium -->
        <xsl:call-template name="iso690.title"/>
        <!-- Subordinate responsibility -->
        <xsl:call-template name="iso690.secondary"/>
        <!-- Edition -->
        <xsl:call-template name="iso690.edition"/>
        <!-- Place of publication, Publisher, Year/Date of publication, Date of update/revision, Date of citation -->
        <xsl:call-template name="iso690.pub"/>
        <!-- Extent -->
        <xsl:call-template name="iso690.extent"/>
        <!-- Series -->
        <xsl:call-template name="iso690.serie"/>
        <!-- Notes -->
        <xsl:call-template name="iso690.notice"/>
        <!-- Avaibility and access -->
        <xsl:call-template name="iso690.access"/>
        <!-- Standard number -->
        <xsl:call-template name="iso690.isbn"/>
    </xsl:template>
    <xsl:template name="iso690.serial">
        <!-- Title and Type of medium -->
        <xsl:call-template name="iso690.title"/>
        <!-- Responsibility [nonEL] -->
        <xsl:if test="not(./bibliomisc[@role='medium'])">
            <xsl:call-template name="iso690.secondary"/>
        </xsl:if>
        <!-- Edition -->
        <xsl:call-template name="iso690.edition">
            <xsl:with-param name="after" select="./bibliomisc[@role='issuing']"/>
        </xsl:call-template>
        <!-- Issue designation (date and/or num) [nonEL] -->
        <xsl:if test="not(./bibliomisc[@role='medium'])">
            <xsl:call-template name="iso690.issuing"/>
        </xsl:if>
        <!-- Place of publication, Publisher, Year/Date of publication, Date of update/revision, Date of citation -->
        <xsl:call-template name="iso690.pub"/>
        <!-- Series -->
        <xsl:call-template name="iso690.serie"/>
        <!-- Notes -->
        <xsl:call-template name="iso690.notice"/>
        <!-- Avaibility and access -->
        <xsl:call-template name="iso690.access"/>
        <!-- Standard number -->
        <xsl:call-template name="iso690.issn"/>
    </xsl:template>
    <xsl:template name="iso690.monogr.part">
        <!-- Primary responsibility of host document -->
        <xsl:call-template name="iso690.primary"/>
        <!-- Title and Type of medium of host document -->
        <xsl:call-template name="iso690.title"/>
        <!-- Subordinate responsibility of host document [EL] -->
        <xsl:if test="./bibliomisc[@role='medium']">
            <xsl:call-template name="iso690.secondary"/>
        </xsl:if>
        <!-- Edition -->
        <xsl:call-template name="iso690.edition">
            <xsl:with-param name="after" select="./volumenum"/>
        </xsl:call-template>
        <!-- Numeration of the part [nonEL]-->
        <xsl:if test="not(./bibliomisc[@role='medium'])">
            <xsl:call-template name="iso690.partnr"/>
            <!-- Subordinate responsibility [nonEL] -->
            <xsl:call-template name="iso690.secondary"/>
        </xsl:if>
        <!-- Place of publication, Publisher, Year/Date of publication, Date of update/revision, Date of citation -->
        <xsl:call-template name="iso690.pub"/>
        <!-- Location within host -->
        <xsl:call-template name="iso690.part.location"/>
        <xsl:if test="./bibliomisc[@role='medium']">
            <!-- Numeration within host document [EL] -->
            <!-- Notes [EL] -->
            <xsl:call-template name="iso690.notice"/>
            <!-- Avaibility and access [EL] -->
            <xsl:call-template name="iso690.access"/>
            <!-- Standard number [EL] -->
            <xsl:call-template name="iso690.isbn"/>
        </xsl:if>
    </xsl:template>
    <xsl:template name="iso690.paper.mon">
        <!-- Contribution -->
        <xsl:apply-templates mode="iso690.paper.part" select="./biblioset[@relation='part']"/>
        <!-- In -->
        <xsl:text>In </xsl:text>
        <!-- Host -->
        <xsl:apply-templates mode="iso690.paper.book" select="./biblioset[@relation='book']"/>
    </xsl:template>
    <xsl:template match="biblioset" mode="iso690.paper.part">
        <!-- Contribution -->
        <!-- Primary responsibility -->
        <xsl:call-template name="iso690.primary"/>
        <!-- Title -->
        <xsl:call-template name="iso690.title">
            <xsl:with-param name="italic" select="0"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="biblioset" mode="iso690.paper.book">
        <!-- Host -->
        <!-- Primary responsibility -->
        <xsl:call-template name="iso690.primary"/>
        <!-- Title and Type of medium -->
        <xsl:call-template name="iso690.title"/>
        <!-- Subordinate responsibility [EL] -->
        <xsl:if test="./bibliomisc[@role='medium']">
            <xsl:call-template name="iso690.secondary"/>
        </xsl:if>
        <!-- Edition -->
        <xsl:call-template name="iso690.edition"/>
        <!-- Place of publication, Publisher, Year/Date of publication, Date of update/revision, Date of citation -->
        <xsl:call-template name="iso690.paper.pub"/>
        <!-- Numeration within host document [EL] -->
        <!-- Location within host -->
        <xsl:call-template name="iso690.location"/>
        <xsl:if test="./bibliomisc[@role='medium']">
            <!-- Notes [EL] -->
            <xsl:call-template name="iso690.notice"/>
            <!-- Avaibility and access [EL] -->
            <xsl:call-template name="iso690.access"/>
            <!-- Standard number [EL] -->
            <xsl:call-template name="iso690.isbn"/>
        </xsl:if>
    </xsl:template>
    <xsl:template name="iso690.article">
        <!-- Article -->
        <xsl:apply-templates mode="iso690.article.art" select="./biblioset[@relation='article']"/>
        <!-- Serial -->
        <xsl:apply-templates mode="iso690.article.jour" select="./biblioset[@relation='journal']"/>
    </xsl:template>
    <xsl:template match="biblioset" mode="iso690.article.art">
        <!-- Article -->
        <!-- Primary responsibility -->
        <xsl:call-template name="iso690.primary"/>
        <!-- Title -->
        <xsl:call-template name="iso690.title">
            <xsl:with-param name="italic" select="0"/>
        </xsl:call-template>
        <!-- Subordinate responsibility [nonEL] -->
        <xsl:if test="not(../*/bibliomisc[@role='medium'])">
            <xsl:call-template name="iso690.secondary"/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="biblioset" mode="iso690.article.jour">
        <!-- Serial -->
        <!-- Title and Type of medium -->
        <xsl:call-template name="iso690.title"/>
        <!-- Edition -->
        <xsl:call-template name="iso690.edition">
            <xsl:with-param name="after" select="./pubdate[not(@role='issuing')]|./volumenum|./issuenum|./pagenums"/>
        </xsl:call-template>
        <!-- Number designation [EL] -->
        <!-- Location within host -->
        <xsl:call-template name="iso690.article.location"/>
        <xsl:if test="./bibliomisc[@role='medium']">
            <!-- Notes [EL] -->
            <xsl:call-template name="iso690.notice"/>
            <!-- Avaibility and access [EL] -->
            <xsl:call-template name="iso690.access"/>
            <!-- Standard number [EL] -->
            <xsl:call-template name="iso690.issn"/>
        </xsl:if>
    </xsl:template>
    <xsl:template name="iso690.patent">
        <!-- Primary responsibility (applicant) -->
        <xsl:call-template name="iso690.primary"/>
        <!-- Title of the invention -->
        <xsl:call-template name="iso690.title"/>
        <!-- Subordinate responsibility -->
        <xsl:call-template name="iso690.secondary"/>
        <!-- Notes -->
        <xsl:call-template name="iso690.notice"/>
        <!-- Identification -->
        <xsl:call-template name="iso690.pat.ident"/>
    </xsl:template>
    <xsl:template name="iso690.primary">
        <xsl:param name="primary.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'primary.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:choose>
            <xsl:when test="./authorgroup/author|./author">
                <xsl:call-template name="iso690.author.list">
                    <xsl:with-param name="person.list" select=".//authorgroup/author|.//author"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="./authorgroup/editor|./editor">
                <xsl:call-template name="iso690.author.list">
                    <xsl:with-param name="person.list" select=".//authorgroup/editor|.//editor"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="./authorgroup/corpauthor|./corpauthor">
                <xsl:call-template name="iso690.author.list">
                    <xsl:with-param name="person.list" select=".//authorgroup/corpauthor|.//corpauthor"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:if test="(./firstname)and(./surname)">
                    <xsl:call-template name="iso690.author"/>
                    <xsl:call-template name="iso690.endsep">
                        <xsl:with-param name="text" select="string(./firstname[1])"/>
                        <xsl:with-param name="sep" select="$primary.sep"/>
                    </xsl:call-template>
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="iso690.author.list">
        <xsl:param name="person.list" select="author|corpauthor|editor"/>
        <xsl:param name="person.count" select="count($person.list)"/>
        <xsl:param name="count" select="1"/>
        <xsl:param name="group" select="./authorgroup[@role='many']"/>
        <xsl:param name="many" select="0"/>

        <xsl:param name="primary.many">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'primary.many'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="primary.editor">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'primary.editor'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="primary.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'primary.sep'"/>
            </xsl:call-template>
        </xsl:param>

        <xsl:choose>
            <xsl:when test="$count &gt; $person.count"/>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="$person.count &lt; 4 and not($group)">
                        <xsl:call-template name="iso690.author">
                            <xsl:with-param name="node" select="$person.list[position()=$count]"/>
                        </xsl:call-template>
                        <xsl:choose>
                            <xsl:when test="$person.count = 2 and $count = 1 and $biblioentry.alt.primary.seps != 0">
                                <xsl:call-template name="gentext.template">
                                    <xsl:with-param name="context" select="'iso690'"/>
                                    <xsl:with-param name="name" select="'alt.person.two.sep'"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:when test="$person.count = 2 and $count = 1">
                                <xsl:call-template name="gentext.template">
                                    <xsl:with-param name="context" select="'authorgroup'"/>
                                    <xsl:with-param name="name" select="'sep2'"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:when
                                    test="$person.count &gt; 2 and $count+1 = $person.count and $biblioentry.alt.primary.seps != 0">
                                <xsl:call-template name="gentext.template">
                                    <xsl:with-param name="context" select="'iso690'"/>
                                    <xsl:with-param name="name" select="'alt.person.last.sep'"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:when test="$person.count &gt; 2 and $count+1 = $person.count">
                                <xsl:call-template name="gentext.template">
                                    <xsl:with-param name="context" select="'authorgroup'"/>
                                    <xsl:with-param name="name" select="'seplast'"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:when test="$count &lt; $person.count and $biblioentry.alt.primary.seps != 0">
                                <xsl:call-template name="gentext.template">
                                    <xsl:with-param name="context" select="'iso690'"/>
                                    <xsl:with-param name="name" select="'alt.person.more.sep'"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:when test="$count &lt; $person.count">
                                <xsl:call-template name="gentext.template">
                                    <xsl:with-param name="context" select="'authorgroup'"/>
                                    <xsl:with-param name="name" select="'sep'"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:when test="($count = $person.count)">
                                <xsl:choose>
                                    <xsl:when test="$many!=0">
                                        <xsl:if test="name($person.list[position()=$count])='editor'">
                                            <xsl:value-of select="$primary.editor"/>
                                        </xsl:if>
                                        <xsl:value-of select="$primary.many"/>
                                        <xsl:call-template name="iso690.endsep">
                                            <xsl:with-param name="text" select="$primary.many"/>
                                            <xsl:with-param name="sep" select="$primary.sep"/>
                                        </xsl:call-template>
                                    </xsl:when>
                                    <xsl:when test="name($person.list[position()=$count])='editor'">
                                        <xsl:value-of select="$primary.editor"/>
                                        <xsl:value-of select="$primary.sep"/>
                                    </xsl:when>
                                    <xsl:when test="name($person.list[position()=$count])='corpauthor'">
                                        <xsl:call-template name="iso690.endsep">
                                            <xsl:with-param name="text"
                                                            select="string($person.list[position()=$count])"/>
                                            <xsl:with-param name="sep" select="$primary.sep"/>
                                        </xsl:call-template>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:call-template name="iso690.endsep">
                                            <xsl:with-param name="text"
                                                            select="string($person.list[position()=$count]//firstname[1])"/>
                                            <xsl:with-param name="sep" select="$primary.sep"/>
                                        </xsl:call-template>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:when>
                        </xsl:choose>

                        <xsl:call-template name="iso690.author.list">
                            <xsl:with-param name="person.list" select="$person.list"/>
                            <xsl:with-param name="person.count" select="$person.count"/>
                            <xsl:with-param name="count" select="$count+1"/>
                            <xsl:with-param name="many" select="$many"/>
                            <xsl:with-param name="group"/>
                        </xsl:call-template>
                    </xsl:when>

                    <xsl:otherwise>
                        <xsl:choose>
                            <xsl:when test="($biblioentry.primary.count&gt;=3) and ($person.count&gt;=3)">
                                <xsl:call-template name="iso690.author.list">
                                    <xsl:with-param name="person.list"
                                                    select="$person.list[1]|$person.list[2]|$person.list[3]"/>
                                    <xsl:with-param name="person.count" select="3"/>
                                    <xsl:with-param name="count" select="1"/>
                                    <xsl:with-param name="many" select="1"/>
                                    <xsl:with-param name="group"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:when test="($biblioentry.primary.count&gt;1) and  ($person.count&gt;1)">
                                <xsl:call-template name="iso690.author.list">
                                    <xsl:with-param name="person.list" select="$person.list[1]|$person.list[2]"/>
                                    <xsl:with-param name="person.count" select="2"/>
                                    <xsl:with-param name="count" select="1"/>
                                    <xsl:with-param name="many" select="1"/>
                                    <xsl:with-param name="group"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:call-template name="iso690.author.list">
                                    <xsl:with-param name="person.list" select="$person.list[1]"/>
                                    <xsl:with-param name="person.count" select="1"/>
                                    <xsl:with-param name="count" select="1"/>
                                    <xsl:with-param name="many" select="1"/>
                                    <xsl:with-param name="group"/>
                                </xsl:call-template>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="iso690.author">
        <xsl:param name="node" select="."/>
        <xsl:param name="lastfirst.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'lastfirst.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:choose>
            <xsl:when test="name($node)!='corpauthor'">
                <span style="text-transform:uppercase">
                    <xsl:apply-templates mode="iso690.mode" select="$node//surname[1]"/>
                </span>
                <xsl:if test="$node//surname and $node//firstname">
                    <xsl:value-of select="$lastfirst.sep"/>
                </xsl:if>
                <xsl:apply-templates mode="iso690.mode" select="$node//firstname[1]"/>
            </xsl:when>
            <xsl:otherwise>
                <span style="text-transform:uppercase">
                    <xsl:apply-templates mode="iso690.mode" select="$node"/>
                </span>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="corpauthor|firstname|surname" mode="iso690.mode">
        <xsl:apply-templates mode="iso690.mode"/>
    </xsl:template>
    <xsl:template name="iso690.title">
        <xsl:param name="medium" select="./bibliomisc[@role='medium']"/>
        <xsl:param name="italic" select="1"/>
        <xsl:param name="sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'title.sep'"/>
            </xsl:call-template>
        </xsl:param>

        <xsl:apply-templates mode="iso690.mode" select="./title">
            <xsl:with-param name="medium" select="$medium"/>
            <xsl:with-param name="italic" select="$italic"/>
            <xsl:with-param name="sep" select="$sep"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="title" mode="iso690.mode">
        <xsl:param name="medium"/>
        <xsl:param name="italic" select="1"/>
        <xsl:param name="sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'title.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="medium1">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'medium1'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="medium2">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'medium2'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:choose>
            <xsl:when test="$italic=1">
                <xsl:call-template name="iso690.italic.title"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="iso690.make.title"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:if test="$medium">
            <xsl:value-of select="$medium1"/>
            <xsl:apply-templates mode="iso690.mode" select="$medium"/>
            <xsl:value-of select="$medium2"/>
        </xsl:if>
        <xsl:call-template name="iso690.endsep">
            <xsl:with-param name="text" select="concat(string(.),string(../subtitle))"/>
            <xsl:with-param name="sep" select="$sep"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="iso690.italic.title">
        <em>
            <xsl:call-template name="iso690.make.title"/>
        </em>
    </xsl:template>
    <xsl:template name="iso690.make.title">
        <xsl:param name="submaintitle.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'submaintitle.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:apply-templates mode="iso690.mode"/>
        <xsl:if test="../subtitle|../info/subtitle">
            <xsl:value-of select="$submaintitle.sep"/>
            <xsl:apply-templates mode="iso690.mode" select="../subtitle|../info/subtitle"/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="subtitle" mode="iso690.mode">
        <xsl:apply-templates mode="iso690.mode"/>
    </xsl:template>
    <xsl:template match="bibliomisc[@role='medium']" mode="iso690.mode">
        <xsl:apply-templates mode="iso690.mode"/>
    </xsl:template>
    <xsl:template name="iso690.secondary">
        <xsl:param name="secondary.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'secondary.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="secondary.person.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'secondary.person.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:for-each select="./bibliomisc[@role='secondary']">
            <xsl:apply-templates mode="iso690.mode" select="."/>
            <xsl:choose>
                <xsl:when test="position()=count(../bibliomisc[@role='secondary'])">
                    <xsl:call-template name="iso690.endsep">
                        <xsl:with-param name="text" select="string(.)"/>
                        <xsl:with-param name="sep" select="$secondary.sep"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$secondary.person.sep"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:for-each>
    </xsl:template>
    <xsl:template match="bibliomisc[@role='secondary']" mode="iso690.mode">
        <xsl:apply-templates mode="iso690.mode"/>
    </xsl:template>
    <xsl:template name="iso690.edition">
        <xsl:param name="after"/>
        <xsl:param name="edition.serial.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'edition.serial.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:choose>
            <xsl:when test="string($after)!=''">
                <xsl:apply-templates mode="iso690.mode" select="./edition">
                    <xsl:with-param name="sep" select="$edition.serial.sep"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="iso690.mode" select="./edition"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="edition" mode="iso690.mode">
        <xsl:param name="sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'edition.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:apply-templates mode="iso690.mode"/>
        <xsl:call-template name="iso690.endsep">
            <xsl:with-param name="text" select="string(.)"/>
            <xsl:with-param name="sep" select="$sep"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="iso690.issuing">
        <xsl:param name="issuing.div">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'issuing.div'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="issuing.range">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'issuing.range'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="issuing.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'issuing.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:choose>
            <xsl:when test="./pubdate[@role='issuing'] and ./volumenum[2] and ./issuenum[2]">
                <xsl:call-template name="iso690.issuedate"/>
                <xsl:apply-templates mode="iso690.mode" select="./volumenum[1]">
                    <xsl:with-param name="sep" select="$issuing.div"/>
                </xsl:apply-templates>
                <xsl:apply-templates mode="iso690.mode" select="./issuenum[1]">
                    <xsl:with-param name="sep" select="$issuing.range"/>
                </xsl:apply-templates>
                <xsl:apply-templates mode="iso690.mode" select="./volumenum[2]">
                    <xsl:with-param name="sep" select="$issuing.div"/>
                </xsl:apply-templates>
                <xsl:apply-templates mode="iso690.mode" select="./issuenum[2]">
                    <xsl:with-param name="sep" select="$issuing.sep"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:when test="./pubdate[@role='issuing'] and ./volumenum[2]">
                <xsl:call-template name="iso690.issuedate"/>
                <xsl:apply-templates mode="iso690.mode" select="./volumenum[1]">
                    <xsl:with-param name="sep" select="$issuing.range"/>
                </xsl:apply-templates>
                <xsl:apply-templates mode="iso690.mode" select="./volumenum[2]">
                    <xsl:with-param name="sep" select="$issuing.sep"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:when test="./pubdate[@role='issuing'] and ./volumenum and ./issuenum">
                <xsl:apply-templates mode="iso690.mode" select="./pubdate[@role='issuing']">
                    <xsl:with-param name="sep" select="$issuing.div"/>
                </xsl:apply-templates>
                <xsl:apply-templates mode="iso690.mode" select="./volumenum">
                    <xsl:with-param name="sep" select="$issuing.div"/>
                </xsl:apply-templates>
                <xsl:apply-templates mode="iso690.mode" select="./issuenum">
                    <xsl:with-param name="sep" select="$issuing.sep"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:when test="./pubdate[@role='issuing']">
                <xsl:apply-templates mode="iso690.mode" select="./pubdate[@role='issuing']">
                    <xsl:with-param name="sep" select="$issuing.sep"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:when test="./volumenum">
                <xsl:apply-templates mode="iso690.mode" select="./volumenum">
                    <xsl:with-param name="sep" select="$issuing.sep"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:when test="./issuenum">
                <xsl:apply-templates mode="iso690.mode" select="./issuenum">
                    <xsl:with-param name="sep" select="$issuing.sep"/>
                </xsl:apply-templates>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="iso690.issuedate">
        <xsl:param name="issuing.div">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'issuing.div'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="issuing.range">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'issuing.range'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="issuing.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'issuing.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:choose>
            <xsl:when test="./pubdate[@role='issuing'][2]">
                <xsl:apply-templates mode="iso690.mode" select="./pubdate[@role='issuing'][1]">
                    <xsl:with-param name="sep" select="$issuing.range"/>
                </xsl:apply-templates>
                <xsl:apply-templates mode="iso690.mode" select="./pubdate[@role='issuing'][2]">
                    <xsl:with-param name="sep" select="$issuing.div"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="iso690.mode" select="./pubdate[@role='issuing']">
                    <xsl:with-param name="sep" select="$issuing.div"/>
                </xsl:apply-templates>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="pubdate[@role='issuing']" mode="iso690.mode">
        <xsl:param name="sep"/>
        <xsl:variable name="substr" select="substring(string(.),string-length(string(.)))"/>
        <xsl:apply-templates mode="iso690.mode"/>
        <xsl:call-template name="iso690.space">
            <xsl:with-param name="text" select="$substr"/>
        </xsl:call-template>
        <xsl:choose>
            <xsl:when test="$substr='-'">
                <xsl:call-template name="iso690.endsep">
                    <xsl:with-param name="text" select="' '"/>
                    <xsl:with-param name="sep" select="$sep"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="iso690.endsep">
                    <xsl:with-param name="text" select="string(.)"/>
                    <xsl:with-param name="sep" select="$sep"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="iso690.partnr">
        <xsl:param name="partnr.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'partnr.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:apply-templates mode="iso690.mode" select="./volumenum">
            <xsl:with-param name="sep" select="$partnr.sep"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template name="iso690.pub">
        <xsl:param name="onlydate" select="0"/>
        <xsl:param name="placesep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'placepubl.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="pubsep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'publyear.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="endsep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'pubinfo.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:choose>
            <xsl:when
                    test="(./publisher/publishername|./publishername|./publisher/address/city)and($onlydate=0)and(./pubdate[not(@role='issuing')]|./copyright/year|./date[@role='upd']|./date[@role='upd'])">
                <xsl:apply-templates mode="iso690.mode" select="./publisher/address/city">
                    <xsl:with-param name="sep" select="$placesep"/>
                </xsl:apply-templates>
                <xsl:apply-templates mode="iso690.mode" select="./publisher/publishername|./publishername">
                    <xsl:with-param name="sep" select="$pubsep"/>
                </xsl:apply-templates>
                <xsl:apply-templates mode="iso690.mode" select="./pubdate[not(@role='issuing')]|./copyright/year">
                    <xsl:with-param name="sep" select="$endsep"/>
                </xsl:apply-templates>
                <xsl:if test="not(./pubdate[not(@role='issuing')]|./copyright/year)">
                    <xsl:call-template name="iso690.data">
                        <xsl:with-param name="sep" select="$endsep"/>
                    </xsl:call-template>
                </xsl:if>
            </xsl:when>
            <xsl:when test="(./publisher/publishername|./publishername)and(./publisher/address/city)and($onlydate=0)">
                <xsl:apply-templates mode="iso690.mode" select="./publisher/address/city">
                    <xsl:with-param name="sep" select="$placesep"/>
                </xsl:apply-templates>
                <xsl:apply-templates mode="iso690.mode" select="./publisher/publishername|./publishername">
                    <xsl:with-param name="sep" select="$endsep"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:when test="($onlydate=1)or(./pubdate[not(@role='issuing')]|./copyright/year)">
                <xsl:apply-templates mode="iso690.mode" select="./pubdate[not(@role='issuing')]|./copyright/year">
                    <xsl:with-param name="sep" select="$endsep"/>
                </xsl:apply-templates>
                <xsl:if test="$onlydate=1">
                    <xsl:call-template name="iso690.location">
                        <xsl:with-param name="onlypages" select="1"/>
                    </xsl:call-template>
                </xsl:if>
            </xsl:when>
            <xsl:when test="not(./pubdate[not(@role='issuing')]|./copyright/year)">
                <xsl:call-template name="iso690.data">
                    <xsl:with-param name="sep" select="$endsep"/>
                </xsl:call-template>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="iso690.paper.pub">
        <xsl:param name="spec.pubinfo.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'spec.pubinfo.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:choose>
            <xsl:when test="./volumnum|./issuenum|./pagenums">
                <xsl:call-template name="iso690.pub">
                    <xsl:with-param name="endsep" select="$spec.pubinfo.sep"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="iso690.pub"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="iso690.data">
        <xsl:param name="sep"/>
        <xsl:param name="datecit2">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'datecit2'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:apply-templates mode="iso690.mode" select="./date[@role='upd']">
            <xsl:with-param name="sep"/>
        </xsl:apply-templates>
        <xsl:apply-templates mode="iso690.mode" select="./date[@role='cit']"/>
        <xsl:choose>
            <xsl:when test="./date[@role='cit']">
                <xsl:call-template name="iso690.endsep">
                    <xsl:with-param name="text" select="$datecit2"/>
                    <xsl:with-param name="sep" select="$sep"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="./date[@role='upd']">
                <xsl:call-template name="iso690.endsep">
                    <xsl:with-param name="text" select="string(./date[@role='upd'])"/>
                    <xsl:with-param name="sep" select="$sep"/>
                </xsl:call-template>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="publisher/address/city|publishername" mode="iso690.mode">
        <xsl:param name="sep"/>
        <xsl:param name="upd" select="0"/>
        <xsl:apply-templates mode="iso690.mode"/>
        <xsl:call-template name="iso690.endsep">
            <xsl:with-param name="text" select="string(.)"/>
            <xsl:with-param name="sep" select="$sep"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="pubdate|copyright/year" mode="iso690.mode">
        <xsl:param name="sep"/>
        <xsl:param name="upd" select="1"/>
        <xsl:param name="datecit2">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'datecit2'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:variable name="substr" select="substring(string(.),string-length(string(.)))"/>
        <xsl:if test="name(.)!='pubdate'">
            <xsl:value-of select="'&#xA9;'"/>
            <!-- copyright -->
        </xsl:if>
        <xsl:apply-templates mode="iso690.mode"/>
        <xsl:call-template name="iso690.space">
            <xsl:with-param name="text" select="$substr"/>
        </xsl:call-template>
        <xsl:if test="$upd!=0">
            <xsl:choose>
                <xsl:when test="name(.)='pubdate'">
                    <xsl:apply-templates mode="iso690.mode" select="../date[@role='upd']"/>
                    <xsl:apply-templates mode="iso690.mode" select="../date[@role='cit']"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates mode="iso690.mode" select="../../date[@role='upd']"/>
                    <xsl:apply-templates mode="iso690.mode" select="../../date[@role='cit']"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
        <xsl:choose>
            <xsl:when test="../date[@role='cit']|../../date[@role='cit'] and $upd!=0">
                <xsl:call-template name="iso690.endsep">
                    <xsl:with-param name="text" select="$datecit2"/>
                    <xsl:with-param name="sep" select="$sep"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="../date[@role='upd']|../../date[@role='upd'] and $upd!=0">
                <xsl:call-template name="iso690.endsep">
                    <xsl:with-param name="text" select="string(../date[@role='upd'])"/>
                    <xsl:with-param name="sep" select="$sep"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="$substr='-'">
                <xsl:call-template name="iso690.endsep">
                    <xsl:with-param name="text" select="' '"/>
                    <xsl:with-param name="sep" select="$sep"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="iso690.endsep">
                    <xsl:with-param name="text" select="string(.)"/>
                    <xsl:with-param name="sep" select="$sep"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="iso690.space">
        <xsl:param name="text" select="substring(string(.),string-length(string(.)))"/>
        <xsl:if test="$text='-'">
            <xsl:value-of select="' '"/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="date[@role='upd']" mode="iso690.mode">
        <xsl:param name="sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'upd.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:value-of select="$sep"/>
        <xsl:apply-templates mode="iso690.mode"/>
    </xsl:template>
    <xsl:template match="date[@role='cit']" mode="iso690.mode">
        <xsl:param name="datecit1">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'datecit1'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="datecit2">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'datecit2'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:value-of select="$datecit1"/>
        <xsl:apply-templates mode="iso690.mode"/>
        <xsl:value-of select="$datecit2"/>
    </xsl:template>
    <xsl:template name="iso690.extent">
        <xsl:param name="extent.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'extent.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:apply-templates mode="iso690.mode" select="./pagenums">
            <xsl:with-param name="sep" select="$extent.sep"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template name="iso690.part.location">
        <xsl:param name="location.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'location.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:choose>
            <xsl:when test="./pagenums">
                <xsl:apply-templates mode="iso690.mode" select="./bibliomisc[@role='secnum']"/>
                <xsl:apply-templates mode="iso690.mode" select="./bibliomisc[@role='sectitle']"/>
                <xsl:apply-templates mode="iso690.mode" select="./pagenums"/>
            </xsl:when>
            <xsl:when test="./bibliomisc[@role='sectitle']">
                <xsl:apply-templates mode="iso690.mode" select="./bibliomisc[@role='secnum']"/>
                <xsl:apply-templates mode="iso690.mode" select="./bibliomisc[@role='sectitle']">
                    <xsl:with-param name="sep" select="$location.sep"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="iso690.mode" select="./bibliomisc[@role='secnum']">
                    <xsl:with-param name="sep" select="$location.sep"/>
                </xsl:apply-templates>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="iso690.article.location">
        <xsl:param name="location.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'location.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="locs.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'locs.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:choose>
            <xsl:when test="not(./date[@role='upd']|./date[@role='cit'])">
                <xsl:choose>
                    <xsl:when test="./volumenum|./issuenum|./pagenums">
                        <xsl:apply-templates mode="iso690.mode" select="./pubdate[not(@role='issuing')]">
                            <xsl:with-param name="upd" select="0"/>
                            <xsl:with-param name="sep" select="$locs.sep"/>
                        </xsl:apply-templates>
                        <xsl:call-template name="iso690.location"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates mode="iso690.mode" select="./pubdate[not(@role='issuing')]">
                            <xsl:with-param name="sep" select="$location.sep"/>
                        </xsl:apply-templates>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="./volumenum|./issuenum|./pagenums">
                        <xsl:apply-templates mode="iso690.mode" select="./pubdate[not(@role='issuing')]">
                            <xsl:with-param name="upd" select="0"/>
                            <xsl:with-param name="sep" select="$locs.sep"/>
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates mode="iso690.mode" select="./pubdate[not(@role='issuing')]">
                            <xsl:with-param name="upd" select="0"/>
                            <xsl:with-param name="sep" select="$location.sep"/>
                        </xsl:apply-templates>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:choose>
                    <xsl:when test="./issuenum">
                        <xsl:apply-templates mode="iso690.mode" select="./volumenum"/>
                        <xsl:apply-templates mode="iso690.mode" select="./issuenum">
                            <xsl:with-param name="sep"/>
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates mode="iso690.mode" select="./volumenum">
                            <xsl:with-param name="sep"/>
                        </xsl:apply-templates>
                    </xsl:otherwise>
                </xsl:choose>
                <xsl:choose>
                    <xsl:when test="./pagenums">
                        <xsl:call-template name="iso690.data">
                            <xsl:with-param name="sep" select="$locs.sep"/>
                        </xsl:call-template>
                        <xsl:apply-templates mode="iso690.mode" select="./pagenums"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="iso690.data">
                            <xsl:with-param name="sep" select="$location.sep"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="iso690.location">
        <xsl:param name="location.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'location.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:choose>
            <xsl:when test="./volumenum and not(./issuenum) and not(./pagenums)">
                <xsl:apply-templates mode="iso690.mode" select="./volumenum">
                    <xsl:with-param name="sep" select="$location.sep"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:when test="./issuenum and not(./pagenums)">
                <xsl:apply-templates mode="iso690.mode" select="./volumenum"/>
                <xsl:apply-templates mode="iso690.mode" select="./issuenum">
                    <xsl:with-param name="sep" select="$location.sep"/>
                </xsl:apply-templates>
            </xsl:when>
            <xsl:when test="./pagenums">
                <xsl:apply-templates mode="iso690.mode" select="./volumenum"/>
                <xsl:apply-templates mode="iso690.mode" select="./issuenum"/>
                <xsl:apply-templates mode="iso690.mode" select="./pagenums"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="bibliomisc[@role='secnum']|bibliomisc[@role='sectitle']" mode="iso690.mode">
        <xsl:param name="sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'locs.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:apply-templates mode="iso690.mode"/>
        <xsl:call-template name="iso690.endsep">
            <xsl:with-param name="text" select="string(.)"/>
            <xsl:with-param name="sep" select="$sep"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="volumenum|issuenum" mode="iso690.mode">
        <xsl:param name="sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'locs.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:apply-templates mode="iso690.mode"/>
        <xsl:call-template name="iso690.endsep">
            <xsl:with-param name="text" select="string(.)"/>
            <xsl:with-param name="sep" select="$sep"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="pagenums" mode="iso690.mode">
        <xsl:param name="sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'location.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:apply-templates mode="iso690.mode"/>
        <xsl:call-template name="iso690.endsep">
            <xsl:with-param name="text" select="string(.)"/>
            <xsl:with-param name="sep" select="$sep"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="iso690.serie">
        <xsl:apply-templates mode="iso690.mode" select=".//bibliomisc[@role='serie']"/>
    </xsl:template>
    <xsl:template name="iso690.notice">
        <xsl:apply-templates mode="iso690.mode" select=".//bibliomisc[not(@role)]"/>
    </xsl:template>
    <xsl:template match="bibliomisc[not(@role)]|bibliomisc[@role='serie']" mode="iso690.mode">
        <xsl:param name="notice.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'notice.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:apply-templates mode="iso690.mode"/>
        <xsl:call-template name="iso690.endsep">
            <xsl:with-param name="text" select="string(.)"/>
            <xsl:with-param name="sep" select="$notice.sep"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="iso690.access">
        <xsl:for-each select="./biblioid[@class='uri']|./bibliomisc[@role='access']">
            <xsl:choose>
                <xsl:when test="position()=1">
                    <xsl:apply-templates mode="iso690.mode" select="."/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates mode="iso690.mode" select=".">
                        <xsl:with-param name="firstacc" select="0"/>
                    </xsl:apply-templates>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:for-each>
    </xsl:template>
    <xsl:template match="biblioid[@class='uri']/ulink|bibliomisc[@role='access']/ulink" mode="iso690.mode">
        <xsl:param name="link1">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'link1'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="link2">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'link2'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:value-of select="$link1"/>
        <xsl:call-template name="ulink"/>
        <xsl:value-of select="$link2"/>
    </xsl:template>
    <xsl:template match="biblioid[@class='uri']|bibliomisc[@role='access']" mode="iso690.mode">
        <xsl:param name="firstacc" select="1"/>
        <xsl:param name="access">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'access'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="acctoo">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'acctoo'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="onwww">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'onwww'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="oninet">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'oninet'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="access.end">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'access.end'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="access.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'access.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:choose>
            <xsl:when test="$firstacc=1">
                <xsl:value-of select="$access"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$acctoo"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:choose>
            <xsl:when test="(./ulink)and(string(./ulink)=string(.))">
                <xsl:choose>
                    <xsl:when test="(starts-with(./ulink/@url,'http://')or(starts-with(./ulink/@url,'https://')))">
                        <xsl:value-of select="$onwww"/>
                        <xsl:value-of select="$access.end"/>
                        <xsl:apply-templates mode="iso690.mode" select="./ulink"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$oninet"/>
                        <xsl:value-of select="$access.end"/>
                        <xsl:apply-templates mode="iso690.mode" select="./ulink"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="(./ulink)and(string(./ulink)!=string(.))">
                <xsl:value-of select="text()[1]"/>
                <xsl:call-template name="iso690.endsep">
                    <xsl:with-param name="text" select="text()[1]"/>
                    <xsl:with-param name="sep" select="$access.end"/>
                </xsl:call-template>
                <xsl:apply-templates mode="iso690.mode" select="./ulink"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="iso690.mode"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:value-of select="$access.sep"/>
    </xsl:template>
    <xsl:template name="iso690.isbn">
        <xsl:choose>
            <xsl:when test="./biblioid/@class='isbn'">
                <xsl:apply-templates mode="iso690.mode" select="./biblioid[@class='isbn']"/>
            </xsl:when>
            <xsl:when test="./isbn">
                <xsl:apply-templates mode="iso690.mode" select="./isbn"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="isbn|biblioid[@class='isbn']" mode="iso690.mode">
        <xsl:param name="isbn">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'isbn'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="stdnum.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'stdnum.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:value-of select="$isbn"/>
        <xsl:apply-templates mode="iso690.mode"/>
        <xsl:value-of select="$stdnum.sep"/>
    </xsl:template>
    <xsl:template name="iso690.issn">
        <xsl:choose>
            <xsl:when test="./biblioid/@class='issn'">
                <xsl:apply-templates mode="iso690.mode" select="./biblioid[@class='issn']"/>
            </xsl:when>
            <xsl:when test="./issn">
                <xsl:apply-templates mode="iso690.mode" select="./issn"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="issn|biblioid[@class='issn']" mode="iso690.mode">
        <xsl:param name="issn">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'issn'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:param name="stdnum.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'stdnum.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:value-of select="$issn"/>
        <xsl:apply-templates mode="iso690.mode"/>
        <xsl:value-of select="$stdnum.sep"/>
    </xsl:template>
    <xsl:template name="iso690.pat.ident">
        <xsl:param name="patdate.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'patdate.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:apply-templates mode="iso690.mode" select="./address/country"/>
        <xsl:apply-templates mode="iso690.mode" select="./bibliomisc[@role='patenttype']"/>
        <xsl:choose>
            <xsl:when test="./biblioid[@class='other' and @otherclass='patentnum']">
                <xsl:apply-templates mode="iso690.mode"
                                     select="./biblioid[@class='other' and @otherclass='patentnum']"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="iso690.mode" select="./bibliomisc[@role='patentnum']"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:apply-templates mode="iso690.mode" select="./pubdate[not(@role='issuing')]">
            <xsl:with-param name="sep" select="$patdate.sep"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="address/country" mode="iso690.mode">
        <xsl:param name="patcountry.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'patcountry.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <em>
            <xsl:apply-templates mode="iso690.mode"/>
        </em>
        <xsl:value-of select="$patcountry.sep"/>
    </xsl:template>
    <xsl:template match="bibliomisc[@role='patenttype']" mode="iso690.mode">
        <xsl:param name="pattype.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'pattype.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <em>
            <xsl:apply-templates mode="iso690.mode"/>
        </em>
        <xsl:value-of select="$pattype.sep"/>
    </xsl:template>
    <xsl:template match="biblioid[@class='other' and @otherclass='patentnum']|bibliomisc[@role='patentnum']"
                  mode="iso690.mode">
        <xsl:param name="patnum.sep">
            <xsl:call-template name="gentext.template">
                <xsl:with-param name="context" select="'iso690'"/>
                <xsl:with-param name="name" select="'patnum.sep'"/>
            </xsl:call-template>
        </xsl:param>
        <xsl:apply-templates mode="iso690.mode"/>
        <xsl:value-of select="$patnum.sep"/>
    </xsl:template>
    <xsl:template name="iso690.endsep">
        <xsl:param name="text"/>
        <xsl:param name="sep" select=". "/>
        <xsl:choose>
            <xsl:when test="substring($text,string-length($text))!=substring($sep,1,1)">
                <xsl:value-of select="$sep"/>
            </xsl:when>
            <xsl:when test="substring($text,string-length($text))=' '">
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="' '"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*" mode="iso690.mode">
        <xsl:apply-templates select="."/>
        <!-- try the default mode -->
    </xsl:template>
    <xsl:template match="glossary">

        <xsl:variable name="language">
            <xsl:call-template name="l10n.language"/>
        </xsl:variable>

        <xsl:variable name="lowercase">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key">normalize.sort.input</xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="uppercase">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key">normalize.sort.output</xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:call-template name="id.warning"/>

        <xsl:element name="{$div.element}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:call-template name="glossary.titlepage"/>

            <xsl:choose>
                <xsl:when test="glossdiv">
                    <xsl:apply-templates select="(glossdiv[1]/preceding-sibling::*)"/>
                </xsl:when>
                <xsl:when test="glossentry">
                    <xsl:apply-templates select="(glossentry[1]/preceding-sibling::*)"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates/>
                </xsl:otherwise>
            </xsl:choose>

            <xsl:choose>
                <xsl:when test="glossdiv">
                    <xsl:apply-templates select="glossdiv"/>
                </xsl:when>
                <xsl:when test="glossentry">
                    <dl>
                        <xsl:choose>
                            <xsl:when test="$glossary.sort != 0">
                                <xsl:apply-templates select="glossentry">
                                    <xsl:sort lang="{$language}"
                                              select="normalize-space(translate(concat(@sortas, glossterm[not(parent::glossentry/@sortas) or parent::glossentry/@sortas = '']), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'))"/>
                                </xsl:apply-templates>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:apply-templates select="glossentry"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </dl>
                </xsl:when>
                <xsl:otherwise>
                    <!-- empty glossary -->
                </xsl:otherwise>
            </xsl:choose>

            <xsl:if test="not(parent::article)">
                <xsl:call-template name="process.footnotes"/>
            </xsl:if>
        </xsl:element>
    </xsl:template>
    <xsl:template match="glossary/glossaryinfo"/>
    <xsl:template match="glossary/info"/>
    <xsl:template match="glossary/title"/>
    <xsl:template match="glossary/subtitle"/>
    <xsl:template match="glossary/titleabbrev"/>
    <xsl:template match="glosslist">

        <xsl:variable name="language">
            <xsl:call-template name="l10n.language"/>
        </xsl:variable>

        <xsl:variable name="lowercase">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key">normalize.sort.input</xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="uppercase">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key">normalize.sort.output</xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:if test="blockinfo/title|info/title|title">
                <xsl:call-template name="formal.object.heading"/>
            </xsl:if>
            <dl>
                <xsl:choose>
                    <xsl:when test="$glossary.sort != 0">
                        <xsl:apply-templates select="glossentry">
                            <xsl:sort lang="{$language}"
                                      select="normalize-space(translate(concat(@sortas, glossterm[not(parent::glossentry/@sortas) or parent::glossentry/@sortas = '']), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'))"/>
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="glossentry"/>
                    </xsl:otherwise>
                </xsl:choose>
            </dl>
        </div>
    </xsl:template>
    <xsl:template match="glossdiv">

        <xsl:variable name="language">
            <xsl:call-template name="l10n.language"/>
        </xsl:variable>

        <xsl:variable name="lowercase">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key">normalize.sort.input</xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="uppercase">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key">normalize.sort.output</xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:call-template name="id.warning"/>

        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:apply-templates select="(glossentry[1]/preceding-sibling::*)"/>

            <dl>
                <xsl:choose>
                    <xsl:when test="$glossary.sort != 0">
                        <xsl:apply-templates select="glossentry">
                            <xsl:sort lang="{$language}"
                                      select="translate(glossterm, $lowercase,                                          $uppercase)"/>
                        </xsl:apply-templates>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates select="glossentry"/>
                    </xsl:otherwise>
                </xsl:choose>
            </dl>
        </div>
    </xsl:template>
    <xsl:template match="glossdiv/title">
        <h3>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:apply-templates/>
        </h3>
    </xsl:template>
    <xsl:template match="glossentry">
        <xsl:choose>
            <xsl:when test="$glossentry.show.acronym = 'primary'">
                <dt>
                    <xsl:call-template name="id.attribute">
                        <xsl:with-param name="conditional">
                            <xsl:choose>
                                <xsl:when test="$glossterm.auto.link != 0">0</xsl:when>
                                <xsl:otherwise>1</xsl:otherwise>
                            </xsl:choose>
                        </xsl:with-param>
                    </xsl:call-template>
                    <xsl:call-template name="anchor">
                        <xsl:with-param name="conditional">
                            <xsl:choose>
                                <xsl:when test="$glossterm.auto.link != 0">0</xsl:when>
                                <xsl:otherwise>1</xsl:otherwise>
                            </xsl:choose>
                        </xsl:with-param>
                    </xsl:call-template>

                    <xsl:choose>
                        <xsl:when test="acronym|abbrev">
                            <xsl:apply-templates select="acronym|abbrev"/>
                            <xsl:text> (</xsl:text>
                            <xsl:apply-templates select="glossterm"/>
                            <xsl:text>)</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:apply-templates select="glossterm"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </dt>
            </xsl:when>
            <xsl:when test="$glossentry.show.acronym = 'yes'">
                <dt>
                    <xsl:call-template name="id.attribute">
                        <xsl:with-param name="conditional">
                            <xsl:choose>
                                <xsl:when test="$glossterm.auto.link != 0">0</xsl:when>
                                <xsl:otherwise>1</xsl:otherwise>
                            </xsl:choose>
                        </xsl:with-param>
                    </xsl:call-template>
                    <xsl:call-template name="anchor">
                        <xsl:with-param name="conditional">
                            <xsl:choose>
                                <xsl:when test="$glossterm.auto.link != 0">0</xsl:when>
                                <xsl:otherwise>1</xsl:otherwise>
                            </xsl:choose>
                        </xsl:with-param>
                    </xsl:call-template>

                    <xsl:apply-templates select="glossterm"/>

                    <xsl:if test="acronym|abbrev">
                        <xsl:text> (</xsl:text>
                        <xsl:apply-templates select="acronym|abbrev"/>
                        <xsl:text>)</xsl:text>
                    </xsl:if>
                </dt>
            </xsl:when>
            <xsl:otherwise>
                <dt>
                    <xsl:call-template name="id.attribute">
                        <xsl:with-param name="conditional">
                            <xsl:choose>
                                <xsl:when test="$glossterm.auto.link != 0">0</xsl:when>
                                <xsl:otherwise>1</xsl:otherwise>
                            </xsl:choose>
                        </xsl:with-param>
                    </xsl:call-template>
                    <xsl:call-template name="anchor">
                        <xsl:with-param name="conditional">
                            <xsl:choose>
                                <xsl:when test="$glossterm.auto.link != 0">0</xsl:when>
                                <xsl:otherwise>1</xsl:otherwise>
                            </xsl:choose>
                        </xsl:with-param>
                    </xsl:call-template>

                    <xsl:apply-templates select="glossterm"/>
                </dt>
            </xsl:otherwise>
        </xsl:choose>

        <xsl:apply-templates select="indexterm|revhistory|glosssee|glossdef"/>
    </xsl:template>
    <xsl:template match="glossentry/glossterm">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:apply-templates/>
        </span>
        <xsl:if test="following-sibling::glossterm">,</xsl:if>
    </xsl:template>
    <xsl:template match="glossentry/acronym">
        <xsl:apply-templates/>
        <xsl:if test="following-sibling::acronym|following-sibling::abbrev">,</xsl:if>
    </xsl:template>
    <xsl:template match="glossentry/abbrev">
        <xsl:apply-templates/>
        <xsl:if test="following-sibling::acronym|following-sibling::abbrev">,</xsl:if>
    </xsl:template>
    <xsl:template match="glossentry/revhistory">
    </xsl:template>
    <xsl:template match="glossentry/glosssee">
        <xsl:variable name="otherterm" select="@otherterm"/>
        <xsl:variable name="targets" select="key('id', $otherterm)"/>
        <xsl:variable name="target" select="$targets[1]"/>
        <xsl:variable name="xlink" select="@xlink:href"/>

        <dd>
            <p>
                <xsl:variable name="template">
                    <xsl:call-template name="gentext.template">
                        <xsl:with-param name="context" select="'glossary'"/>
                        <xsl:with-param name="name" select="'see'"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="title">
                    <xsl:choose>
                        <xsl:when test="$target">
                            <a>
                                <xsl:apply-templates select="." mode="common.html.attributes"/>
                                <xsl:call-template name="id.attribute"/>
                                <xsl:attribute name="href">
                                    <xsl:call-template name="href.target">
                                        <xsl:with-param name="object" select="$target"/>
                                    </xsl:call-template>
                                </xsl:attribute>
                                <xsl:apply-templates select="$target" mode="xref-to"/>
                            </a>
                        </xsl:when>
                        <xsl:when test="$xlink">
                            <xsl:call-template name="simple.xlink">
                                <xsl:with-param name="content">
                                    <xsl:apply-templates/>
                                </xsl:with-param>
                            </xsl:call-template>
                        </xsl:when>
                        <xsl:when test="$otherterm != '' and not($target)">
                            <xsl:message>
                                <xsl:text>Warning: glosssee @otherterm reference not found: </xsl:text>
                                <xsl:value-of select="$otherterm"/>
                            </xsl:message>
                            <xsl:apply-templates/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:apply-templates/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>

                <xsl:call-template name="substitute-markup">
                    <xsl:with-param name="template" select="$template"/>
                    <xsl:with-param name="title" select="$title"/>
                </xsl:call-template>
            </p>
        </dd>
    </xsl:template>
    <xsl:template match="glossentry/glossdef">
        <dd>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:apply-templates select="*[local-name(.) != 'glossseealso']"/>
            <xsl:if test="glossseealso">
                <p>
                    <xsl:variable name="template">
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="context" select="'glossary'"/>
                            <xsl:with-param name="name" select="'seealso'"/>
                        </xsl:call-template>
                    </xsl:variable>
                    <xsl:variable name="title">
                        <xsl:apply-templates select="glossseealso"/>
                    </xsl:variable>
                    <xsl:call-template name="substitute-markup">
                        <xsl:with-param name="template" select="$template"/>
                        <xsl:with-param name="title" select="$title"/>
                    </xsl:call-template>
                </p>
            </xsl:if>
        </dd>
    </xsl:template>
    <xsl:template match="glossseealso">
        <xsl:variable name="otherterm" select="@otherterm"/>
        <xsl:variable name="targets" select="key('id', $otherterm)"/>
        <xsl:variable name="target" select="$targets[1]"/>
        <xsl:variable name="xlink" select="@xlink:href"/>

        <xsl:choose>
            <xsl:when test="$target">
                <a>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:attribute name="href">
                        <xsl:call-template name="href.target">
                            <xsl:with-param name="object" select="$target"/>
                        </xsl:call-template>
                    </xsl:attribute>
                    <xsl:apply-templates select="$target" mode="xref-to"/>
                </a>
            </xsl:when>
            <xsl:when test="$xlink">
                <xsl:call-template name="simple.xlink">
                    <xsl:with-param name="content">
                        <xsl:apply-templates/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="$otherterm != '' and not($target)">
                <xsl:message>
                    <xsl:text>Warning: glossseealso @otherterm reference not found: </xsl:text>
                    <xsl:value-of select="$otherterm"/>
                </xsl:message>
                <xsl:apply-templates/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates/>
            </xsl:otherwise>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="position() = last()"/>
            <xsl:otherwise>
                <xsl:call-template name="gentext.template">
                    <xsl:with-param name="context" select="'glossary'"/>
                    <xsl:with-param name="name" select="'seealso-separator'"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="glossary[@role='auto']" priority="2">

        <xsl:variable name="language">
            <xsl:call-template name="l10n.language"/>
        </xsl:variable>

        <xsl:variable name="lowercase">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key">normalize.sort.input</xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="uppercase">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key">normalize.sort.output</xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="terms" select="//glossterm[not(parent::glossdef)]|//firstterm"/>
        <xsl:variable name="collection" select="document($glossary.collection, .)"/>

        <xsl:call-template name="id.warning"/>

        <xsl:if test="$glossary.collection = ''">
            <xsl:message>
                <xsl:text>Warning: processing automatic glossary </xsl:text>
                <xsl:text>without a glossary.collection file.</xsl:text>
            </xsl:message>
        </xsl:if>

        <xsl:if test="not($collection) and $glossary.collection != ''">
            <xsl:message>
                <xsl:text>Warning: processing automatic glossary but unable to </xsl:text>
                <xsl:text>open glossary.collection file '</xsl:text>
                <xsl:value-of select="$glossary.collection"/>
                <xsl:text>'</xsl:text>
            </xsl:message>
        </xsl:if>

        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>

            <xsl:call-template name="glossary.titlepage"/>

            <xsl:choose>
                <xsl:when test="glossdiv and $collection//glossdiv">
                    <xsl:for-each select="$collection//glossdiv">
                        <!-- first see if there are any in this div -->
                        <xsl:variable name="exist.test">
                            <xsl:for-each select="glossentry">
                                <xsl:variable name="cterm" select="glossterm"/>
                                <xsl:if test="$terms[@baseform = $cterm or . = $cterm]">
                                    <xsl:value-of select="glossterm"/>
                                </xsl:if>
                            </xsl:for-each>
                        </xsl:variable>

                        <xsl:if test="$exist.test != ''">
                            <xsl:apply-templates select="." mode="auto-glossary">
                                <xsl:with-param name="terms" select="$terms"/>
                            </xsl:apply-templates>
                        </xsl:if>
                    </xsl:for-each>
                </xsl:when>
                <xsl:otherwise>
                    <dl>
                        <xsl:choose>
                            <xsl:when test="$glossary.sort != 0">
                                <xsl:for-each select="$collection//glossentry">
                                    <xsl:sort lang="{$language}"
                                              select="normalize-space(translate(concat(@sortas, glossterm[not(parent::glossentry/@sortas) or parent::glossentry/@sortas = '']), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'))"/>
                                    <xsl:variable name="cterm" select="glossterm"/>
                                    <xsl:if test="$terms[@baseform = $cterm or . = $cterm]">
                                        <xsl:apply-templates select="." mode="auto-glossary"/>
                                    </xsl:if>
                                </xsl:for-each>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:for-each select="$collection//glossentry">
                                    <xsl:variable name="cterm" select="glossterm"/>
                                    <xsl:if test="$terms[@baseform = $cterm or . = $cterm]">
                                        <xsl:apply-templates select="." mode="auto-glossary"/>
                                    </xsl:if>
                                </xsl:for-each>
                            </xsl:otherwise>
                        </xsl:choose>
                    </dl>
                </xsl:otherwise>
            </xsl:choose>

            <xsl:if test="not(parent::article)">
                <xsl:call-template name="process.footnotes"/>
            </xsl:if>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="auto-glossary">
        <!-- pop back out to the default mode for most elements -->
        <xsl:apply-templates select="."/>
    </xsl:template>
    <xsl:template match="glossdiv" mode="auto-glossary">
        <xsl:param name="terms" select="."/>


        <xsl:variable name="language">
            <xsl:call-template name="l10n.language"/>
        </xsl:variable>

        <xsl:variable name="lowercase">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key">normalize.sort.input</xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="uppercase">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key">normalize.sort.output</xsl:with-param>
            </xsl:call-template>
        </xsl:variable>


        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:apply-templates select="(glossentry[1]/preceding-sibling::*)"/>

            <dl>
                <xsl:choose>
                    <xsl:when test="$glossary.sort != 0">
                        <xsl:for-each select="glossentry">
                            <xsl:sort lang="{$language}"
                                      select="normalize-space(translate(concat(@sortas, glossterm[not(parent::glossentry/@sortas) or parent::glossentry/@sortas = '']), 'Aa&#xC0;&#xE0;&#xC1;&#xE1;&#xC2;&#xE2;&#xC3;&#xE3;&#xC4;&#xE4;&#xC5;&#xE5;&#x100;&#x101;&#x102;&#x103;&#x104;&#x105;&#x1CD;&#x1CE;&#x1DE;&#x1DF;&#x1E0;&#x1E1;&#x1FA;&#x1FB;&#x200;&#x201;&#x202;&#x203;&#x226;&#x227;&#x1E00;&#x1E01;&#x1E9A;&#x1EA0;&#x1EA1;&#x1EA2;&#x1EA3;&#x1EA4;&#x1EA5;&#x1EA6;&#x1EA7;&#x1EA8;&#x1EA9;&#x1EAA;&#x1EAB;&#x1EAC;&#x1EAD;&#x1EAE;&#x1EAF;&#x1EB0;&#x1EB1;&#x1EB2;&#x1EB3;&#x1EB4;&#x1EB5;&#x1EB6;&#x1EB7;Bb&#x180;&#x181;&#x253;&#x182;&#x183;&#x1E02;&#x1E03;&#x1E04;&#x1E05;&#x1E06;&#x1E07;Cc&#xC7;&#xE7;&#x106;&#x107;&#x108;&#x109;&#x10A;&#x10B;&#x10C;&#x10D;&#x187;&#x188;&#x255;&#x1E08;&#x1E09;Dd&#x10E;&#x10F;&#x110;&#x111;&#x18A;&#x257;&#x18B;&#x18C;&#x1C5;&#x1F2;&#x221;&#x256;&#x1E0A;&#x1E0B;&#x1E0C;&#x1E0D;&#x1E0E;&#x1E0F;&#x1E10;&#x1E11;&#x1E12;&#x1E13;Ee&#xC8;&#xE8;&#xC9;&#xE9;&#xCA;&#xEA;&#xCB;&#xEB;&#x112;&#x113;&#x114;&#x115;&#x116;&#x117;&#x118;&#x119;&#x11A;&#x11B;&#x204;&#x205;&#x206;&#x207;&#x228;&#x229;&#x1E14;&#x1E15;&#x1E16;&#x1E17;&#x1E18;&#x1E19;&#x1E1A;&#x1E1B;&#x1E1C;&#x1E1D;&#x1EB8;&#x1EB9;&#x1EBA;&#x1EBB;&#x1EBC;&#x1EBD;&#x1EBE;&#x1EBF;&#x1EC0;&#x1EC1;&#x1EC2;&#x1EC3;&#x1EC4;&#x1EC5;&#x1EC6;&#x1EC7;Ff&#x191;&#x192;&#x1E1E;&#x1E1F;Gg&#x11C;&#x11D;&#x11E;&#x11F;&#x120;&#x121;&#x122;&#x123;&#x193;&#x260;&#x1E4;&#x1E5;&#x1E6;&#x1E7;&#x1F4;&#x1F5;&#x1E20;&#x1E21;Hh&#x124;&#x125;&#x126;&#x127;&#x21E;&#x21F;&#x266;&#x1E22;&#x1E23;&#x1E24;&#x1E25;&#x1E26;&#x1E27;&#x1E28;&#x1E29;&#x1E2A;&#x1E2B;&#x1E96;Ii&#xCC;&#xEC;&#xCD;&#xED;&#xCE;&#xEE;&#xCF;&#xEF;&#x128;&#x129;&#x12A;&#x12B;&#x12C;&#x12D;&#x12E;&#x12F;&#x130;&#x197;&#x268;&#x1CF;&#x1D0;&#x208;&#x209;&#x20A;&#x20B;&#x1E2C;&#x1E2D;&#x1E2E;&#x1E2F;&#x1EC8;&#x1EC9;&#x1ECA;&#x1ECB;Jj&#x134;&#x135;&#x1F0;&#x29D;Kk&#x136;&#x137;&#x198;&#x199;&#x1E8;&#x1E9;&#x1E30;&#x1E31;&#x1E32;&#x1E33;&#x1E34;&#x1E35;Ll&#x139;&#x13A;&#x13B;&#x13C;&#x13D;&#x13E;&#x13F;&#x140;&#x141;&#x142;&#x19A;&#x1C8;&#x234;&#x26B;&#x26C;&#x26D;&#x1E36;&#x1E37;&#x1E38;&#x1E39;&#x1E3A;&#x1E3B;&#x1E3C;&#x1E3D;Mm&#x271;&#x1E3E;&#x1E3F;&#x1E40;&#x1E41;&#x1E42;&#x1E43;Nn&#xD1;&#xF1;&#x143;&#x144;&#x145;&#x146;&#x147;&#x148;&#x19D;&#x272;&#x19E;&#x220;&#x1CB;&#x1F8;&#x1F9;&#x235;&#x273;&#x1E44;&#x1E45;&#x1E46;&#x1E47;&#x1E48;&#x1E49;&#x1E4A;&#x1E4B;Oo&#xD2;&#xF2;&#xD3;&#xF3;&#xD4;&#xF4;&#xD5;&#xF5;&#xD6;&#xF6;&#xD8;&#xF8;&#x14C;&#x14D;&#x14E;&#x14F;&#x150;&#x151;&#x19F;&#x1A0;&#x1A1;&#x1D1;&#x1D2;&#x1EA;&#x1EB;&#x1EC;&#x1ED;&#x1FE;&#x1FF;&#x20C;&#x20D;&#x20E;&#x20F;&#x22A;&#x22B;&#x22C;&#x22D;&#x22E;&#x22F;&#x230;&#x231;&#x1E4C;&#x1E4D;&#x1E4E;&#x1E4F;&#x1E50;&#x1E51;&#x1E52;&#x1E53;&#x1ECC;&#x1ECD;&#x1ECE;&#x1ECF;&#x1ED0;&#x1ED1;&#x1ED2;&#x1ED3;&#x1ED4;&#x1ED5;&#x1ED6;&#x1ED7;&#x1ED8;&#x1ED9;&#x1EDA;&#x1EDB;&#x1EDC;&#x1EDD;&#x1EDE;&#x1EDF;&#x1EE0;&#x1EE1;&#x1EE2;&#x1EE3;Pp&#x1A4;&#x1A5;&#x1E54;&#x1E55;&#x1E56;&#x1E57;Qq&#x2A0;Rr&#x154;&#x155;&#x156;&#x157;&#x158;&#x159;&#x210;&#x211;&#x212;&#x213;&#x27C;&#x27D;&#x27E;&#x1E58;&#x1E59;&#x1E5A;&#x1E5B;&#x1E5C;&#x1E5D;&#x1E5E;&#x1E5F;Ss&#x15A;&#x15B;&#x15C;&#x15D;&#x15E;&#x15F;&#x160;&#x161;&#x218;&#x219;&#x282;&#x1E60;&#x1E61;&#x1E62;&#x1E63;&#x1E64;&#x1E65;&#x1E66;&#x1E67;&#x1E68;&#x1E69;Tt&#x162;&#x163;&#x164;&#x165;&#x166;&#x167;&#x1AB;&#x1AC;&#x1AD;&#x1AE;&#x288;&#x21A;&#x21B;&#x236;&#x1E6A;&#x1E6B;&#x1E6C;&#x1E6D;&#x1E6E;&#x1E6F;&#x1E70;&#x1E71;&#x1E97;Uu&#xD9;&#xF9;&#xDA;&#xFA;&#xDB;&#xFB;&#xDC;&#xFC;&#x168;&#x169;&#x16A;&#x16B;&#x16C;&#x16D;&#x16E;&#x16F;&#x170;&#x171;&#x172;&#x173;&#x1AF;&#x1B0;&#x1D3;&#x1D4;&#x1D5;&#x1D6;&#x1D7;&#x1D8;&#x1D9;&#x1DA;&#x1DB;&#x1DC;&#x214;&#x215;&#x216;&#x217;&#x1E72;&#x1E73;&#x1E74;&#x1E75;&#x1E76;&#x1E77;&#x1E78;&#x1E79;&#x1E7A;&#x1E7B;&#x1EE4;&#x1EE5;&#x1EE6;&#x1EE7;&#x1EE8;&#x1EE9;&#x1EEA;&#x1EEB;&#x1EEC;&#x1EED;&#x1EEE;&#x1EEF;&#x1EF0;&#x1EF1;Vv&#x1B2;&#x28B;&#x1E7C;&#x1E7D;&#x1E7E;&#x1E7F;Ww&#x174;&#x175;&#x1E80;&#x1E81;&#x1E82;&#x1E83;&#x1E84;&#x1E85;&#x1E86;&#x1E87;&#x1E88;&#x1E89;&#x1E98;Xx&#x1E8A;&#x1E8B;&#x1E8C;&#x1E8D;Yy&#xDD;&#xFD;&#xFF;&#x178;&#x176;&#x177;&#x1B3;&#x1B4;&#x232;&#x233;&#x1E8E;&#x1E8F;&#x1E99;&#x1EF2;&#x1EF3;&#x1EF4;&#x1EF5;&#x1EF6;&#x1EF7;&#x1EF8;&#x1EF9;Zz&#x179;&#x17A;&#x17B;&#x17C;&#x17D;&#x17E;&#x1B5;&#x1B6;&#x224;&#x225;&#x290;&#x291;&#x1E90;&#x1E91;&#x1E92;&#x1E93;&#x1E94;&#x1E95;&#x1E95;', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPQQQRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVWWWWWWWWWWWWWWWXXXXXXYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZ'))"/>
                            <xsl:variable name="cterm" select="glossterm"/>
                            <xsl:if test="$terms[@baseform = $cterm or . = $cterm]">
                                <xsl:apply-templates select="." mode="auto-glossary"/>
                            </xsl:if>
                        </xsl:for-each>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:for-each select="glossentry">
                            <xsl:variable name="cterm" select="glossterm"/>
                            <xsl:if test="$terms[@baseform = $cterm or . = $cterm]">
                                <xsl:apply-templates select="." mode="auto-glossary"/>
                            </xsl:if>
                        </xsl:for-each>
                    </xsl:otherwise>
                </xsl:choose>
            </dl>
        </div>
    </xsl:template>
    <xsl:template match="blockinfo|info">
        <!-- suppress -->
    </xsl:template>
    <xsl:template name="block.object">
        <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="para">
        <xsl:call-template name="paragraph">
            <xsl:with-param name="class">
                <xsl:if test="@role and $para.propagates.style != 0">
                    <xsl:value-of select="@role"/>
                </xsl:if>
            </xsl:with-param>
            <xsl:with-param name="content">
                <xsl:if test="position() = 1 and parent::listitem">
                    <xsl:call-template name="anchor">
                        <xsl:with-param name="node" select="parent::listitem"/>
                    </xsl:call-template>
                </xsl:if>

                <xsl:call-template name="anchor"/>
                <xsl:apply-templates/>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="formalpara/info">
        <xsl:apply-templates select="title"/>
    </xsl:template>
    <xsl:template match="formalpara/para">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="blockquote">
        <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>

            <xsl:choose>
                <xsl:when test="attribution">
                    <table border="{$table.border.off}" class="{$class.prefix}blockquote">
                        <xsl:if test="$css.decoration != 0">
                            <xsl:attribute name="style">
                                <xsl:text>width: 100%; cellspacing: 0; cellpadding: 0;</xsl:text>
                            </xsl:attribute>
                        </xsl:if>
                        <xsl:if test="$div.element != 'section'">
                            <xsl:attribute name="summary">Block quote</xsl:attribute>
                        </xsl:if>
                        <tr>
                            <td width="10%" valign="top"></td>
                            <td width="80%" valign="top">
                                <xsl:apply-templates select="child::*[local-name(.)!='attribution']"/>
                            </td>
                            <td width="10%" valign="top"></td>
                        </tr>
                        <tr>
                            <td width="10%" valign="top"></td>
                            <td colspan="2" align="{$direction.align.end}" valign="top">
                                <xsl:text>--</xsl:text>
                                <xsl:apply-templates select="attribution"/>
                            </td>
                        </tr>
                    </table>
                </xsl:when>
                <xsl:otherwise>
                    <blockquote>
                        <xsl:call-template name="common.html.attributes"/>
                        <xsl:apply-templates/>
                    </blockquote>
                </xsl:otherwise>
            </xsl:choose>
        </div>
    </xsl:template>
    <xsl:template match="blockquote/title|blockquote/info/title">
        <xsl:choose>
            <xsl:when test="$make.clean.html != 0">
                <div class="{$class.prefix}blockquote-title">
                    <xsl:apply-templates/>
                </div>
            </xsl:when>
            <xsl:otherwise>
                <div class="{$class.prefix}blockquote-title">
                    <p>
                        <strong>
                            <xsl:apply-templates/>
                        </strong>
                    </p>
                </div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="epigraph">
        <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates select="para|simpara|formalpara|literallayout"/>
            <xsl:if test="attribution">
                <div class="{$class.prefix}attribution">
                    <span>—
                        <xsl:apply-templates select="attribution"/>
                    </span>
                </div>
            </xsl:if>
        </div>
    </xsl:template>
    <xsl:template match="attribution">
        <span>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates/>
        </span>
    </xsl:template>
    <xsl:template match="sidebar">
        <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="sidebar.titlepage"/>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="abstract/title|sidebar/title">
    </xsl:template>
    <xsl:template match="sidebar/sidebarinfo|sidebar/info"/>
    <xsl:template match="abstract">
        <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="anchor"/>
            <xsl:call-template name="formal.object.heading">
                <xsl:with-param name="title">
                    <xsl:apply-templates select="." mode="title.markup">
                        <xsl:with-param name="allow-anchors" select="'1'"/>
                    </xsl:apply-templates>
                </xsl:with-param>
            </xsl:call-template>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="msgset">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="msgentry">
        <xsl:call-template name="block.object"/>
    </xsl:template>
    <xsl:template match="simplemsgentry">
        <xsl:call-template name="block.object"/>
    </xsl:template>
    <xsl:template match="msg">
        <xsl:call-template name="block.object"/>
    </xsl:template>
    <xsl:template match="msgmain">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="msgmain/title">
        <xsl:choose>
            <xsl:when test="$make.clean.html != 0">
                <span class="{$class.prefix}msgmain-title">
                    <xsl:apply-templates/>
                </span>
            </xsl:when>
            <xsl:otherwise>
                <strong>
                    <xsl:apply-templates/>
                </strong>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="msgsub">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="msgsub/title">
        <xsl:choose>
            <xsl:when test="$make.clean.html != 0">
                <span class="{$class.prefix}msgsub-title">
                    <xsl:apply-templates/>
                </span>
            </xsl:when>
            <xsl:otherwise>
                <strong>
                    <xsl:apply-templates/>
                </strong>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="msgrel">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="msgrel/title">
        <xsl:choose>
            <xsl:when test="$make.clean.html != 0">
                <span class="{$class.prefix}msgrel-title">
                    <xsl:apply-templates/>
                </span>
            </xsl:when>
            <xsl:otherwise>
                <strong>
                    <xsl:apply-templates/>
                </strong>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="msgtext">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="msginfo">
        <xsl:call-template name="block.object"/>
    </xsl:template>
    <xsl:template match="msglevel">
        <xsl:choose>
            <xsl:when test="$make.clean.html != 0">
                <div class="{$class.prefix}msglevel">
                    <span class="{$class.prefix}msglevel-title">
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="context" select="'msgset'"/>
                            <xsl:with-param name="name" select="'MsgLevel'"/>
                        </xsl:call-template>
                    </span>
                    <xsl:apply-templates/>
                </div>
            </xsl:when>
            <xsl:otherwise>
                <p>
                    <strong>
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="context" select="'msgset'"/>
                            <xsl:with-param name="name" select="'MsgLevel'"/>
                        </xsl:call-template>
                    </strong>
                    <xsl:apply-templates/>
                </p>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="msgorig">
        <xsl:choose>
            <xsl:when test="$make.clean.html != 0">
                <div class="{$class.prefix}msgorig">
                    <span class="{$class.prefix}msgorig-title">
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="context" select="'msgset'"/>
                            <xsl:with-param name="name" select="'MsgOrig'"/>
                        </xsl:call-template>
                    </span>
                    <xsl:apply-templates/>
                </div>
            </xsl:when>
            <xsl:otherwise>
                <p>
                    <strong>
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="context" select="'msgset'"/>
                            <xsl:with-param name="name" select="'MsgOrig'"/>
                        </xsl:call-template>
                    </strong>
                    <xsl:apply-templates/>
                </p>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="msgaud">
        <xsl:choose>
            <xsl:when test="$make.clean.html != 0">
                <div class="{$class.prefix}msgaud">
                    <span class="{$class.prefix}msgaud-title">
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="context" select="'msgset'"/>
                            <xsl:with-param name="name" select="'MsgAud'"/>
                        </xsl:call-template>
                    </span>
                    <xsl:apply-templates/>
                </div>
            </xsl:when>
            <xsl:otherwise>
                <p>
                    <strong>
                        <xsl:call-template name="gentext.template">
                            <xsl:with-param name="context" select="'msgset'"/>
                            <xsl:with-param name="name" select="'MsgAud'"/>
                        </xsl:call-template>
                    </strong>
                    <xsl:apply-templates/>
                </p>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="msgexplan">
        <xsl:call-template name="block.object"/>
    </xsl:template>
    <xsl:template match="msgexplan/title">
        <xsl:choose>
            <xsl:when test="$make.clean.html != 0">
                <div class="{$class.prefix}msgexplan">
                    <span class="{$class.prefix}msgexplan-title">
                        <xsl:apply-templates/>
                    </span>
                </div>
            </xsl:when>
            <xsl:otherwise>
                <p>
                    <strong>
                        <xsl:apply-templates/>
                    </strong>
                </p>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="revhistory">
        <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <table>
                <xsl:if test="$css.decoration != 0">
                    <xsl:attribute name="style">
                        <xsl:text>border-style:solid; width:100%;</xsl:text>
                    </xsl:attribute>
                </xsl:if>
                <!-- include summary attribute if not HTML5 -->
                <xsl:if test="$div.element != 'section'">
                    <xsl:attribute name="summary">
                        <xsl:call-template name="gentext">
                            <xsl:with-param name="key">revhistory</xsl:with-param>
                        </xsl:call-template>
                    </xsl:attribute>
                </xsl:if>
                <tr>
                    <th align="{$direction.align.start}" valign="top" colspan="3">
                        <strong>
                            <xsl:call-template name="gentext">
                                <xsl:with-param name="key" select="'RevHistory'"/>
                            </xsl:call-template>
                        </strong>
                    </th>
                </tr>
                <xsl:apply-templates/>
            </table>
        </div>
    </xsl:template>
    <xsl:template match="revhistory/revision">
        <xsl:variable name="revnumber" select="revnumber"/>
        <xsl:variable name="revdate" select="date"/>
        <xsl:variable name="revauthor" select="authorinitials|author"/>
        <xsl:variable name="revremark" select="revremark|revdescription"/>
        <tr>
            <td align="{$direction.align.start}">
                <xsl:if test="$revnumber">
                    <xsl:call-template name="gentext">
                        <xsl:with-param name="key" select="'Revision'"/>
                    </xsl:call-template>
                    <xsl:call-template name="gentext.space"/>
                    <xsl:apply-templates select="$revnumber"/>
                </xsl:if>
            </td>
            <td align="{$direction.align.start}">
                <xsl:apply-templates select="$revdate"/>
            </td>
            <xsl:choose>
                <xsl:when test="count($revauthor)=0">
                    <td align="{$direction.align.start}">
                        <xsl:call-template name="dingbat">
                            <xsl:with-param name="dingbat">nbsp</xsl:with-param>
                        </xsl:call-template>
                    </td>
                </xsl:when>
                <xsl:otherwise>
                    <td align="{$direction.align.start}">
                        <xsl:for-each select="$revauthor">
                            <xsl:apply-templates select="."/>
                            <xsl:if test="position() != last()">
                                <xsl:text>, </xsl:text>
                            </xsl:if>
                        </xsl:for-each>
                    </td>
                </xsl:otherwise>
            </xsl:choose>
        </tr>
        <xsl:if test="$revremark">
            <tr>
                <td align="{$direction.align.start}" colspan="3">
                    <xsl:apply-templates select="$revremark"/>
                </td>
            </tr>
        </xsl:if>
    </xsl:template>
    <xsl:template match="revision/revnumber">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="revision/date">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="revision/authorinitials">
        <xsl:text>, </xsl:text>
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="revision/authorinitials[1]" priority="2">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="revision/revremark">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="revision/revdescription">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="ackno|acknowledgements[parent::article]">
        <xsl:call-template name="block.object"/>
    </xsl:template>
    <xsl:template match="highlights">
        <xsl:call-template name="block.object"/>
    </xsl:template>
    <xsl:template match="task">
        <xsl:variable name="param.placement"
                      select="substring-after(normalize-space($formal.title.placement),                                         concat(local-name(.), ' '))"/>

        <xsl:variable name="placement">
            <xsl:choose>
                <xsl:when test="contains($param.placement, ' ')">
                    <xsl:value-of select="substring-before($param.placement, ' ')"/>
                </xsl:when>
                <xsl:when test="$param.placement = ''">before</xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$param.placement"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="preamble" select="*[not(self::title                               or self::titleabbrev)]"/>

        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>

            <xsl:if test="(title or info/title) and $placement = 'before'">
                <xsl:call-template name="formal.object.heading"/>
            </xsl:if>

            <xsl:apply-templates select="$preamble"/>

            <xsl:if test="(title or info/title) and $placement != 'before'">
                <xsl:call-template name="formal.object.heading"/>
            </xsl:if>
        </div>
    </xsl:template>
    <xsl:template match="task/title">
        <!-- nop -->
    </xsl:template>
    <xsl:template match="tasksummary">
        <xsl:call-template name="semiformal.object"/>
    </xsl:template>
    <xsl:template match="tasksummary/title"/>
    <xsl:template match="taskprerequisites">
        <xsl:call-template name="semiformal.object"/>
    </xsl:template>
    <xsl:template match="taskprerequisites/title"/>
    <xsl:template match="taskrelated">
        <xsl:call-template name="semiformal.object"/>
    </xsl:template>
    <xsl:template match="taskrelated/title"/>
    <xsl:template match="qandaset">
        <xsl:variable name="title" select="(blockinfo/title|info/title|title)[1]"/>
        <xsl:variable name="preamble"
                      select="*[local-name(.) != 'title'                                           and local-name(.) != 'titleabbrev'                                           and local-name(.) != 'qandadiv'                                           and local-name(.) != 'qandaentry']"/>
        <xsl:variable name="toc">
            <xsl:call-template name="pi.dbhtml_toc"/>
        </xsl:variable>

        <xsl:variable name="toc.params">
            <xsl:call-template name="find.path.params">
                <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
            </xsl:call-template>
        </xsl:variable>

        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:apply-templates select="$title"/>
            <xsl:if test="not($title)">
                <!-- andhor is output on title if there is one -->
                <xsl:call-template name="anchor">
                    <xsl:with-param name="conditional" select="0"/>
                </xsl:call-template>
            </xsl:if>
            <xsl:if test="((contains($toc.params, 'toc') and $toc != '0') or $toc = '1')                   and not(ancestor::answer and not($qanda.nested.in.toc=0))">
                <xsl:call-template name="process.qanda.toc"/>
            </xsl:if>
            <xsl:apply-templates select="$preamble"/>
            <xsl:call-template name="process.qandaset"/>
        </div>
    </xsl:template>
    <xsl:template
            match="qandaset/blockinfo/title|                      qandaset/info/title|                      qandaset/title">
        <xsl:variable name="qalevel">
            <xsl:call-template name="qanda.section.level"/>
        </xsl:variable>
        <xsl:element name="h{string(number($qalevel)+1)}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:call-template name="anchor">
                <xsl:with-param name="node" select=".."/>
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:apply-templates/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="qandaset/blockinfo|qandaset/info">
        <!-- what should this template really do? -->
        <xsl:apply-templates select="legalnotice" mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template
            match="qandadiv/blockinfo/title|                      qandadiv/info/title|                      qandadiv/title">
        <xsl:variable name="qalevel">
            <xsl:call-template name="qandadiv.section.level"/>
        </xsl:variable>

        <xsl:element name="h{string(number($qalevel)+1)}" namespace="http://www.w3.org/1999/xhtml">
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:call-template name="id.attribute">
                <xsl:with-param name="node" select=".."/>
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:call-template name="anchor">
                <xsl:with-param name="node" select=".."/>
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <xsl:apply-templates select="parent::qandadiv" mode="label.markup"/>
            <xsl:if test="$qandadiv.autolabel != 0">
                <xsl:apply-templates select="." mode="intralabel.punctuation"/>
                <xsl:text> </xsl:text>
            </xsl:if>
            <xsl:apply-templates/>
        </xsl:element>
    </xsl:template>
    <xsl:template match="*" mode="qanda.defaultlabel">
        <xsl:choose>
            <xsl:when test="ancestor-or-self::*[@defaultlabel]">
                <xsl:value-of
                        select="(ancestor-or-self::*[@defaultlabel])[last()]                             /@defaultlabel"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$qanda.defaultlabel"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="question" mode="qanda.label">
        <xsl:variable name="deflabel">
            <xsl:apply-templates select="." mode="qanda.defaultlabel"/>
        </xsl:variable>
        <xsl:apply-templates select="." mode="label.markup"/>
        <xsl:if test="contains($deflabel, 'number') and not(label)">
            <xsl:apply-templates select="." mode="intralabel.punctuation"/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="answer" mode="qanda.label">
        <xsl:apply-templates select="." mode="label.markup"/>
    </xsl:template>
    <xsl:template match="label">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template name="process.qanda.toc">
        <!-- * if user wants nested qandaset and qandaentry in main Qandaset TOC, -->
        <!-- * then don't also include the nested stuff in the sub TOCs -->
        <dl>
            <xsl:apply-templates select="qandadiv" mode="qandatoc.mode"/>
            <xsl:apply-templates select="qandaset|qandaentry" mode="qandatoc.mode"/>
        </dl>
    </xsl:template>
    <xsl:template match="qandadiv" mode="qandatoc.mode">
        <dt>
            <xsl:apply-templates select="title" mode="qandatoc.mode"/>
        </dt>
        <dd>
            <xsl:call-template name="process.qanda.toc"/>
        </dd>
    </xsl:template>
    <xsl:template
            match="qandadiv/blockinfo/title|                      qandadiv/info/title|                      qandadiv/title"
            mode="qandatoc.mode">
        <xsl:variable name="qalevel">
            <xsl:call-template name="qandadiv.section.level"/>
        </xsl:variable>
        <xsl:variable name="id">
            <xsl:call-template name="object.id">
                <xsl:with-param name="object" select="parent::*"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="div.label">
            <xsl:apply-templates select="parent::qandadiv" mode="label.markup"/>
        </xsl:variable>
        <xsl:if test="string-length($div.label) != 0">
            <xsl:copy-of select="$div.label"/>
            <xsl:value-of select="$autotoc.label.separator"/>
        </xsl:if>
        <xsl:text> </xsl:text>
        <a>
            <xsl:attribute name="href">
                <xsl:call-template name="href.target">
                    <xsl:with-param name="object" select="parent::*"/>
                </xsl:call-template>
            </xsl:attribute>
            <xsl:apply-templates/>
        </a>
    </xsl:template>
    <xsl:template match="qandaset" mode="qandatoc.mode">
        <xsl:for-each select="qandaentry">
            <xsl:apply-templates select="." mode="qandatoc.mode"/>
        </xsl:for-each>
    </xsl:template>
    <xsl:template match="qandaentry" mode="qandatoc.mode">
        <xsl:apply-templates select="question" mode="qandatoc.mode"/>
    </xsl:template>
    <xsl:template match="question" mode="qandatoc.mode">
        <xsl:variable name="firstch">
            <!-- Use a titleabbrev or title if available -->
            <xsl:choose>
                <xsl:when test="../blockinfo/titleabbrev">
                    <xsl:apply-templates select="../blockinfo/titleabbrev[1]/node()"/>
                </xsl:when>
                <xsl:when test="../blockinfo/title">
                    <xsl:apply-templates select="../blockinfo/title[1]/node()"/>
                </xsl:when>
                <xsl:when test="../info/titleabbrev">
                    <xsl:apply-templates select="../info/titleabbrev[1]/node()"/>
                </xsl:when>
                <xsl:when test="../titleabbrev">
                    <xsl:apply-templates select="../titleabbrev[1]/node()"/>
                </xsl:when>
                <xsl:when test="../info/title">
                    <xsl:apply-templates select="../info/title[1]/node()"/>
                </xsl:when>
                <xsl:when test="../title">
                    <xsl:apply-templates select="../title[1]/node()"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates select="(*[local-name(.)!='label'])[1]/node()"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="deflabel">
            <xsl:choose>
                <xsl:when test="ancestor-or-self::*[@defaultlabel]">
                    <xsl:value-of
                            select="(ancestor-or-self::*[@defaultlabel])[last()]                               /@defaultlabel"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$qanda.defaultlabel"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <dt>
            <xsl:apply-templates select="." mode="label.markup"/>
            <xsl:if test="contains($deflabel,'number') and not(label)">
                <xsl:apply-templates select="." mode="intralabel.punctuation"/>
            </xsl:if>
            <xsl:text> </xsl:text>
            <a>
                <xsl:attribute name="href">
                    <xsl:call-template name="href.target">
                        <xsl:with-param name="object" select=".."/>
                    </xsl:call-template>
                </xsl:attribute>
                <xsl:value-of select="$firstch"/>
            </a>
        </dt>
        <!-- * include nested qandaset/qandaentry in TOC if user wants it -->
        <xsl:if test="not($qanda.nested.in.toc = 0)">
            <xsl:apply-templates select="following-sibling::answer" mode="qandatoc.mode"/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="answer" mode="qandatoc.mode">
        <xsl:if test="descendant::question">
            <dd>
                <xsl:call-template name="process.qanda.toc"/>
            </dd>
        </xsl:if>
    </xsl:template>
    <xsl:template match="*" mode="no.wrapper.mode">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="cmdsynopsis">
        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <p>
                <xsl:call-template name="id.attribute">
                    <xsl:with-param name="conditional" select="0"/>
                </xsl:call-template>
                <xsl:if test="..//processing-instruction('dbcmdlist')">
                    <!-- * Placing a dbcmdlist PI as a child of a particular element -->
                    <!-- * creates a hyperlinked list of all cmdsynopsis instances -->
                    <!-- * that are descendants of that element; so for any -->
                    <!-- * cmdsynopsis that is a descendant of an element containing -->
                    <!-- * a dbcmdlist PI, we need to output an a@id instance so that -->
                    <!-- * we will have something to link to -->
                    <xsl:call-template name="anchor">
                        <xsl:with-param name="conditional" select="0"/>
                    </xsl:call-template>
                </xsl:if>
                <xsl:apply-templates/>
            </p>
        </div>
    </xsl:template>
    <xsl:template match="cmdsynopsis/command">
        <br/>
        <xsl:call-template name="inline.monoseq"/>
        <xsl:text> </xsl:text>
    </xsl:template>
    <xsl:template match="cmdsynopsis/command[1]" priority="2">
        <xsl:call-template name="inline.monoseq"/>
        <xsl:text> </xsl:text>
    </xsl:template>
    <xsl:template match="group|arg" name="group-or-arg">
        <xsl:variable name="choice" select="@choice"/>
        <xsl:variable name="rep" select="@rep"/>
        <xsl:variable name="sepchar">
            <xsl:choose>
                <xsl:when test="ancestor-or-self::*/@sepchar">
                    <xsl:value-of select="ancestor-or-self::*/@sepchar"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text> </xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:if test="preceding-sibling::*">
            <xsl:value-of select="$sepchar"/>
        </xsl:if>
        <xsl:choose>
            <xsl:when test="$choice='plain'">
                <xsl:value-of select="$arg.choice.plain.open.str"/>
            </xsl:when>
            <xsl:when test="$choice='req'">
                <xsl:value-of select="$arg.choice.req.open.str"/>
            </xsl:when>
            <xsl:when test="$choice='opt'">
                <xsl:value-of select="$arg.choice.opt.open.str"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$arg.choice.def.open.str"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:apply-templates/>
        <xsl:choose>
            <xsl:when test="$rep='repeat'">
                <xsl:value-of select="$arg.rep.repeat.str"/>
            </xsl:when>
            <xsl:when test="$rep='norepeat'">
                <xsl:value-of select="$arg.rep.norepeat.str"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$arg.rep.def.str"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:choose>
            <xsl:when test="$choice='plain'">
                <xsl:value-of select="$arg.choice.plain.close.str"/>
            </xsl:when>
            <xsl:when test="$choice='req'">
                <xsl:value-of select="$arg.choice.req.close.str"/>
            </xsl:when>
            <xsl:when test="$choice='opt'">
                <xsl:value-of select="$arg.choice.opt.close.str"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="$arg.choice.def.close.str"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="group/arg">
        <xsl:variable name="choice" select="@choice"/>
        <xsl:variable name="rep" select="@rep"/>
        <xsl:if test="preceding-sibling::*">
            <xsl:value-of select="$arg.or.sep"/>
        </xsl:if>
        <xsl:call-template name="group-or-arg"/>
    </xsl:template>
    <xsl:template match="sbr">
        <br/>
    </xsl:template>
    <xsl:template match="synopfragmentref">
        <xsl:variable name="target" select="key('id',@linkend)"/>
        <xsl:variable name="snum">
            <xsl:apply-templates select="$target" mode="synopfragment.number"/>
        </xsl:variable>
        <em>
            <a href="#{@linkend}">
                <xsl:text>(</xsl:text>
                <xsl:value-of select="$snum"/>
                <xsl:text>)</xsl:text>
            </a>
            <xsl:text> </xsl:text>
            <xsl:apply-templates/>
        </em>
    </xsl:template>
    <xsl:template match="synopfragment" mode="synopfragment.number">
        <xsl:number format="1"/>
    </xsl:template>
    <xsl:template match="synopfragment">
        <xsl:variable name="snum">
            <xsl:apply-templates select="." mode="synopfragment.number"/>
        </xsl:variable>
        <!-- You can't introduce another <p> here, because you're 
       already in a <p> from cmdsynopsis-->
        <span>
            <xsl:variable name="id">
                <xsl:call-template name="object.id"/>
            </xsl:variable>
            <a id="{$id}">
                <xsl:text>(</xsl:text>
                <xsl:value-of select="$snum"/>
                <xsl:text>)</xsl:text>
            </a>
            <xsl:text> </xsl:text>
            <xsl:apply-templates/>
        </span>
    </xsl:template>
    <xsl:template match="funcsynopsis">
        <xsl:if test="..//processing-instruction('dbfunclist')">
            <!-- * Placing a dbfunclist PI as a child of a particular element -->
            <!-- * creates a hyperlinked list of all funcsynopsis instances that -->
            <!-- * are descendants of that element; so for any funcsynopsis that is -->
            <!-- * a descendant of an element containing a dbfunclist PI, we need -->
            <!-- * to output an a@id instance so that we will have something to -->
            <!-- * link to -->
            <span>
                <xsl:call-template name="id.attribute">
                    <xsl:with-param name="conditional" select="0"/>
                </xsl:call-template>
            </span>
            <xsl:call-template name="anchor">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
        </xsl:if>
        <xsl:call-template name="informal.object"/>
    </xsl:template>
    <xsl:template match="funcsynopsisinfo">
        <pre>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates/>
        </pre>
    </xsl:template>
    <xsl:template match="funcprototype" mode="kr-nontabular">
        <p>
            <xsl:apply-templates mode="kr-nontabular"/>
            <xsl:if test="paramdef">
                <br/>
                <xsl:apply-templates select="paramdef" mode="kr-funcsynopsis-mode"/>
            </xsl:if>
        </p>
    </xsl:template>
    <xsl:template match="funcdef" mode="kr-nontabular">
        <code>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="kr-nontabular"/>
            <xsl:text>(</xsl:text>
        </code>
    </xsl:template>
    <xsl:template match="funcdef/function" mode="kr-nontabular">
        <xsl:choose>
            <xsl:when test="$funcsynopsis.decoration != 0">
                <strong class="{$class.prefix}fsfunc">
                    <xsl:apply-templates mode="kr-nontabular"/>
                </strong>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="kr-nontabular"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="void" mode="kr-nontabular">
        <code>)</code>
        <xsl:text>;</xsl:text>
    </xsl:template>
    <xsl:template match="varargs" mode="kr-nontabular">
        <xsl:text>...</xsl:text>
        <code>)</code>
        <xsl:text>;</xsl:text>
    </xsl:template>
    <xsl:template match="paramdef" mode="kr-nontabular">
        <xsl:apply-templates select="parameter" mode="kr-nontabular"/>
        <xsl:choose>
            <xsl:when test="following-sibling::*">
                <xsl:text>, </xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <code>)</code>
                <xsl:text>;</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="paramdef/parameter" mode="kr-nontabular">
        <xsl:choose>
            <xsl:when test="$funcsynopsis.decoration != 0">
                <var class="{$class.prefix}pdparam">
                    <xsl:apply-templates mode="kr-nontabular"/>
                </var>
            </xsl:when>
            <xsl:otherwise>
                <code>
                    <xsl:apply-templates mode="kr-nontabular"/>
                </code>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="paramdef" mode="kr-funcsynopsis-mode">
        <xsl:if test="preceding-sibling::paramdef">
            <br/>
        </xsl:if>
        <code>
            <xsl:apply-templates mode="kr-funcsynopsis-mode"/>
        </code>
        <xsl:text>;</xsl:text>
    </xsl:template>
    <xsl:template match="paramdef/parameter" mode="kr-funcsynopsis-mode">
        <xsl:choose>
            <xsl:when test="$funcsynopsis.decoration != 0">
                <var class="{$class.prefix}pdparam">
                    <xsl:apply-templates mode="kr-funcsynopsis-mode"/>
                </var>
            </xsl:when>
            <xsl:otherwise>
                <code>
                    <xsl:apply-templates mode="kr-funcsynopsis-mode"/>
                </code>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="funcparams" mode="kr-funcsynopsis-mode">
        <code>(</code>
        <xsl:apply-templates mode="kr-funcsynopsis-mode"/>
        <code>)</code>
    </xsl:template>
    <xsl:template match="funcprototype" mode="kr-tabular">
        <table border="{$table.border.off}" class="{$class.prefix}funcprototype-table">
            <xsl:if test="$div.element != 'section'">
                <xsl:attribute name="summary">Function synopsis</xsl:attribute>
            </xsl:if>
            <xsl:if test="$css.decoration != 0">
                <xsl:attribute name="style">cellspacing: 0; cellpadding: 0;</xsl:attribute>
            </xsl:if>
            <tr>
                <td>
                    <xsl:apply-templates select="funcdef" mode="kr-tabular"/>
                </td>
                <xsl:apply-templates select="(void|varargs|paramdef)[1]" mode="kr-tabular"/>
            </tr>
            <xsl:for-each select="(void|varargs|paramdef)[preceding-sibling::*[not(self::funcdef)]]">
                <tr>
                    <td></td>
                    <xsl:apply-templates select="." mode="kr-tabular"/>
                </tr>
            </xsl:for-each>
        </table>
        <xsl:if test="paramdef">
            <div class="{$class.prefix}paramdef-list">
                <xsl:apply-templates select="paramdef" mode="kr-funcsynopsis-mode"/>
            </div>
        </xsl:if>
        <div class="{$class.prefix}funcprototype-spacer"></div>
        <!-- hACk: blank div for vertical spacing -->
    </xsl:template>
    <xsl:template match="funcdef" mode="kr-tabular">
        <code>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="kr-tabular"/>
            <xsl:text>(</xsl:text>
        </code>
    </xsl:template>
    <xsl:template match="funcdef/function" mode="kr-tabular">
        <xsl:choose>
            <xsl:when test="$funcsynopsis.decoration != 0">
                <strong class="{$class.prefix}fsfunc">
                    <xsl:apply-templates mode="kr-nontabular"/>
                </strong>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="kr-tabular"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="void" mode="kr-tabular">
        <td>
            <code>)</code>
            <xsl:text>;</xsl:text>
        </td>
        <td></td>
    </xsl:template>
    <xsl:template match="varargs" mode="kr-tabular">
        <td>
            <xsl:text>...</xsl:text>
            <code>)</code>
            <xsl:text>;</xsl:text>
        </td>
        <td></td>
    </xsl:template>
    <xsl:template match="paramdef" mode="kr-tabular">
        <td>
            <xsl:apply-templates select="parameter" mode="kr-tabular"/>
            <xsl:choose>
                <xsl:when test="following-sibling::*">
                    <xsl:text>, </xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <code>)</code>
                    <xsl:text>;</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </td>
        <td></td>
    </xsl:template>
    <xsl:template match="paramdef/parameter" mode="kr-tabular">
        <xsl:choose>
            <xsl:when test="$funcsynopsis.decoration != 0">
                <var class="{$class.prefix}pdparam">
                    <xsl:apply-templates mode="kr-tabular"/>
                </var>
            </xsl:when>
            <xsl:otherwise>
                <code>
                    <xsl:apply-templates mode="kr-tabular"/>
                </code>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="paramdef" mode="kr-tabular-funcsynopsis-mode">
        <xsl:variable name="type">
            <xsl:choose>
                <xsl:when test="type">
                    <xsl:apply-templates select="type" mode="kr-tabular-funcsynopsis-mode"/>
                </xsl:when>
                <xsl:when test="normalize-space(parameter/preceding-sibling::node()[not(self::parameter)]) != ''">
                    <xsl:copy-of select="parameter/preceding-sibling::node()[not(self::parameter)]"/>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <tr>
            <xsl:choose>
                <xsl:when test="$type != '' and funcparams">
                    <td>
                        <code>
                            <xsl:copy-of select="$type"/>
                        </code>
                        <xsl:text> </xsl:text>
                    </td>
                    <td>
                        <code>
                            <xsl:choose>
                                <xsl:when test="type">
                                    <xsl:apply-templates select="type/following-sibling::*"
                                                         mode="kr-tabular-funcsynopsis-mode"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:apply-templates select="*" mode="kr-tabular-funcsynopsis-mode"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </code>
                    </td>
                </xsl:when>

                <xsl:when test="funcparams">
                    <td colspan="2">
                        <code>
                            <xsl:apply-templates mode="kr-tabular-funcsynopsis-mode"/>
                        </code>
                    </td>
                </xsl:when>

                <xsl:otherwise>
                    <td>
                        <code>
                            <xsl:apply-templates select="parameter/preceding-sibling::node()[not(self::parameter)]"
                                                 mode="kr-tabular-funcsynopsis-mode"/>
                        </code>
                        <xsl:text> </xsl:text>
                    </td>
                    <td>
                        <code>
                            <xsl:apply-templates select="parameter" mode="kr-tabular"/>
                            <xsl:apply-templates select="parameter/following-sibling::*[not(self::parameter)]"
                                                 mode="kr-tabular-funcsynopsis-mode"/>
                            <xsl:text>;</xsl:text>
                        </code>
                    </td>
                </xsl:otherwise>
            </xsl:choose>
        </tr>
    </xsl:template>
    <xsl:template match="paramdef/parameter" mode="kr-tabular-funcsynopsis-mode">
        <xsl:choose>
            <xsl:when test="$funcsynopsis.decoration != 0">
                <var class="{$class.prefix}pdparam">
                    <xsl:apply-templates mode="kr-tabular-funcsynopsis-mode"/>
                </var>
            </xsl:when>
            <xsl:otherwise>
                <code>
                    <xsl:apply-templates mode="kr-tabular-funcsynopsis-mode"/>
                </code>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="funcparams" mode="kr-tabular-funcsynopsis-mode">
        <code>(</code>
        <xsl:apply-templates mode="kr-tabular-funcsynopsis-mode"/>
        <code>)</code>
        <xsl:text>;</xsl:text>
    </xsl:template>
    <xsl:template match="funcprototype" mode="ansi-nontabular">
        <p>
            <xsl:apply-templates mode="ansi-nontabular"/>
        </p>
    </xsl:template>
    <xsl:template match="funcdef" mode="ansi-nontabular">
        <code>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="ansi-nontabular"/>
            <xsl:text>(</xsl:text>
        </code>
    </xsl:template>
    <xsl:template match="funcdef/function" mode="ansi-nontabular">
        <xsl:choose>
            <xsl:when test="$funcsynopsis.decoration != 0">
                <strong class="{$class.prefix}fsfunc">
                    <xsl:apply-templates mode="ansi-nontabular"/>
                </strong>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="ansi-nontabular"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="void" mode="ansi-nontabular">
        <code>void)</code>
        <xsl:text>;</xsl:text>
    </xsl:template>
    <xsl:template match="varargs" mode="ansi-nontabular">
        <xsl:text>...</xsl:text>
        <code>)</code>
        <xsl:text>;</xsl:text>
    </xsl:template>
    <xsl:template match="paramdef" mode="ansi-nontabular">
        <xsl:apply-templates mode="ansi-nontabular"/>
        <xsl:choose>
            <xsl:when test="following-sibling::*">
                <xsl:text>, </xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <code>)</code>
                <xsl:text>;</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="paramdef/parameter" mode="ansi-nontabular">
        <xsl:choose>
            <xsl:when test="$funcsynopsis.decoration != 0">
                <var class="{$class.prefix}pdparam">
                    <xsl:apply-templates mode="ansi-nontabular"/>
                </var>
            </xsl:when>
            <xsl:otherwise>
                <code>
                    <xsl:apply-templates mode="ansi-nontabular"/>
                </code>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="funcparams" mode="ansi-nontabular">
        <code>(</code>
        <xsl:apply-templates mode="ansi-nontabular"/>
        <code>)</code>
    </xsl:template>
    <xsl:template match="funcprototype" mode="ansi-tabular">
        <table border="{$table.border.off}" class="{$class.prefix}funcprototype-table">
            <xsl:if test="$div.element != 'section'">
                <xsl:attribute name="summary">Function synopsis</xsl:attribute>
            </xsl:if>
            <xsl:if test="$css.decoration != 0">
                <xsl:attribute name="style">cellspacing: 0; cellpadding: 0;</xsl:attribute>
            </xsl:if>
            <tr>
                <td>
                    <xsl:apply-templates select="funcdef" mode="ansi-tabular"/>
                </td>
                <xsl:apply-templates select="(void|varargs|paramdef)[1]" mode="ansi-tabular"/>
            </tr>
            <xsl:for-each select="(void|varargs|paramdef)[preceding-sibling::*[not(self::funcdef)]]">
                <tr>
                    <td></td>
                    <xsl:apply-templates select="." mode="ansi-tabular"/>
                </tr>
            </xsl:for-each>
        </table>
        <div class="{$class.prefix}funcprototype-spacer"></div>
        <!-- hACk: blank div for vertical spacing -->
    </xsl:template>
    <xsl:template match="funcdef" mode="ansi-tabular">
        <code>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="ansi-tabular"/>
            <xsl:text>(</xsl:text>
        </code>
    </xsl:template>
    <xsl:template match="funcdef/function" mode="ansi-tabular">
        <xsl:choose>
            <xsl:when test="$funcsynopsis.decoration != 0">
                <strong class="{$class.prefix}fsfunc">
                    <xsl:apply-templates mode="ansi-nontabular"/>
                </strong>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="kr-tabular"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="void" mode="ansi-tabular">
        <td>
            <code>void)</code>
            <xsl:text>;</xsl:text>
        </td>
        <td></td>
    </xsl:template>
    <xsl:template match="varargs" mode="ansi-tabular">
        <td>
            <xsl:text>...</xsl:text>
            <code>)</code>
            <xsl:text>;</xsl:text>
        </td>
        <td></td>
    </xsl:template>
    <xsl:template match="paramdef" mode="ansi-tabular">
        <td>
            <xsl:apply-templates mode="ansi-tabular"/>
            <xsl:choose>
                <xsl:when test="following-sibling::*">
                    <xsl:text>, </xsl:text>
                </xsl:when>
                <xsl:otherwise>
                    <code>)</code>
                    <xsl:text>;</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </td>
    </xsl:template>
    <xsl:template match="paramdef/parameter" mode="ansi-tabular">
        <xsl:choose>
            <xsl:when test="$funcsynopsis.decoration != 0">
                <var class="{$class.prefix}pdparam">
                    <xsl:apply-templates mode="ansi-tabular"/>
                </var>
            </xsl:when>
            <xsl:otherwise>
                <code>
                    <xsl:apply-templates mode="ansi-tabular"/>
                </code>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="funcparams" mode="ansi-tabular">
        <code>(</code>
        <xsl:apply-templates/>
        <code>)</code>
    </xsl:template>
    <xsl:variable name="default-classsynopsis-language">java</xsl:variable>
    <xsl:template
            match="classsynopsis                      |fieldsynopsis                      |methodsynopsis                      |constructorsynopsis                      |destructorsynopsis">
        <xsl:param name="language">
            <xsl:choose>
                <xsl:when test="@language">
                    <xsl:value-of select="@language"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$default-classsynopsis-language"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:param>

        <xsl:choose>
            <xsl:when test="$language='java' or $language='Java'">
                <xsl:apply-templates select="." mode="java"/>
            </xsl:when>
            <xsl:when test="$language='perl' or $language='Perl'">
                <xsl:apply-templates select="." mode="perl"/>
            </xsl:when>
            <xsl:when test="$language='idl' or $language='IDL'">
                <xsl:apply-templates select="." mode="idl"/>
            </xsl:when>
            <xsl:when test="$language='cpp' or $language='c++' or $language='C++'">
                <xsl:apply-templates select="." mode="cpp"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message>
                    <xsl:text>Unrecognized language on </xsl:text>
                    <xsl:value-of select="local-name(.)"/>
                    <xsl:text>: </xsl:text>
                    <xsl:value-of select="$language"/>
                </xsl:message>
                <xsl:apply-templates select=".">
                    <xsl:with-param name="language" select="$default-classsynopsis-language"/>
                </xsl:apply-templates>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="synop-break">
        <xsl:if test="parent::classsynopsis                 or (following-sibling::fieldsynopsis                     |following-sibling::methodsynopsis                     |following-sibling::constructorsynopsis                     |following-sibling::destructorsynopsis)">
            <br/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="classsynopsis" mode="java">
        <pre>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates select="ooclass[1]" mode="java"/>
            <xsl:if test="ooclass[preceding-sibling::*]">
                <xsl:text> extends</xsl:text>
                <xsl:apply-templates select="ooclass[preceding-sibling::*]" mode="java"/>
                <xsl:if test="oointerface|ooexception">
                    <br/>
                    <xsl:text>    </xsl:text>
                </xsl:if>
            </xsl:if>
            <xsl:if test="oointerface">
                <xsl:text>implements</xsl:text>
                <xsl:apply-templates select="oointerface" mode="java"/>
                <xsl:if test="ooexception">
                    <br/>
                    <xsl:text>    </xsl:text>
                </xsl:if>
            </xsl:if>
            <xsl:if test="ooexception">
                <xsl:text>throws</xsl:text>
                <xsl:apply-templates select="ooexception" mode="java"/>
            </xsl:if>
            <xsl:text> {</xsl:text>
            <br/>
            <xsl:apply-templates
                    select="constructorsynopsis                                  |destructorsynopsis                                  |fieldsynopsis                                  |methodsynopsis                                  |classsynopsisinfo"
                    mode="java"/>
            <xsl:text>}</xsl:text>
        </pre>
    </xsl:template>
    <xsl:template match="classsynopsisinfo" mode="java">
        <xsl:apply-templates mode="java"/>
    </xsl:template>
    <xsl:template match="ooclass|oointerface|ooexception" mode="java">
        <xsl:choose>
            <xsl:when test="preceding-sibling::*">
                <xsl:text>, </xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text> </xsl:text>
            </xsl:otherwise>
        </xsl:choose>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="java"/>
        </span>
    </xsl:template>
    <xsl:template match="modifier|package" mode="java">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="java"/>
            <xsl:if test="following-sibling::*">
                <xsl:text> </xsl:text>
            </xsl:if>
        </span>
    </xsl:template>
    <xsl:template match="classname" mode="java">
        <xsl:if test="local-name(preceding-sibling::*[1]) = 'classname'">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="java"/>
        </span>
    </xsl:template>
    <xsl:template match="interfacename" mode="java">
        <xsl:if test="local-name(preceding-sibling::*[1]) = 'interfacename'">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="java"/>
        </span>
    </xsl:template>
    <xsl:template match="exceptionname" mode="java">
        <xsl:if test="local-name(preceding-sibling::*[1]) = 'exceptionname'">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="java"/>
        </span>
    </xsl:template>
    <xsl:template match="fieldsynopsis" mode="java">
        <code>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:if test="parent::classsynopsis">
                <xsl:text>  </xsl:text>
            </xsl:if>
            <xsl:apply-templates mode="java"/>
            <xsl:text>;</xsl:text>
        </code>
        <xsl:call-template name="synop-break"/>
    </xsl:template>
    <xsl:template match="type" mode="java">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="java"/>
            <xsl:text> </xsl:text>
        </span>
    </xsl:template>
    <xsl:template match="varname" mode="java">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="java"/>
            <xsl:text> </xsl:text>
        </span>
    </xsl:template>
    <xsl:template match="initializer" mode="java">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:text>= </xsl:text>
            <xsl:apply-templates mode="java"/>
        </span>
    </xsl:template>
    <xsl:template match="void" mode="java">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:text>void </xsl:text>
        </span>
    </xsl:template>
    <xsl:template match="methodname" mode="java">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="java"/>
        </span>
    </xsl:template>
    <xsl:template match="methodparam" mode="java">
        <xsl:param name="indent">0</xsl:param>
        <xsl:if test="preceding-sibling::methodparam">
            <xsl:text>,</xsl:text>
            <br/>
            <xsl:if test="$indent &gt; 0">
                <xsl:call-template name="copy-string">
                    <xsl:with-param name="string"></xsl:with-param>
                    <xsl:with-param name="count" select="$indent + 1"/>
                </xsl:call-template>
            </xsl:if>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="java"/>
        </span>
    </xsl:template>
    <xsl:template match="parameter" mode="java">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="java"/>
        </span>
    </xsl:template>
    <xsl:template mode="java" match="constructorsynopsis|destructorsynopsis|methodsynopsis">
        <xsl:variable name="start-modifiers" select="modifier[following-sibling::*[local-name(.) != 'modifier']]"/>
        <xsl:variable name="notmod" select="*[local-name(.) != 'modifier']"/>
        <xsl:variable name="end-modifiers" select="modifier[preceding-sibling::*[local-name(.) != 'modifier']]"/>
        <xsl:variable name="decl">
            <xsl:if test="parent::classsynopsis">
                <xsl:text>  </xsl:text>
            </xsl:if>
            <xsl:apply-templates select="$start-modifiers" mode="java"/>

            <!-- type -->
            <xsl:if test="local-name($notmod[1]) != 'methodname'">
                <xsl:apply-templates select="$notmod[1]" mode="java"/>
            </xsl:if>

            <xsl:apply-templates select="methodname" mode="java"/>
        </xsl:variable>

        <code>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:copy-of select="$decl"/>
            <xsl:text>(</xsl:text>
            <xsl:apply-templates select="methodparam" mode="java">
                <xsl:with-param name="indent" select="string-length($decl)"/>
            </xsl:apply-templates>
            <xsl:text>)</xsl:text>
            <xsl:if test="exceptionname">
                <br/>
                <xsl:text>    throws </xsl:text>
                <xsl:apply-templates select="exceptionname" mode="java"/>
            </xsl:if>
            <xsl:if test="modifier[preceding-sibling::*[local-name(.) != 'modifier']]">
                <xsl:text> </xsl:text>
                <xsl:apply-templates select="$end-modifiers" mode="java"/>
            </xsl:if>
            <xsl:text>;</xsl:text>
        </code>
        <xsl:call-template name="synop-break"/>
    </xsl:template>
    <xsl:template match="classsynopsis" mode="cpp">
        <pre>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates select="ooclass[1]" mode="cpp"/>
            <xsl:if test="ooclass[preceding-sibling::*]">
                <xsl:text>: </xsl:text>
                <xsl:apply-templates select="ooclass[preceding-sibling::*]" mode="cpp"/>
                <xsl:if test="oointerface|ooexception">
                    <br/>
                    <xsl:text>    </xsl:text>
                </xsl:if>
            </xsl:if>
            <xsl:if test="oointerface">
                <xsl:text> implements</xsl:text>
                <xsl:apply-templates select="oointerface" mode="cpp"/>
                <xsl:if test="ooexception">
                    <br/>
                    <xsl:text>    </xsl:text>
                </xsl:if>
            </xsl:if>
            <xsl:if test="ooexception">
                <xsl:text> throws</xsl:text>
                <xsl:apply-templates select="ooexception" mode="cpp"/>
            </xsl:if>
            <xsl:text> {</xsl:text>
            <br/>
            <xsl:apply-templates
                    select="constructorsynopsis                                  |destructorsynopsis                                  |fieldsynopsis                                  |methodsynopsis                                  |classsynopsisinfo"
                    mode="cpp"/>
            <xsl:text>}</xsl:text>
        </pre>
    </xsl:template>
    <xsl:template match="classsynopsisinfo" mode="cpp">
        <xsl:apply-templates mode="cpp"/>
    </xsl:template>
    <xsl:template match="ooclass|oointerface|ooexception" mode="cpp">
        <xsl:if test="preceding-sibling::*">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="cpp"/>
        </span>
    </xsl:template>
    <xsl:template match="modifier|package" mode="cpp">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="cpp"/>
            <xsl:if test="following-sibling::*">
                <xsl:text> </xsl:text>
            </xsl:if>
        </span>
    </xsl:template>
    <xsl:template match="classname" mode="cpp">
        <xsl:if test="local-name(preceding-sibling::*[1]) = 'classname'">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="cpp"/>
        </span>
    </xsl:template>
    <xsl:template match="interfacename" mode="cpp">
        <xsl:if test="local-name(preceding-sibling::*[1]) = 'interfacename'">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="cpp"/>
        </span>
    </xsl:template>
    <xsl:template match="exceptionname" mode="cpp">
        <xsl:if test="local-name(preceding-sibling::*[1]) = 'exceptionname'">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="cpp"/>
        </span>
    </xsl:template>
    <xsl:template match="fieldsynopsis" mode="cpp">
        <code>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:if test="parent::classsynopsis">
                <xsl:text>  </xsl:text>
            </xsl:if>
            <xsl:apply-templates mode="cpp"/>
            <xsl:text>;</xsl:text>
        </code>
        <xsl:call-template name="synop-break"/>
    </xsl:template>
    <xsl:template match="type" mode="cpp">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="cpp"/>
            <xsl:text> </xsl:text>
        </span>
    </xsl:template>
    <xsl:template match="varname" mode="cpp">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="cpp"/>
            <xsl:text> </xsl:text>
        </span>
    </xsl:template>
    <xsl:template match="initializer" mode="cpp">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:text>= </xsl:text>
            <xsl:apply-templates mode="cpp"/>
        </span>
    </xsl:template>
    <xsl:template match="void" mode="cpp">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:text>void </xsl:text>
        </span>
    </xsl:template>
    <xsl:template match="methodname" mode="cpp">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="cpp"/>
        </span>
    </xsl:template>
    <xsl:template match="methodparam" mode="cpp">
        <xsl:if test="preceding-sibling::methodparam">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="cpp"/>
        </span>
    </xsl:template>
    <xsl:template match="parameter" mode="cpp">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="cpp"/>
        </span>
    </xsl:template>
    <xsl:template mode="cpp" match="constructorsynopsis|destructorsynopsis|methodsynopsis">
        <xsl:variable name="start-modifiers" select="modifier[following-sibling::*[local-name(.) != 'modifier']]"/>
        <xsl:variable name="notmod" select="*[local-name(.) != 'modifier']"/>
        <xsl:variable name="end-modifiers" select="modifier[preceding-sibling::*[local-name(.) != 'modifier']]"/>

        <code>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:if test="parent::classsynopsis">
                <xsl:text>  </xsl:text>
            </xsl:if>
            <xsl:apply-templates select="$start-modifiers" mode="cpp"/>

            <!-- type -->
            <xsl:if test="local-name($notmod[1]) != 'methodname'">
                <xsl:apply-templates select="$notmod[1]" mode="cpp"/>
            </xsl:if>

            <xsl:apply-templates select="methodname" mode="cpp"/>
            <xsl:text>(</xsl:text>
            <xsl:apply-templates select="methodparam" mode="cpp"/>
            <xsl:text>)</xsl:text>
            <xsl:if test="exceptionname">
                <br/>
                <xsl:text>    throws </xsl:text>
                <xsl:apply-templates select="exceptionname" mode="cpp"/>
            </xsl:if>
            <xsl:if test="modifier[preceding-sibling::*[local-name(.) != 'modifier']]">
                <xsl:text> </xsl:text>
                <xsl:apply-templates select="$end-modifiers" mode="cpp"/>
            </xsl:if>
            <xsl:text>;</xsl:text>
        </code>
        <xsl:call-template name="synop-break"/>
    </xsl:template>
    <xsl:template match="classsynopsis" mode="idl">
        <pre>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:text>interface </xsl:text>
            <xsl:apply-templates select="ooclass[1]" mode="idl"/>
            <xsl:if test="ooclass[preceding-sibling::*]">
                <xsl:text>: </xsl:text>
                <xsl:apply-templates select="ooclass[preceding-sibling::*]" mode="idl"/>
                <xsl:if test="oointerface|ooexception">
                    <br/>
                    <xsl:text>    </xsl:text>
                </xsl:if>
            </xsl:if>
            <xsl:if test="oointerface">
                <xsl:text> implements</xsl:text>
                <xsl:apply-templates select="oointerface" mode="idl"/>
                <xsl:if test="ooexception">
                    <br/>
                    <xsl:text>    </xsl:text>
                </xsl:if>
            </xsl:if>
            <xsl:if test="ooexception">
                <xsl:text> throws</xsl:text>
                <xsl:apply-templates select="ooexception" mode="idl"/>
            </xsl:if>
            <xsl:text> {</xsl:text>
            <br/>
            <xsl:apply-templates
                    select="constructorsynopsis                                  |destructorsynopsis                                  |fieldsynopsis                                  |methodsynopsis                                  |classsynopsisinfo"
                    mode="idl"/>
            <xsl:text>}</xsl:text>
        </pre>
    </xsl:template>
    <xsl:template match="classsynopsisinfo" mode="idl">
        <xsl:apply-templates mode="idl"/>
    </xsl:template>
    <xsl:template match="ooclass|oointerface|ooexception" mode="idl">
        <xsl:if test="preceding-sibling::*">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="idl"/>
        </span>
    </xsl:template>
    <xsl:template match="modifier|package" mode="idl">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="idl"/>
            <xsl:if test="following-sibling::*">
                <xsl:text> </xsl:text>
            </xsl:if>
        </span>
    </xsl:template>
    <xsl:template match="classname" mode="idl">
        <xsl:if test="local-name(preceding-sibling::*[1]) = 'classname'">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="idl"/>
        </span>
    </xsl:template>
    <xsl:template match="interfacename" mode="idl">
        <xsl:if test="local-name(preceding-sibling::*[1]) = 'interfacename'">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="idl"/>
        </span>
    </xsl:template>
    <xsl:template match="exceptionname" mode="idl">
        <xsl:if test="local-name(preceding-sibling::*[1]) = 'exceptionname'">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="idl"/>
        </span>
    </xsl:template>
    <xsl:template match="fieldsynopsis" mode="idl">
        <code>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:if test="parent::classsynopsis">
                <xsl:text>  </xsl:text>
            </xsl:if>
            <xsl:apply-templates mode="idl"/>
            <xsl:text>;</xsl:text>
        </code>
        <xsl:call-template name="synop-break"/>
    </xsl:template>
    <xsl:template match="type" mode="idl">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="idl"/>
            <xsl:text> </xsl:text>
        </span>
    </xsl:template>
    <xsl:template match="varname" mode="idl">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="idl"/>
            <xsl:text> </xsl:text>
        </span>
    </xsl:template>
    <xsl:template match="initializer" mode="idl">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:text>= </xsl:text>
            <xsl:apply-templates mode="idl"/>
        </span>
    </xsl:template>
    <xsl:template match="void" mode="idl">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:text>void </xsl:text>
        </span>
    </xsl:template>
    <xsl:template match="methodname" mode="idl">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="idl"/>
        </span>
    </xsl:template>
    <xsl:template match="methodparam" mode="idl">
        <xsl:if test="preceding-sibling::methodparam">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="idl"/>
        </span>
    </xsl:template>
    <xsl:template match="parameter" mode="idl">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="idl"/>
        </span>
    </xsl:template>
    <xsl:template mode="idl" match="constructorsynopsis|destructorsynopsis|methodsynopsis">
        <xsl:variable name="start-modifiers" select="modifier[following-sibling::*[local-name(.) != 'modifier']]"/>
        <xsl:variable name="notmod" select="*[local-name(.) != 'modifier']"/>
        <xsl:variable name="end-modifiers" select="modifier[preceding-sibling::*[local-name(.) != 'modifier']]"/>
        <code>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:if test="parent::classsynopsis">
                <xsl:text>  </xsl:text>
            </xsl:if>
            <xsl:apply-templates select="$start-modifiers" mode="idl"/>

            <!-- type -->
            <xsl:if test="local-name($notmod[1]) != 'methodname'">
                <xsl:apply-templates select="$notmod[1]" mode="idl"/>
            </xsl:if>

            <xsl:apply-templates select="methodname" mode="idl"/>
            <xsl:text>(</xsl:text>
            <xsl:apply-templates select="methodparam" mode="idl"/>
            <xsl:text>)</xsl:text>
            <xsl:if test="exceptionname">
                <br/>
                <xsl:text>    raises(</xsl:text>
                <xsl:apply-templates select="exceptionname" mode="idl"/>
                <xsl:text>)</xsl:text>
            </xsl:if>
            <xsl:if test="modifier[preceding-sibling::*[local-name(.) != 'modifier']]">
                <xsl:text> </xsl:text>
                <xsl:apply-templates select="$end-modifiers" mode="idl"/>
            </xsl:if>
            <xsl:text>;</xsl:text>
        </code>
        <xsl:call-template name="synop-break"/>
    </xsl:template>
    <xsl:template match="classsynopsis" mode="perl">
        <pre>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:text>package </xsl:text>
            <xsl:apply-templates select="ooclass[1]" mode="perl"/>
            <xsl:text>;</xsl:text>
            <br/>

            <xsl:if test="ooclass[preceding-sibling::*]">
                <xsl:text>@ISA = (</xsl:text>
                <xsl:apply-templates select="ooclass[preceding-sibling::*]" mode="perl"/>
                <xsl:text>);</xsl:text>
                <br/>
            </xsl:if>

            <xsl:apply-templates
                    select="constructorsynopsis                                  |destructorsynopsis                                  |fieldsynopsis                                  |methodsynopsis                                  |classsynopsisinfo"
                    mode="perl"/>
        </pre>
    </xsl:template>
    <xsl:template match="classsynopsisinfo" mode="perl">
        <xsl:apply-templates mode="perl"/>
    </xsl:template>
    <xsl:template match="ooclass|oointerface|ooexception" mode="perl">
        <xsl:if test="preceding-sibling::*">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="perl"/>
        </span>
    </xsl:template>
    <xsl:template match="modifier|package" mode="perl">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="perl"/>
            <xsl:if test="following-sibling::*">
                <xsl:text> </xsl:text>
            </xsl:if>
        </span>
    </xsl:template>
    <xsl:template match="classname" mode="perl">
        <xsl:if test="local-name(preceding-sibling::*[1]) = 'classname'">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="perl"/>
        </span>
    </xsl:template>
    <xsl:template match="interfacename" mode="perl">
        <xsl:if test="local-name(preceding-sibling::*[1]) = 'interfacename'">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="perl"/>
        </span>
    </xsl:template>
    <xsl:template match="exceptionname" mode="perl">
        <xsl:if test="local-name(preceding-sibling::*[1]) = 'exceptionname'">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="perl"/>
        </span>
    </xsl:template>
    <xsl:template match="fieldsynopsis" mode="perl">
        <code>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:if test="parent::classsynopsis">
                <xsl:text>  </xsl:text>
            </xsl:if>
            <xsl:apply-templates mode="perl"/>
            <xsl:text>;</xsl:text>
        </code>
        <xsl:call-template name="synop-break"/>
    </xsl:template>
    <xsl:template match="type" mode="perl">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="perl"/>
            <xsl:text> </xsl:text>
        </span>
    </xsl:template>
    <xsl:template match="varname" mode="perl">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="perl"/>
            <xsl:text> </xsl:text>
        </span>
    </xsl:template>
    <xsl:template match="initializer" mode="perl">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:text>= </xsl:text>
            <xsl:apply-templates mode="perl"/>
        </span>
    </xsl:template>
    <xsl:template match="void" mode="perl">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:text>void </xsl:text>
        </span>
    </xsl:template>
    <xsl:template match="methodname" mode="perl">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="perl"/>
        </span>
    </xsl:template>
    <xsl:template match="methodparam" mode="perl">
        <xsl:if test="preceding-sibling::methodparam">
            <xsl:text>, </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="perl"/>
        </span>
    </xsl:template>
    <xsl:template match="parameter" mode="perl">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="perl"/>
        </span>
    </xsl:template>
    <xsl:template mode="perl" match="constructorsynopsis|destructorsynopsis|methodsynopsis">
        <xsl:variable name="start-modifiers" select="modifier[following-sibling::*[local-name(.) != 'modifier']]"/>
        <xsl:variable name="notmod" select="*[local-name(.) != 'modifier']"/>
        <xsl:variable name="end-modifiers" select="modifier[preceding-sibling::*[local-name(.) != 'modifier']]"/>

        <code>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:text>sub </xsl:text>

            <xsl:apply-templates select="methodname" mode="perl"/>
            <xsl:text> { ... };</xsl:text>
        </code>
        <xsl:call-template name="synop-break"/>
    </xsl:template>
    <xsl:template match="ooclass|oointerface|ooexception">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="link|olink|xref" mode="java">
        <xsl:apply-templates select="."/>
    </xsl:template>
    <xsl:template match="link|olink|xref" mode="cpp">
        <xsl:apply-templates select="."/>
    </xsl:template>
    <xsl:template match="link|olink|xref" mode="idl">
        <xsl:apply-templates select="."/>
    </xsl:template>
    <xsl:template match="link|olink|xref" mode="perl">
        <xsl:apply-templates select="."/>
    </xsl:template>
    <xsl:template match="link|olink|xref" mode="ansi-nontabular">
        <xsl:apply-templates select="."/>
    </xsl:template>
    <xsl:template match="link|olink|xref" mode="ansi-tabular">
        <xsl:apply-templates select="."/>
    </xsl:template>
    <xsl:template match="link|olink|xref" mode="kr-nontabular">
        <xsl:apply-templates select="."/>
    </xsl:template>
    <xsl:template match="link|olink|xref" mode="kr-tabular">
        <xsl:apply-templates select="."/>
    </xsl:template>
    <xsl:attribute-set name="book.titlepage.recto.style"/>
    <xsl:attribute-set name="book.titlepage.verso.style"/>
    <xsl:attribute-set name="article.titlepage.recto.style"/>
    <xsl:attribute-set name="article.titlepage.verso.style"/>
    <xsl:attribute-set name="set.titlepage.recto.style"/>
    <xsl:attribute-set name="set.titlepage.verso.style"/>
    <xsl:attribute-set name="part.titlepage.recto.style"/>
    <xsl:attribute-set name="part.titlepage.verso.style"/>
    <xsl:attribute-set name="partintro.titlepage.recto.style"/>
    <xsl:attribute-set name="partintro.titlepage.verso.style"/>
    <xsl:attribute-set name="reference.titlepage.recto.style"/>
    <xsl:attribute-set name="reference.titlepage.verso.style"/>
    <xsl:attribute-set name="refentry.titlepage.recto.style"/>
    <xsl:attribute-set name="refentry.titlepage.verso.style"/>
    <xsl:attribute-set name="dedication.titlepage.recto.style"/>
    <xsl:attribute-set name="dedication.titlepage.verso.style"/>
    <xsl:attribute-set name="acknowledgements.titlepage.recto.style"/>
    <xsl:attribute-set name="acknowledgements.titlepage.verso.style"/>
    <xsl:attribute-set name="preface.titlepage.recto.style"/>
    <xsl:attribute-set name="preface.titlepage.verso.style"/>
    <xsl:attribute-set name="chapter.titlepage.recto.style"/>
    <xsl:attribute-set name="chapter.titlepage.verso.style"/>
    <xsl:attribute-set name="appendix.titlepage.recto.style"/>
    <xsl:attribute-set name="appendix.titlepage.verso.style"/>
    <xsl:attribute-set name="bibliography.titlepage.recto.style"/>
    <xsl:attribute-set name="bibliography.titlepage.verso.style"/>
    <xsl:attribute-set name="glossary.titlepage.recto.style"/>
    <xsl:attribute-set name="glossary.titlepage.verso.style"/>
    <xsl:attribute-set name="index.titlepage.recto.style"/>
    <xsl:attribute-set name="index.titlepage.verso.style"/>
    <xsl:attribute-set name="setindex.titlepage.recto.style"/>
    <xsl:attribute-set name="setindex.titlepage.verso.style"/>
    <xsl:attribute-set name="sidebar.titlepage.recto.style"/>
    <xsl:attribute-set name="sidebar.titlepage.verso.style"/>
    <xsl:attribute-set name="topic.titlepage.recto.style"/>
    <xsl:attribute-set name="topic.titlepage.verso.style"/>
    <xsl:attribute-set name="section.titlepage.recto.style"/>
    <xsl:attribute-set name="section.titlepage.verso.style"/>
    <xsl:attribute-set name="sect1.titlepage.recto.style" use-attribute-sets="section.titlepage.recto.style"/>
    <xsl:attribute-set name="sect1.titlepage.verso.style" use-attribute-sets="section.titlepage.verso.style"/>
    <xsl:attribute-set name="sect2.titlepage.recto.style" use-attribute-sets="section.titlepage.recto.style"/>
    <xsl:attribute-set name="sect2.titlepage.verso.style" use-attribute-sets="section.titlepage.verso.style"/>
    <xsl:attribute-set name="sect3.titlepage.recto.style" use-attribute-sets="section.titlepage.recto.style"/>
    <xsl:attribute-set name="sect3.titlepage.verso.style" use-attribute-sets="section.titlepage.verso.style"/>
    <xsl:attribute-set name="sect4.titlepage.recto.style" use-attribute-sets="section.titlepage.recto.style"/>
    <xsl:attribute-set name="sect4.titlepage.verso.style" use-attribute-sets="section.titlepage.verso.style"/>
    <xsl:attribute-set name="sect5.titlepage.recto.style" use-attribute-sets="section.titlepage.recto.style"/>
    <xsl:attribute-set name="sect5.titlepage.verso.style" use-attribute-sets="section.titlepage.verso.style"/>
    <xsl:attribute-set name="simplesect.titlepage.recto.style" use-attribute-sets="section.titlepage.recto.style"/>
    <xsl:attribute-set name="simplesect.titlepage.verso.style" use-attribute-sets="section.titlepage.verso.style"/>
    <xsl:attribute-set name="table.of.contents.titlepage.recto.style"/>
    <xsl:attribute-set name="table.of.contents.titlepage.verso.style"/>
    <xsl:attribute-set name="list.of.tables.titlepage.recto.style"/>
    <xsl:attribute-set name="list.of.tables.contents.titlepage.verso.style"/>
    <xsl:attribute-set name="list.of.figures.titlepage.recto.style"/>
    <xsl:attribute-set name="list.of.figures.contents.titlepage.verso.style"/>
    <xsl:attribute-set name="list.of.equations.titlepage.recto.style"/>
    <xsl:attribute-set name="list.of.equations.contents.titlepage.verso.style"/>
    <xsl:attribute-set name="list.of.examples.titlepage.recto.style"/>
    <xsl:attribute-set name="list.of.examples.contents.titlepage.verso.style"/>
    <xsl:attribute-set name="list.of.unknowns.titlepage.recto.style"/>
    <xsl:attribute-set name="list.of.unknowns.contents.titlepage.verso.style"/>
    <xsl:template match="*" mode="titlepage.mode">
        <!-- if an element isn't found in this mode, try the default mode -->
        <xsl:apply-templates select="."/>
    </xsl:template>
    <xsl:template match="abbrev" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="abstract" mode="titlepage.mode">
        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:if test="$abstract.notitle.enabled = 0">
                <xsl:call-template name="formal.object.heading">
                    <xsl:with-param name="title">
                        <xsl:apply-templates select="." mode="title.markup"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:if>
            <xsl:apply-templates mode="titlepage.mode"/>
            <xsl:call-template name="process.footnotes"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract/title" mode="titlepage.mode">
    </xsl:template>
    <xsl:template match="address" mode="titlepage.mode">
        <xsl:param name="suppress-numbers" select="'0'"/>

        <xsl:variable name="rtf">
            <xsl:apply-templates mode="titlepage.mode"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when
                    test="$suppress-numbers = '0'                     and @linenumbering = 'numbered'                     and $use.extensions != '0'                     and $linenumbering.extension != '0'">
                <div>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:call-template name="paragraph">
                        <xsl:with-param name="content">
                            <xsl:call-template name="number.rtf.lines">
                                <xsl:with-param name="rtf" select="$rtf"/>
                            </xsl:call-template>
                        </xsl:with-param>
                    </xsl:call-template>
                </div>
            </xsl:when>

            <xsl:otherwise>
                <div>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:call-template name="paragraph">
                        <xsl:with-param name="content">
                            <xsl:call-template name="make-verbatim">
                                <xsl:with-param name="rtf" select="$rtf"/>
                            </xsl:call-template>
                        </xsl:with-param>
                    </xsl:call-template>
                </div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="affiliation" mode="titlepage.mode">
        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="artpagenums" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="author|editor" mode="titlepage.mode">
        <xsl:call-template name="credits.div"/>
    </xsl:template>
    <xsl:template name="credits.div">
        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:if test="self::editor[position()=1] and not($editedby.enabled = 0)">
                <h4 class="{$class.prefix}editedby">
                    <xsl:call-template name="gentext.edited.by"/>
                </h4>
            </xsl:if>
            <h3>
                <xsl:apply-templates select="." mode="common.html.attributes"/>
                <xsl:choose>
                    <xsl:when test="orgname">
                        <xsl:apply-templates/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="person.name"/>
                    </xsl:otherwise>
                </xsl:choose>
            </h3>
            <xsl:if test="not($contrib.inline.enabled = 0)">
                <xsl:apply-templates mode="titlepage.mode" select="contrib"/>
            </xsl:if>
            <xsl:apply-templates mode="titlepage.mode" select="affiliation"/>
            <xsl:apply-templates mode="titlepage.mode" select="email"/>
            <xsl:if test="not($blurb.on.titlepage.enabled = 0)">
                <xsl:choose>
                    <xsl:when test="$contrib.inline.enabled = 0">
                        <xsl:apply-templates mode="titlepage.mode" select="contrib|authorblurb|personblurb"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates mode="titlepage.mode" select="authorblurb|personblurb"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:if>
        </div>
    </xsl:template>
    <xsl:template match="authorblurb|personblurb" mode="titlepage.mode">
        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="titlepage.mode">
        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:if test="parent::refentryinfo">
                <h2>Authors</h2>
            </xsl:if>

            <xsl:call-template name="anchor"/>
            <xsl:apply-templates mode="titlepage.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorinitials" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="bibliomisc" mode="titlepage.mode">
        <xsl:apply-templates mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="bibliomset" mode="titlepage.mode">
        <xsl:apply-templates mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="collabname" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
        </span>
    </xsl:template>
    <xsl:template match="confgroup" mode="titlepage.mode">
        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="confdates" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="confsponsor" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="conftitle" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="confnum" mode="titlepage.mode">
        <!-- suppress -->
    </xsl:template>
    <xsl:template match="contractnum" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="contractsponsor" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="contrib" mode="titlepage.mode">
        <xsl:choose>
            <xsl:when test="not($contrib.inline.enabled = 0)">
                <span>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:call-template name="id.attribute"/>
                    <xsl:apply-templates mode="titlepage.mode"/>
                </span>
                <xsl:text> </xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <div>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:call-template name="id.attribute"/>
                    <p>
                        <xsl:apply-templates mode="titlepage.mode"/>
                    </p>
                </div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="copyright" mode="titlepage.mode">

        <xsl:if test="generate-id() = generate-id(//refentryinfo/copyright[1])       and ($stylesheet.result.type = 'html' or $stylesheet.result.type = 'xhtml')">
            <h2>Copyright</h2>
        </xsl:if>

        <p>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="gentext">
                <xsl:with-param name="key" select="'Copyright'"/>
            </xsl:call-template>
            <xsl:call-template name="gentext.space"/>
            <xsl:call-template name="dingbat">
                <xsl:with-param name="dingbat">copyright</xsl:with-param>
            </xsl:call-template>
            <xsl:call-template name="gentext.space"/>
            <xsl:call-template name="copyright.years">
                <xsl:with-param name="years" select="year"/>
                <xsl:with-param name="print.ranges" select="$make.year.ranges"/>
                <xsl:with-param name="single.year.ranges" select="$make.single.year.ranges"/>
            </xsl:call-template>
            <xsl:call-template name="gentext.space"/>
            <xsl:apply-templates select="holder" mode="titlepage.mode"/>
        </p>
    </xsl:template>
    <xsl:template match="year" mode="titlepage.mode">
        <xsl:choose>
            <xsl:when test="$show.revisionflag != 0 and @revisionflag">
                <span class="{$class.prefix}{@revisionflag}">
                    <xsl:apply-templates mode="titlepage.mode"/>
                </span>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="titlepage.mode"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="holder" mode="titlepage.mode">
        <xsl:choose>
            <xsl:when test="$show.revisionflag != 0 and @revisionflag">
                <span class="{$class.prefix}{@revisionflag}">
                    <xsl:apply-templates mode="titlepage.mode"/>
                </span>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates mode="titlepage.mode"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:if test="position() &lt; last()">
            <xsl:text>, </xsl:text>
        </xsl:if>
    </xsl:template>
    <xsl:template match="corpauthor" mode="titlepage.mode">
        <h3>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
        </h3>
    </xsl:template>
    <xsl:template match="corpcredit" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="corpname" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="date" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="edition" mode="titlepage.mode">
        <p>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <xsl:call-template name="gentext.space"/>
            <xsl:call-template name="gentext">
                <xsl:with-param name="key" select="'Edition'"/>
            </xsl:call-template>
        </p>
    </xsl:template>
    <xsl:template match="email" mode="titlepage.mode">
        <!-- use the normal e-mail handling code -->
        <xsl:apply-templates select="."/>
    </xsl:template>
    <xsl:template match="firstname" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="graphic" mode="titlepage.mode">
        <!-- use the normal graphic handling code -->
        <xsl:apply-templates select="."/>
    </xsl:template>
    <xsl:template match="honorific" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="isbn" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="issn" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="biblioid" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="itermset" mode="titlepage.mode">
    </xsl:template>
    <xsl:template match="invpartnumber" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="issuenum" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="jobtitle" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="keywordset" mode="titlepage.mode">
    </xsl:template>
    <xsl:template match="legalnotice" mode="titlepage.mode">
        <xsl:variable name="id">
            <xsl:call-template name="object.id"/>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$generate.legalnotice.link != 0">

                <!-- Compute name of legalnotice file -->
                <xsl:variable name="file">
                    <xsl:call-template name="ln.or.rh.filename"/>
                </xsl:variable>

                <xsl:variable name="filename">
                    <xsl:call-template name="make-relative-filename">
                        <xsl:with-param name="base.dir" select="$chunk.base.dir"/>
                        <xsl:with-param name="base.name" select="$file"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="title">
                    <xsl:apply-templates select="." mode="title.markup"/>
                </xsl:variable>

                <a href="{$file}">
                    <xsl:copy-of select="$title"/>
                </a>

                <xsl:call-template name="write.chunk">
                    <xsl:with-param name="filename" select="$filename"/>
                    <xsl:with-param name="quiet" select="$chunk.quietly"/>
                    <xsl:with-param name="content">
                        <xsl:call-template name="user.preroot"/>
                        <html>
                            <head>
                                <xsl:call-template name="system.head.content"/>
                                <xsl:call-template name="head.content"/>
                                <xsl:call-template name="user.head.content"/>
                            </head>
                            <body>
                                <xsl:call-template name="body.attributes"/>
                                <div>
                                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                                    <xsl:call-template name="id.attribute">
                                        <xsl:with-param name="conditional" select="0"/>
                                    </xsl:call-template>
                                    <xsl:apply-templates mode="titlepage.mode"/>
                                </div>
                            </body>
                        </html>
                        <xsl:value-of select="$chunk.append"/>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <div>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:call-template name="id.attribute">
                        <xsl:with-param name="conditional" select="0"/>
                    </xsl:call-template>
                    <xsl:call-template name="anchor">
                        <xsl:with-param name="conditional" select="0"/>
                    </xsl:call-template>
                    <xsl:apply-templates mode="titlepage.mode"/>
                </div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="legalnotice/title" mode="titlepage.mode">
        <p class="{$class.prefix}legalnotice-title">
            <strong>
                <xsl:apply-templates/>
            </strong>
        </p>
    </xsl:template>
    <xsl:template match="lineage" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="modespec" mode="titlepage.mode">
    </xsl:template>
    <xsl:template match="orgdiv" mode="titlepage.mode">
        <xsl:if test="preceding-sibling::*[1][self::orgname]">
            <xsl:text> </xsl:text>
        </xsl:if>
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="orgname" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="othercredit" mode="titlepage.mode">
        <xsl:choose>
            <xsl:when test="not($othercredit.like.author.enabled = 0)">
                <xsl:variable name="contrib" select="string(contrib)"/>
                <xsl:choose>
                    <xsl:when test="contrib">
                        <xsl:if test="not(preceding-sibling::othercredit[string(contrib)=$contrib])">
                            <xsl:call-template name="paragraph">
                                <xsl:with-param name="class" select="local-name(.)"/>
                                <xsl:with-param name="content">
                                    <xsl:apply-templates mode="titlepage.mode" select="contrib"/>
                                    <xsl:text>: </xsl:text>
                                    <xsl:call-template name="person.name"/>
                                    <xsl:apply-templates mode="titlepage.mode" select="affiliation"/>
                                    <xsl:apply-templates
                                            select="following-sibling::othercredit[string(contrib)=$contrib]"
                                            mode="titlepage.othercredits"/>
                                </xsl:with-param>
                            </xsl:call-template>
                        </xsl:if>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="paragraph">
                            <xsl:with-param name="class" select="local-name(.)"/>
                            <xsl:with-param name="content">
                                <xsl:call-template name="person.name"/>
                            </xsl:with-param>
                        </xsl:call-template>
                        <xsl:apply-templates mode="titlepage.mode" select="affiliation"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:call-template name="credits.div"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="othercredit" mode="titlepage.othercredits">
        <xsl:text>, </xsl:text>
        <xsl:call-template name="person.name"/>
    </xsl:template>
    <xsl:template match="othername" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="pagenums" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="printhistory" mode="titlepage.mode">
        <div>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="productname" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="productnumber" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="pubdate" mode="titlepage.mode">
        <xsl:call-template name="paragraph">
            <xsl:with-param name="class" select="local-name(.)"/>
            <xsl:with-param name="content">
                <xsl:apply-templates mode="titlepage.mode"/>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="publisher" mode="titlepage.mode">
        <xsl:call-template name="paragraph">
            <xsl:with-param name="class" select="local-name(.)"/>
            <xsl:with-param name="content">
                <xsl:apply-templates mode="titlepage.mode"/>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="publishername" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="pubsnumber" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="titlepage.mode">
        <xsl:call-template name="paragraph">
            <xsl:with-param name="class" select="local-name(.)"/>
            <xsl:with-param name="content">
                <xsl:apply-templates mode="titlepage.mode"/>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="revhistory" mode="titlepage.mode">
        <xsl:variable name="numcols">
            <xsl:choose>
                <xsl:when test=".//authorinitials|.//author">3</xsl:when>
                <xsl:otherwise>2</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="id">
            <xsl:call-template name="object.id"/>
        </xsl:variable>

        <xsl:variable name="title">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key">RevHistory</xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="contents">
            <div>
                <xsl:apply-templates select="." mode="common.html.attributes"/>
                <xsl:call-template name="id.attribute"/>
                <table>
                    <xsl:if test="$css.decoration != 0">
                        <xsl:attribute name="style">
                            <xsl:text>border-style:solid; width:100%;</xsl:text>
                        </xsl:attribute>
                    </xsl:if>
                    <!-- include summary attribute if not HTML5 -->
                    <xsl:if test="$div.element != 'section'">
                        <xsl:attribute name="summary">
                            <xsl:call-template name="gentext">
                                <xsl:with-param name="key">revhistory</xsl:with-param>
                            </xsl:call-template>
                        </xsl:attribute>
                    </xsl:if>
                    <tr>
                        <th align="{$direction.align.start}" valign="top" colspan="{$numcols}">
                            <strong>
                                <xsl:call-template name="gentext">
                                    <xsl:with-param name="key" select="'RevHistory'"/>
                                </xsl:call-template>
                            </strong>
                        </th>
                    </tr>
                    <xsl:apply-templates mode="titlepage.mode">
                        <xsl:with-param name="numcols" select="$numcols"/>
                    </xsl:apply-templates>
                </table>
            </div>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$generate.revhistory.link != 0">

                <!-- Compute name of revhistory file -->
                <xsl:variable name="file">
                    <xsl:call-template name="ln.or.rh.filename">
                        <xsl:with-param name="is.ln" select="false()"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="filename">
                    <xsl:call-template name="make-relative-filename">
                        <xsl:with-param name="base.dir" select="$chunk.base.dir"/>
                        <xsl:with-param name="base.name" select="$file"/>
                    </xsl:call-template>
                </xsl:variable>

                <a href="{$file}">
                    <xsl:copy-of select="$title"/>
                </a>

                <xsl:call-template name="write.chunk">
                    <xsl:with-param name="filename" select="$filename"/>
                    <xsl:with-param name="quiet" select="$chunk.quietly"/>
                    <xsl:with-param name="content">
                        <xsl:call-template name="user.preroot"/>
                        <html>
                            <head>
                                <xsl:call-template name="system.head.content"/>
                                <xsl:call-template name="head.content">
                                    <xsl:with-param name="title">
                                        <xsl:value-of select="$title"/>
                                        <xsl:if test="../../title">
                                            <xsl:value-of select="concat(' (', ../../title, ')')"/>
                                        </xsl:if>
                                    </xsl:with-param>
                                </xsl:call-template>
                                <xsl:call-template name="user.head.content"/>
                            </head>
                            <body>
                                <xsl:call-template name="body.attributes"/>
                                <xsl:copy-of select="$contents"/>
                            </body>
                        </html>
          <xsl:text>
</xsl:text>
                    </xsl:with-param>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="$contents"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="revhistory/revision" mode="titlepage.mode">
        <xsl:param name="numcols" select="'3'"/>
        <xsl:variable name="revnumber" select="revnumber"/>
        <xsl:variable name="revdate" select="date"/>
        <xsl:variable name="revauthor" select="authorinitials|author"/>
        <xsl:variable name="revremark" select="revremark|revdescription"/>
        <tr>
            <td align="{$direction.align.start}">
                <xsl:if test="$revnumber">
                    <xsl:call-template name="gentext">
                        <xsl:with-param name="key" select="'Revision'"/>
                    </xsl:call-template>
                    <xsl:call-template name="gentext.space"/>
                    <xsl:apply-templates select="$revnumber[1]" mode="titlepage.mode"/>
                </xsl:if>
            </td>
            <td align="{$direction.align.start}">
                <xsl:apply-templates select="$revdate[1]" mode="titlepage.mode"/>
            </td>
            <xsl:choose>
                <xsl:when test="$revauthor">
                    <td align="{$direction.align.start}">
                        <xsl:for-each select="$revauthor">
                            <xsl:apply-templates select="." mode="titlepage.mode"/>
                            <xsl:if test="position() != last()">
                                <xsl:text>, </xsl:text>
                            </xsl:if>
                        </xsl:for-each>
                    </td>
                </xsl:when>
                <xsl:when test="$numcols &gt; 2">
                    <td></td>
                </xsl:when>
                <xsl:otherwise/>
            </xsl:choose>
        </tr>
        <xsl:if test="$revremark">
            <tr>
                <td align="{$direction.align.start}" colspan="{$numcols}">
                    <xsl:apply-templates select="$revremark[1]" mode="titlepage.mode"/>
                </td>
            </tr>
        </xsl:if>
    </xsl:template>
    <xsl:template match="revision/revnumber" mode="titlepage.mode">
        <xsl:apply-templates mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="revision/date" mode="titlepage.mode">
        <xsl:apply-templates mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="revision/authorinitials" mode="titlepage.mode">
        <xsl:apply-templates mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="revision/author" mode="titlepage.mode">
        <xsl:apply-templates mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="revision/revremark" mode="titlepage.mode">
        <xsl:apply-templates mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="revision/revdescription" mode="titlepage.mode">
        <xsl:apply-templates mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="seriesvolnums" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="shortaffil" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="subjectset" mode="titlepage.mode">
    </xsl:template>
    <xsl:template match="subtitle" mode="titlepage.mode">
        <h2>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
        </h2>
    </xsl:template>
    <xsl:template match="surname" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template match="title" mode="titlepage.mode">
        <xsl:variable name="id">
            <xsl:choose>
                <!-- if title is in an *info wrapper, get the grandparent -->
                <xsl:when test="contains(local-name(..), 'info')">
                    <xsl:call-template name="object.id">
                        <xsl:with-param name="object" select="../.."/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:call-template name="object.id">
                        <xsl:with-param name="object" select=".."/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <h1>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:choose>
                <xsl:when test="$generate.id.attributes = 0">
                    <a id="{$id}"/>
                </xsl:when>
                <xsl:otherwise>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:choose>
                <xsl:when test="$show.revisionflag != 0 and @revisionflag">
                    <span class="{$class.prefix}{@revisionflag}">
                        <xsl:apply-templates mode="titlepage.mode"/>
                    </span>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:apply-templates mode="titlepage.mode"/>
                </xsl:otherwise>
            </xsl:choose>
        </h1>
    </xsl:template>
    <xsl:template match="titleabbrev" mode="titlepage.mode">
        <!-- nop; title abbreviations don't belong on the title page! -->
    </xsl:template>
    <xsl:template match="volumenum" mode="titlepage.mode">
        <span>
            <xsl:apply-templates select="." mode="common.html.attributes"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:apply-templates mode="titlepage.mode"/>
            <br/>
        </span>
    </xsl:template>
    <xsl:template name="ln.or.rh.filename">
        <xsl:param name="node" select="."/>
        <xsl:param name="is.ln" select="true()"/>

        <xsl:variable name="dbhtml-filename">
            <xsl:call-template name="pi.dbhtml_filename">
                <xsl:with-param name="node" select="$node"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
            <!--  1. If there is a dbhtml_filename PI, use that -->
            <xsl:when test="$dbhtml-filename != ''">
                <xsl:value-of select="$dbhtml-filename"/>
            </xsl:when>
            <xsl:when test="($node/@id or $node/@xml:id) and not($use.id.as.filename = 0)">
                <!-- * 2. If this legalnotice/revhistory has an ID, then go ahead and use -->
                <!-- * just the value of that ID as the basename for the file -->
                <!-- * (that is, without prepending an "ln-" or "rh-" to it) -->
                <xsl:value-of select="($node/@id|$node/@xml:id)[1]"/>
                <xsl:value-of select="$html.ext"/>
            </xsl:when>
            <xsl:when test="not ($node/@id or $node/@xml:id) or $use.id.as.filename = 0">
                <!-- * 3. Otherwise, if this legalnotice/revhistory does not have an ID, or -->
                <!-- * if $use.id.as.filename = 0 -->
                <!-- * then we generate an ID... -->
                <xsl:variable name="id">
                    <xsl:value-of select="generate-id($node)"/>
                </xsl:variable>
                <!-- * ...and then we take that generated ID, prepend a -->
                <!-- * prefix to it, and use that as the basename for the file -->
                <xsl:choose>
                    <xsl:when test="$is.ln">
                        <xsl:value-of select="concat('ln-',$id,$html.ext)"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="concat('rh-',$id,$html.ext)"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="article.titlepage.recto">
        <xsl:choose>
            <xsl:when test="articleinfo/title">
                <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/title"/>
            </xsl:when>
            <xsl:when test="artheader/title">
                <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="articleinfo/subtitle">
                <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="artheader/subtitle">
                <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/corpauthor"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/corpauthor"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/authorgroup"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/authorgroup"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/author"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/author"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/othercredit"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/othercredit"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/releaseinfo"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/releaseinfo"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/copyright"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/copyright"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/legalnotice"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/legalnotice"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/pubdate"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/pubdate"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/revision"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/revision"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/revhistory"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/revhistory"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/abstract"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/abstract"/>
        <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="article.titlepage.verso">
    </xsl:template>
    <xsl:template name="article.titlepage.separator">
    </xsl:template>
    <xsl:template name="article.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="article.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="article.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="article.titlepage.before.recto"/>
                <xsl:call-template name="article.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="article.titlepage.before.verso"/>
                <xsl:call-template name="article.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="article.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="article.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="article.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="article.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="article.titlepage.recto.style">
            <xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="article.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="article.titlepage.recto.style">
            <xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="article.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="article.titlepage.recto.style">
            <xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="article.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="article.titlepage.recto.style">
            <xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="article.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="article.titlepage.recto.style">
            <xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="article.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="article.titlepage.recto.style">
            <xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="article.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="article.titlepage.recto.style">
            <xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="article.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="article.titlepage.recto.style">
            <xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="article.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="article.titlepage.recto.style">
            <xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="article.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="article.titlepage.recto.style">
            <xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="article.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="article.titlepage.recto.style">
            <xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="article.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="article.titlepage.recto.style">
            <xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="article.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="article.titlepage.recto.style">
            <xsl:apply-templates select="." mode="article.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="set.titlepage.recto">
        <xsl:choose>
            <xsl:when test="setinfo/title">
                <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="setinfo/subtitle">
                <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/corpauthor"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/authorgroup"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/author"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/othercredit"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/releaseinfo"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/copyright"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/legalnotice"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/pubdate"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/revision"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/revhistory"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="setinfo/abstract"/>
        <xsl:apply-templates mode="set.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="set.titlepage.verso">
    </xsl:template>
    <xsl:template name="set.titlepage.separator">
    </xsl:template>
    <xsl:template name="set.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="set.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="set.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="set.titlepage.before.recto"/>
                <xsl:call-template name="set.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="set.titlepage.before.verso"/>
                <xsl:call-template name="set.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="set.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="set.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="set.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="set.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="set.titlepage.recto.style">
            <xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="set.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="set.titlepage.recto.style">
            <xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="set.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="set.titlepage.recto.style">
            <xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="set.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="set.titlepage.recto.style">
            <xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="set.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="set.titlepage.recto.style">
            <xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="set.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="set.titlepage.recto.style">
            <xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="set.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="set.titlepage.recto.style">
            <xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="set.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="set.titlepage.recto.style">
            <xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="set.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="set.titlepage.recto.style">
            <xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="set.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="set.titlepage.recto.style">
            <xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="set.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="set.titlepage.recto.style">
            <xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="set.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="set.titlepage.recto.style">
            <xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="set.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="set.titlepage.recto.style">
            <xsl:apply-templates select="." mode="set.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="book.titlepage.recto">
        <xsl:choose>
            <xsl:when test="bookinfo/title">
                <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="bookinfo/subtitle">
                <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/corpauthor"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/authorgroup"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/author"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/othercredit"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/releaseinfo"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/copyright"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/legalnotice"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/pubdate"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/revision"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/revhistory"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/abstract"/>
        <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="book.titlepage.verso">
    </xsl:template>
    <xsl:template name="book.titlepage.separator">
    </xsl:template>
    <xsl:template name="book.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="book.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="book.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="book.titlepage.before.recto"/>
                <xsl:call-template name="book.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="book.titlepage.before.verso"/>
                <xsl:call-template name="book.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="book.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="book.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="book.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="book.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="book.titlepage.recto.style">
            <xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="book.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="book.titlepage.recto.style">
            <xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="book.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="book.titlepage.recto.style">
            <xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="book.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="book.titlepage.recto.style">
            <xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="book.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="book.titlepage.recto.style">
            <xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="book.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="book.titlepage.recto.style">
            <xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="book.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="book.titlepage.recto.style">
            <xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="book.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="book.titlepage.recto.style">
            <xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="book.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="book.titlepage.recto.style">
            <xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="book.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="book.titlepage.recto.style">
            <xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="book.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="book.titlepage.recto.style">
            <xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="book.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="book.titlepage.recto.style">
            <xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="book.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="book.titlepage.recto.style">
            <xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="part.titlepage.recto">
        <div xsl:use-attribute-sets="part.titlepage.recto.style">
            <xsl:call-template name="division.title">
                <xsl:with-param name="node" select="ancestor-or-self::part[1]"/>
            </xsl:call-template>
        </div>
        <xsl:choose>
            <xsl:when test="partinfo/subtitle">
                <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="docinfo/subtitle">
                <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/corpauthor"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/corpauthor"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/authorgroup"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/authorgroup"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/author"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/author"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/othercredit"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/othercredit"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/releaseinfo"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/releaseinfo"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/copyright"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/copyright"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/legalnotice"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/legalnotice"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/pubdate"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/pubdate"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/revision"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/revision"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/revhistory"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/revhistory"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="partinfo/abstract"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="docinfo/abstract"/>
        <xsl:apply-templates mode="part.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="part.titlepage.verso">
    </xsl:template>
    <xsl:template name="part.titlepage.separator">
    </xsl:template>
    <xsl:template name="part.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="part.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="part.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="part.titlepage.before.recto"/>
                <xsl:call-template name="part.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="part.titlepage.before.verso"/>
                <xsl:call-template name="part.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="part.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="part.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="part.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="subtitle" mode="part.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="part.titlepage.recto.style">
            <xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="part.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="part.titlepage.recto.style">
            <xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="part.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="part.titlepage.recto.style">
            <xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="part.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="part.titlepage.recto.style">
            <xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="part.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="part.titlepage.recto.style">
            <xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="part.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="part.titlepage.recto.style">
            <xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="part.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="part.titlepage.recto.style">
            <xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="part.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="part.titlepage.recto.style">
            <xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="part.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="part.titlepage.recto.style">
            <xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="part.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="part.titlepage.recto.style">
            <xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="part.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="part.titlepage.recto.style">
            <xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="part.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="part.titlepage.recto.style">
            <xsl:apply-templates select="." mode="part.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="partintro.titlepage.recto">
        <xsl:choose>
            <xsl:when test="partintroinfo/title">
                <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/title"/>
            </xsl:when>
            <xsl:when test="docinfo/title">
                <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="partintroinfo/subtitle">
                <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="docinfo/subtitle">
                <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/corpauthor"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/corpauthor"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/authorgroup"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/authorgroup"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/author"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/author"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/othercredit"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/othercredit"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/releaseinfo"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/releaseinfo"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/copyright"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/copyright"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/legalnotice"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/legalnotice"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/pubdate"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/pubdate"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/revision"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/revision"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/revhistory"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/revhistory"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="partintroinfo/abstract"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="docinfo/abstract"/>
        <xsl:apply-templates mode="partintro.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="partintro.titlepage.verso">
    </xsl:template>
    <xsl:template name="partintro.titlepage.separator">
    </xsl:template>
    <xsl:template name="partintro.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="partintro.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="partintro.titlepage">
        <div>
            <xsl:variable name="recto.content">
                <xsl:call-template name="partintro.titlepage.before.recto"/>
                <xsl:call-template name="partintro.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="partintro.titlepage.before.verso"/>
                <xsl:call-template name="partintro.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="partintro.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="partintro.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="partintro.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="partintro.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="partintro.titlepage.recto.style">
            <xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="partintro.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="partintro.titlepage.recto.style">
            <xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="partintro.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="partintro.titlepage.recto.style">
            <xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="partintro.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="partintro.titlepage.recto.style">
            <xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="partintro.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="partintro.titlepage.recto.style">
            <xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="partintro.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="partintro.titlepage.recto.style">
            <xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="partintro.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="partintro.titlepage.recto.style">
            <xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="partintro.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="partintro.titlepage.recto.style">
            <xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="partintro.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="partintro.titlepage.recto.style">
            <xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="partintro.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="partintro.titlepage.recto.style">
            <xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="partintro.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="partintro.titlepage.recto.style">
            <xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="partintro.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="partintro.titlepage.recto.style">
            <xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="partintro.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="partintro.titlepage.recto.style">
            <xsl:apply-templates select="." mode="partintro.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="reference.titlepage.recto">
        <xsl:choose>
            <xsl:when test="referenceinfo/title">
                <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/title"/>
            </xsl:when>
            <xsl:when test="docinfo/title">
                <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="referenceinfo/subtitle">
                <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="docinfo/subtitle">
                <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/corpauthor"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/corpauthor"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/authorgroup"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/authorgroup"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/author"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/author"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/othercredit"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/othercredit"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/releaseinfo"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/releaseinfo"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/copyright"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/copyright"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/legalnotice"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/legalnotice"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/pubdate"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/pubdate"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/revision"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/revision"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/revhistory"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/revhistory"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="referenceinfo/abstract"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="docinfo/abstract"/>
        <xsl:apply-templates mode="reference.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="reference.titlepage.verso">
    </xsl:template>
    <xsl:template name="reference.titlepage.separator">
    </xsl:template>
    <xsl:template name="reference.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="reference.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="reference.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="reference.titlepage.before.recto"/>
                <xsl:call-template name="reference.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="reference.titlepage.before.verso"/>
                <xsl:call-template name="reference.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="reference.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="reference.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="reference.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="reference.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="reference.titlepage.recto.style">
            <xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="reference.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="reference.titlepage.recto.style">
            <xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="reference.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="reference.titlepage.recto.style">
            <xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="reference.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="reference.titlepage.recto.style">
            <xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="reference.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="reference.titlepage.recto.style">
            <xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="reference.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="reference.titlepage.recto.style">
            <xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="reference.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="reference.titlepage.recto.style">
            <xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="reference.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="reference.titlepage.recto.style">
            <xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="reference.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="reference.titlepage.recto.style">
            <xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="reference.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="reference.titlepage.recto.style">
            <xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="reference.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="reference.titlepage.recto.style">
            <xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="reference.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="reference.titlepage.recto.style">
            <xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="reference.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="reference.titlepage.recto.style">
            <xsl:apply-templates select="." mode="reference.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="refentry.titlepage.recto">
    </xsl:template>
    <xsl:template name="refentry.titlepage.verso">
    </xsl:template>
    <xsl:template name="refentry.titlepage.separator">
    </xsl:template>
    <xsl:template name="refentry.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="refentry.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="refentry.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="refentry.titlepage.before.recto"/>
                <xsl:call-template name="refentry.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="refentry.titlepage.before.verso"/>
                <xsl:call-template name="refentry.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="refentry.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="refentry.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="refentry.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template name="dedication.titlepage.recto">
        <div xsl:use-attribute-sets="dedication.titlepage.recto.style">
            <xsl:call-template name="component.title">
                <xsl:with-param name="node" select="ancestor-or-self::dedication[1]"/>
            </xsl:call-template>
        </div>
        <xsl:choose>
            <xsl:when test="dedicationinfo/subtitle">
                <xsl:apply-templates mode="dedication.titlepage.recto.auto.mode" select="dedicationinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="docinfo/subtitle">
                <xsl:apply-templates mode="dedication.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="dedication.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="dedication.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

    </xsl:template>
    <xsl:template name="dedication.titlepage.verso">
    </xsl:template>
    <xsl:template name="dedication.titlepage.separator">
    </xsl:template>
    <xsl:template name="dedication.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="dedication.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="dedication.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="dedication.titlepage.before.recto"/>
                <xsl:call-template name="dedication.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="dedication.titlepage.before.verso"/>
                <xsl:call-template name="dedication.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="dedication.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="dedication.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="dedication.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="subtitle" mode="dedication.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="dedication.titlepage.recto.style">
            <xsl:apply-templates select="." mode="dedication.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="acknowledgements.titlepage.recto">
        <div xsl:use-attribute-sets="acknowledgements.titlepage.recto.style">
            <xsl:call-template name="component.title">
                <xsl:with-param name="node" select="ancestor-or-self::acknowledgements[1]"/>
            </xsl:call-template>
        </div>
        <xsl:choose>
            <xsl:when test="acknowledgementsinfo/subtitle">
                <xsl:apply-templates mode="acknowledgements.titlepage.recto.auto.mode"
                                     select="acknowledgementsinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="docinfo/subtitle">
                <xsl:apply-templates mode="acknowledgements.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="acknowledgements.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="acknowledgements.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

    </xsl:template>
    <xsl:template name="acknowledgements.titlepage.verso">
    </xsl:template>
    <xsl:template name="acknowledgements.titlepage.separator">
    </xsl:template>
    <xsl:template name="acknowledgements.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="acknowledgements.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="acknowledgements.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="acknowledgements.titlepage.before.recto"/>
                <xsl:call-template name="acknowledgements.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="acknowledgements.titlepage.before.verso"/>
                <xsl:call-template name="acknowledgements.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="acknowledgements.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="acknowledgements.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="acknowledgements.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="subtitle" mode="acknowledgements.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="acknowledgements.titlepage.recto.style">
            <xsl:apply-templates select="." mode="acknowledgements.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="preface.titlepage.recto">
        <xsl:choose>
            <xsl:when test="prefaceinfo/title">
                <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/title"/>
            </xsl:when>
            <xsl:when test="docinfo/title">
                <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="prefaceinfo/subtitle">
                <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="docinfo/subtitle">
                <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/corpauthor"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/corpauthor"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/authorgroup"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/authorgroup"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/author"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/author"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/othercredit"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/othercredit"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/releaseinfo"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/releaseinfo"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/copyright"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/copyright"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/legalnotice"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/legalnotice"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/pubdate"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/pubdate"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/revision"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/revision"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/revhistory"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/revhistory"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="prefaceinfo/abstract"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="docinfo/abstract"/>
        <xsl:apply-templates mode="preface.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="preface.titlepage.verso">
    </xsl:template>
    <xsl:template name="preface.titlepage.separator">
    </xsl:template>
    <xsl:template name="preface.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="preface.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="preface.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="preface.titlepage.before.recto"/>
                <xsl:call-template name="preface.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="preface.titlepage.before.verso"/>
                <xsl:call-template name="preface.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="preface.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="preface.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="preface.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="preface.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="preface.titlepage.recto.style">
            <xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="preface.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="preface.titlepage.recto.style">
            <xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="preface.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="preface.titlepage.recto.style">
            <xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="preface.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="preface.titlepage.recto.style">
            <xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="preface.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="preface.titlepage.recto.style">
            <xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="preface.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="preface.titlepage.recto.style">
            <xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="preface.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="preface.titlepage.recto.style">
            <xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="preface.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="preface.titlepage.recto.style">
            <xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="preface.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="preface.titlepage.recto.style">
            <xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="preface.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="preface.titlepage.recto.style">
            <xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="preface.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="preface.titlepage.recto.style">
            <xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="preface.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="preface.titlepage.recto.style">
            <xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="preface.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="preface.titlepage.recto.style">
            <xsl:apply-templates select="." mode="preface.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="chapter.titlepage.recto">
        <xsl:choose>
            <xsl:when test="chapterinfo/title">
                <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/title"/>
            </xsl:when>
            <xsl:when test="docinfo/title">
                <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="chapterinfo/subtitle">
                <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="docinfo/subtitle">
                <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/corpauthor"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/corpauthor"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/authorgroup"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/authorgroup"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/author"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/author"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/othercredit"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/othercredit"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/releaseinfo"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/releaseinfo"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/copyright"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/copyright"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/legalnotice"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/legalnotice"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/pubdate"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/pubdate"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/revision"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/revision"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/revhistory"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/revhistory"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="chapterinfo/abstract"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="docinfo/abstract"/>
        <xsl:apply-templates mode="chapter.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="chapter.titlepage.verso">
    </xsl:template>
    <xsl:template name="chapter.titlepage.separator">
    </xsl:template>
    <xsl:template name="chapter.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="chapter.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="chapter.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="chapter.titlepage.before.recto"/>
                <xsl:call-template name="chapter.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="chapter.titlepage.before.verso"/>
                <xsl:call-template name="chapter.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="chapter.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="chapter.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="chapter.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="chapter.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="chapter.titlepage.recto.style">
            <xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="chapter.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="chapter.titlepage.recto.style">
            <xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="chapter.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="chapter.titlepage.recto.style">
            <xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="chapter.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="chapter.titlepage.recto.style">
            <xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="chapter.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="chapter.titlepage.recto.style">
            <xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="chapter.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="chapter.titlepage.recto.style">
            <xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="chapter.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="chapter.titlepage.recto.style">
            <xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="chapter.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="chapter.titlepage.recto.style">
            <xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="chapter.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="chapter.titlepage.recto.style">
            <xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="chapter.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="chapter.titlepage.recto.style">
            <xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="chapter.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="chapter.titlepage.recto.style">
            <xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="chapter.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="chapter.titlepage.recto.style">
            <xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="chapter.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="chapter.titlepage.recto.style">
            <xsl:apply-templates select="." mode="chapter.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="topic.titlepage.recto">
        <xsl:choose>
            <xsl:when test="topicinfo/title">
                <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="topicinfo/subtitle">
                <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/corpauthor"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/authorgroup"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/author"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/othercredit"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/releaseinfo"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/copyright"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/legalnotice"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/pubdate"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/revision"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/revhistory"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="topicinfo/abstract"/>
        <xsl:apply-templates mode="topic.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="topic.titlepage.verso">
    </xsl:template>
    <xsl:template name="topic.titlepage.separator">
    </xsl:template>
    <xsl:template name="topic.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="topic.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="topic.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="topic.titlepage.before.recto"/>
                <xsl:call-template name="topic.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="topic.titlepage.before.verso"/>
                <xsl:call-template name="topic.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="topic.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="topic.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="topic.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="topic.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="topic.titlepage.recto.style">
            <xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="topic.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="topic.titlepage.recto.style">
            <xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="topic.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="topic.titlepage.recto.style">
            <xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="topic.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="topic.titlepage.recto.style">
            <xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="topic.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="topic.titlepage.recto.style">
            <xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="topic.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="topic.titlepage.recto.style">
            <xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="topic.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="topic.titlepage.recto.style">
            <xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="topic.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="topic.titlepage.recto.style">
            <xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="topic.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="topic.titlepage.recto.style">
            <xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="topic.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="topic.titlepage.recto.style">
            <xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="topic.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="topic.titlepage.recto.style">
            <xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="topic.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="topic.titlepage.recto.style">
            <xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="topic.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="topic.titlepage.recto.style">
            <xsl:apply-templates select="." mode="topic.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="appendix.titlepage.recto">
        <xsl:choose>
            <xsl:when test="appendixinfo/title">
                <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/title"/>
            </xsl:when>
            <xsl:when test="docinfo/title">
                <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="appendixinfo/subtitle">
                <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="docinfo/subtitle">
                <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/corpauthor"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/corpauthor"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/authorgroup"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/authorgroup"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/author"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/author"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/othercredit"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/othercredit"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/releaseinfo"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/releaseinfo"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/copyright"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/copyright"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/legalnotice"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/legalnotice"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/pubdate"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/pubdate"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/revision"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/revision"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/revhistory"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/revhistory"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="appendixinfo/abstract"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="docinfo/abstract"/>
        <xsl:apply-templates mode="appendix.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="appendix.titlepage.verso">
    </xsl:template>
    <xsl:template name="appendix.titlepage.separator">
    </xsl:template>
    <xsl:template name="appendix.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="appendix.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="appendix.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="appendix.titlepage.before.recto"/>
                <xsl:call-template name="appendix.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="appendix.titlepage.before.verso"/>
                <xsl:call-template name="appendix.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="appendix.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="appendix.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="appendix.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="appendix.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="appendix.titlepage.recto.style">
            <xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="appendix.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="appendix.titlepage.recto.style">
            <xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="appendix.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="appendix.titlepage.recto.style">
            <xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="appendix.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="appendix.titlepage.recto.style">
            <xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="appendix.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="appendix.titlepage.recto.style">
            <xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="appendix.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="appendix.titlepage.recto.style">
            <xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="appendix.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="appendix.titlepage.recto.style">
            <xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="appendix.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="appendix.titlepage.recto.style">
            <xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="appendix.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="appendix.titlepage.recto.style">
            <xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="appendix.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="appendix.titlepage.recto.style">
            <xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="appendix.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="appendix.titlepage.recto.style">
            <xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="appendix.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="appendix.titlepage.recto.style">
            <xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="appendix.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="appendix.titlepage.recto.style">
            <xsl:apply-templates select="." mode="appendix.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="section.titlepage.recto">
        <xsl:choose>
            <xsl:when test="sectioninfo/title">
                <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="sectioninfo/subtitle">
                <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/corpauthor"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/authorgroup"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/author"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/othercredit"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/releaseinfo"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/copyright"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/legalnotice"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/pubdate"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/revision"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/revhistory"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="sectioninfo/abstract"/>
        <xsl:apply-templates mode="section.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="section.titlepage.verso">
    </xsl:template>
    <xsl:template name="section.titlepage.separator">
        <xsl:if test="count(parent::*)='0'">
            <hr/>
        </xsl:if>
    </xsl:template>
    <xsl:template name="section.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="section.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="section.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="section.titlepage.before.recto"/>
                <xsl:call-template name="section.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="section.titlepage.before.verso"/>
                <xsl:call-template name="section.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="section.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="section.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="section.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="section.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="section.titlepage.recto.style">
            <xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="section.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="section.titlepage.recto.style">
            <xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="section.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="section.titlepage.recto.style">
            <xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="section.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="section.titlepage.recto.style">
            <xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="section.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="section.titlepage.recto.style">
            <xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="section.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="section.titlepage.recto.style">
            <xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="section.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="section.titlepage.recto.style">
            <xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="section.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="section.titlepage.recto.style">
            <xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="section.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="section.titlepage.recto.style">
            <xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="section.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="section.titlepage.recto.style">
            <xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="section.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="section.titlepage.recto.style">
            <xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="section.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="section.titlepage.recto.style">
            <xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="section.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="section.titlepage.recto.style">
            <xsl:apply-templates select="." mode="section.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="sect1.titlepage.recto">
        <xsl:choose>
            <xsl:when test="sect1info/title">
                <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="sect1info/subtitle">
                <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/corpauthor"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/authorgroup"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/author"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/othercredit"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/releaseinfo"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/copyright"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/legalnotice"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/pubdate"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/revision"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/revhistory"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="sect1info/abstract"/>
        <xsl:apply-templates mode="sect1.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="sect1.titlepage.verso">
    </xsl:template>
    <xsl:template name="sect1.titlepage.separator">
        <xsl:if test="count(parent::*)='0'">
            <hr/>
        </xsl:if>
    </xsl:template>
    <xsl:template name="sect1.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="sect1.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="sect1.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="sect1.titlepage.before.recto"/>
                <xsl:call-template name="sect1.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="sect1.titlepage.before.verso"/>
                <xsl:call-template name="sect1.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="sect1.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="sect1.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="sect1.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="sect1.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect1.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="sect1.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect1.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="sect1.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect1.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="sect1.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect1.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="sect1.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect1.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="sect1.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect1.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="sect1.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect1.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="sect1.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect1.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="sect1.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect1.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="sect1.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect1.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="sect1.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect1.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="sect1.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect1.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="sect1.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect1.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect1.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="sect2.titlepage.recto">
        <xsl:choose>
            <xsl:when test="sect2info/title">
                <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="sect2info/subtitle">
                <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/corpauthor"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/authorgroup"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/author"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/othercredit"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/releaseinfo"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/copyright"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/legalnotice"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/pubdate"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/revision"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/revhistory"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="sect2info/abstract"/>
        <xsl:apply-templates mode="sect2.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="sect2.titlepage.verso">
    </xsl:template>
    <xsl:template name="sect2.titlepage.separator">
        <xsl:if test="count(parent::*)='0'">
            <hr/>
        </xsl:if>
    </xsl:template>
    <xsl:template name="sect2.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="sect2.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="sect2.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="sect2.titlepage.before.recto"/>
                <xsl:call-template name="sect2.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="sect2.titlepage.before.verso"/>
                <xsl:call-template name="sect2.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="sect2.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="sect2.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="sect2.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="sect2.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect2.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="sect2.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect2.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="sect2.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect2.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="sect2.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect2.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="sect2.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect2.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="sect2.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect2.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="sect2.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect2.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="sect2.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect2.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="sect2.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect2.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="sect2.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect2.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="sect2.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect2.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="sect2.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect2.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="sect2.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect2.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect2.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="sect3.titlepage.recto">
        <xsl:choose>
            <xsl:when test="sect3info/title">
                <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="sect3info/subtitle">
                <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/corpauthor"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/authorgroup"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/author"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/othercredit"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/releaseinfo"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/copyright"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/legalnotice"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/pubdate"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/revision"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/revhistory"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="sect3info/abstract"/>
        <xsl:apply-templates mode="sect3.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="sect3.titlepage.verso">
    </xsl:template>
    <xsl:template name="sect3.titlepage.separator">
        <xsl:if test="count(parent::*)='0'">
            <hr/>
        </xsl:if>
    </xsl:template>
    <xsl:template name="sect3.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="sect3.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="sect3.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="sect3.titlepage.before.recto"/>
                <xsl:call-template name="sect3.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="sect3.titlepage.before.verso"/>
                <xsl:call-template name="sect3.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="sect3.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="sect3.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="sect3.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="sect3.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect3.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="sect3.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect3.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="sect3.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect3.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="sect3.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect3.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="sect3.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect3.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="sect3.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect3.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="sect3.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect3.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="sect3.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect3.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="sect3.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect3.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="sect3.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect3.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="sect3.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect3.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="sect3.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect3.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="sect3.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect3.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect3.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="sect4.titlepage.recto">
        <xsl:choose>
            <xsl:when test="sect4info/title">
                <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="sect4info/subtitle">
                <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/corpauthor"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/authorgroup"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/author"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/othercredit"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/releaseinfo"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/copyright"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/legalnotice"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/pubdate"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/revision"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/revhistory"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="sect4info/abstract"/>
        <xsl:apply-templates mode="sect4.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="sect4.titlepage.verso">
    </xsl:template>
    <xsl:template name="sect4.titlepage.separator">
        <xsl:if test="count(parent::*)='0'">
            <hr/>
        </xsl:if>
    </xsl:template>
    <xsl:template name="sect4.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="sect4.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="sect4.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="sect4.titlepage.before.recto"/>
                <xsl:call-template name="sect4.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="sect4.titlepage.before.verso"/>
                <xsl:call-template name="sect4.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="sect4.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="sect4.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="sect4.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="sect4.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect4.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="sect4.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect4.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="sect4.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect4.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="sect4.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect4.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="sect4.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect4.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="sect4.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect4.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="sect4.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect4.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="sect4.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect4.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="sect4.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect4.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="sect4.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect4.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="sect4.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect4.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="sect4.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect4.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="sect4.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect4.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect4.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="sect5.titlepage.recto">
        <xsl:choose>
            <xsl:when test="sect5info/title">
                <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="sect5info/subtitle">
                <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/corpauthor"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/authorgroup"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/author"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/othercredit"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/releaseinfo"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/copyright"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/legalnotice"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/pubdate"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/revision"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/revhistory"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="sect5info/abstract"/>
        <xsl:apply-templates mode="sect5.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="sect5.titlepage.verso">
    </xsl:template>
    <xsl:template name="sect5.titlepage.separator">
        <xsl:if test="count(parent::*)='0'">
            <hr/>
        </xsl:if>
    </xsl:template>
    <xsl:template name="sect5.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="sect5.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="sect5.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="sect5.titlepage.before.recto"/>
                <xsl:call-template name="sect5.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="sect5.titlepage.before.verso"/>
                <xsl:call-template name="sect5.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="sect5.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="sect5.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="sect5.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="sect5.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect5.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="sect5.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect5.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="sect5.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect5.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="sect5.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect5.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="sect5.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect5.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="sect5.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect5.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="sect5.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect5.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="sect5.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect5.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="sect5.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect5.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="sect5.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect5.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="sect5.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect5.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="sect5.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect5.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="sect5.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sect5.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sect5.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="simplesect.titlepage.recto">
        <xsl:choose>
            <xsl:when test="simplesectinfo/title">
                <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/title"/>
            </xsl:when>
            <xsl:when test="docinfo/title">
                <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="simplesectinfo/subtitle">
                <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="docinfo/subtitle">
                <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/corpauthor"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/corpauthor"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/corpauthor"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/authorgroup"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/authorgroup"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/authorgroup"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/author"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/author"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/author"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/othercredit"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/othercredit"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/othercredit"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/releaseinfo"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/releaseinfo"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/releaseinfo"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/copyright"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/copyright"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/copyright"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/legalnotice"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/legalnotice"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/legalnotice"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/pubdate"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/pubdate"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/pubdate"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/revision"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/revision"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/revision"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/revhistory"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/revhistory"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/revhistory"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="simplesectinfo/abstract"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="docinfo/abstract"/>
        <xsl:apply-templates mode="simplesect.titlepage.recto.auto.mode" select="info/abstract"/>
    </xsl:template>
    <xsl:template name="simplesect.titlepage.verso">
    </xsl:template>
    <xsl:template name="simplesect.titlepage.separator">
        <xsl:if test="count(parent::*)='0'">
            <hr/>
        </xsl:if>
    </xsl:template>
    <xsl:template name="simplesect.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="simplesect.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="simplesect.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="simplesect.titlepage.before.recto"/>
                <xsl:call-template name="simplesect.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="simplesect.titlepage.before.verso"/>
                <xsl:call-template name="simplesect.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="simplesect.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="simplesect.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="simplesect.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="simplesect.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
            <xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="simplesect.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
            <xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="corpauthor" mode="simplesect.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
            <xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="authorgroup" mode="simplesect.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
            <xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="author" mode="simplesect.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
            <xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="othercredit" mode="simplesect.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
            <xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="releaseinfo" mode="simplesect.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
            <xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="copyright" mode="simplesect.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
            <xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="legalnotice" mode="simplesect.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
            <xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="pubdate" mode="simplesect.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
            <xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revision" mode="simplesect.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
            <xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="revhistory" mode="simplesect.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
            <xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template match="abstract" mode="simplesect.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="simplesect.titlepage.recto.style">
            <xsl:apply-templates select="." mode="simplesect.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="bibliography.titlepage.recto">
        <div xsl:use-attribute-sets="bibliography.titlepage.recto.style">
            <xsl:call-template name="component.title">
                <xsl:with-param name="node" select="ancestor-or-self::bibliography[1]"/>
            </xsl:call-template>
        </div>
        <xsl:choose>
            <xsl:when test="bibliographyinfo/subtitle">
                <xsl:apply-templates mode="bibliography.titlepage.recto.auto.mode" select="bibliographyinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="docinfo/subtitle">
                <xsl:apply-templates mode="bibliography.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="bibliography.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="bibliography.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

    </xsl:template>
    <xsl:template name="bibliography.titlepage.verso">
    </xsl:template>
    <xsl:template name="bibliography.titlepage.separator">
    </xsl:template>
    <xsl:template name="bibliography.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="bibliography.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="bibliography.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="bibliography.titlepage.before.recto"/>
                <xsl:call-template name="bibliography.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="bibliography.titlepage.before.verso"/>
                <xsl:call-template name="bibliography.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="bibliography.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="bibliography.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="bibliography.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="subtitle" mode="bibliography.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="bibliography.titlepage.recto.style">
            <xsl:apply-templates select="." mode="bibliography.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="glossary.titlepage.recto">
        <div xsl:use-attribute-sets="glossary.titlepage.recto.style">
            <xsl:call-template name="component.title">
                <xsl:with-param name="node" select="ancestor-or-self::glossary[1]"/>
            </xsl:call-template>
        </div>
        <xsl:choose>
            <xsl:when test="glossaryinfo/subtitle">
                <xsl:apply-templates mode="glossary.titlepage.recto.auto.mode" select="glossaryinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="docinfo/subtitle">
                <xsl:apply-templates mode="glossary.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="glossary.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="glossary.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

    </xsl:template>
    <xsl:template name="glossary.titlepage.verso">
    </xsl:template>
    <xsl:template name="glossary.titlepage.separator">
    </xsl:template>
    <xsl:template name="glossary.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="glossary.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="glossary.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="glossary.titlepage.before.recto"/>
                <xsl:call-template name="glossary.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="glossary.titlepage.before.verso"/>
                <xsl:call-template name="glossary.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="glossary.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="glossary.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="glossary.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="subtitle" mode="glossary.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="glossary.titlepage.recto.style">
            <xsl:apply-templates select="." mode="glossary.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="index.titlepage.recto">
        <div xsl:use-attribute-sets="index.titlepage.recto.style">
            <xsl:call-template name="component.title">
                <xsl:with-param name="node" select="ancestor-or-self::index[1]"/>
            </xsl:call-template>
        </div>
        <xsl:choose>
            <xsl:when test="indexinfo/subtitle">
                <xsl:apply-templates mode="index.titlepage.recto.auto.mode" select="indexinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="docinfo/subtitle">
                <xsl:apply-templates mode="index.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="index.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="index.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

    </xsl:template>
    <xsl:template name="index.titlepage.verso">
    </xsl:template>
    <xsl:template name="index.titlepage.separator">
    </xsl:template>
    <xsl:template name="index.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="index.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="index.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="index.titlepage.before.recto"/>
                <xsl:call-template name="index.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="index.titlepage.before.verso"/>
                <xsl:call-template name="index.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="index.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="index.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="index.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="subtitle" mode="index.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="index.titlepage.recto.style">
            <xsl:apply-templates select="." mode="index.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="setindex.titlepage.recto">
        <div xsl:use-attribute-sets="setindex.titlepage.recto.style">
            <xsl:call-template name="component.title">
                <xsl:with-param name="node" select="ancestor-or-self::setindex[1]"/>
            </xsl:call-template>
        </div>
        <xsl:choose>
            <xsl:when test="setindexinfo/subtitle">
                <xsl:apply-templates mode="setindex.titlepage.recto.auto.mode" select="setindexinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="docinfo/subtitle">
                <xsl:apply-templates mode="setindex.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="setindex.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="setindex.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

    </xsl:template>
    <xsl:template name="setindex.titlepage.verso">
    </xsl:template>
    <xsl:template name="setindex.titlepage.separator">
    </xsl:template>
    <xsl:template name="setindex.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="setindex.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="setindex.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="setindex.titlepage.before.recto"/>
                <xsl:call-template name="setindex.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="setindex.titlepage.before.verso"/>
                <xsl:call-template name="setindex.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="setindex.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="setindex.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="setindex.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="subtitle" mode="setindex.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="setindex.titlepage.recto.style">
            <xsl:apply-templates select="." mode="setindex.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <xsl:template name="sidebar.titlepage.recto">
        <xsl:choose>
            <xsl:when test="sidebarinfo/title">
                <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="sidebarinfo/title"/>
            </xsl:when>
            <xsl:when test="docinfo/title">
                <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="docinfo/title"/>
            </xsl:when>
            <xsl:when test="info/title">
                <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="info/title"/>
            </xsl:when>
            <xsl:when test="title">
                <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="title"/>
            </xsl:when>
        </xsl:choose>

        <xsl:choose>
            <xsl:when test="sidebarinfo/subtitle">
                <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="sidebarinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="docinfo/subtitle">
                <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="docinfo/subtitle"/>
            </xsl:when>
            <xsl:when test="info/subtitle">
                <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="info/subtitle"/>
            </xsl:when>
            <xsl:when test="subtitle">
                <xsl:apply-templates mode="sidebar.titlepage.recto.auto.mode" select="subtitle"/>
            </xsl:when>
        </xsl:choose>

    </xsl:template>
    <xsl:template name="sidebar.titlepage.verso">
    </xsl:template>
    <xsl:template name="sidebar.titlepage.separator">
    </xsl:template>
    <xsl:template name="sidebar.titlepage.before.recto">
    </xsl:template>
    <xsl:template name="sidebar.titlepage.before.verso">
    </xsl:template>
    <xsl:template name="sidebar.titlepage">
        <div class="{$class.prefix}titlepage">
            <xsl:variable name="recto.content">
                <xsl:call-template name="sidebar.titlepage.before.recto"/>
                <xsl:call-template name="sidebar.titlepage.recto"/>
            </xsl:variable>
            <xsl:variable name="recto.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($recto.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($recto.content) != '') or ($recto.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$recto.content"/>
                </div>
            </xsl:if>
            <xsl:variable name="verso.content">
                <xsl:call-template name="sidebar.titlepage.before.verso"/>
                <xsl:call-template name="sidebar.titlepage.verso"/>
            </xsl:variable>
            <xsl:variable name="verso.elements.count">
                <xsl:choose>
                    <xsl:when test="function-available('exsl:node-set')">
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:when test="contains(system-property('xsl:vendor'), 'Apache Software Foundation')">
                        <!--Xalan quirk-->
                        <xsl:value-of select="count(exsl:node-set($verso.content)/*)"/>
                    </xsl:when>
                    <xsl:otherwise>1</xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="(normalize-space($verso.content) != '') or ($verso.elements.count &gt; 0)">
                <div>
                    <xsl:copy-of select="$verso.content"/>
                </div>
            </xsl:if>
            <xsl:call-template name="sidebar.titlepage.separator"/>
        </div>
    </xsl:template>
    <xsl:template match="*" mode="sidebar.titlepage.recto.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="sidebar.titlepage.verso.mode">
        <!-- if an element isn't found in this mode, -->
        <!-- try the generic titlepage.mode -->
        <xsl:apply-templates select="." mode="titlepage.mode"/>
    </xsl:template>
    <xsl:template match="title" mode="sidebar.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sidebar.titlepage.recto.style">
            <xsl:call-template name="formal.object.heading">
                <xsl:with-param name="object" select="ancestor-or-self::sidebar[1]"/>
            </xsl:call-template>
        </div>
    </xsl:template>
    <xsl:template match="subtitle" mode="sidebar.titlepage.recto.auto.mode">
        <div xsl:use-attribute-sets="sidebar.titlepage.recto.style">
            <xsl:apply-templates select="." mode="sidebar.titlepage.recto.mode"/>
        </div>
    </xsl:template>
    <doc:reference xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0">
        <info xmlns="http://www.w3.org/1999/xhtml">
            <title>HTML Processing Instruction Reference</title>
            <releaseinfo role="meta">
                $Id: pi.xsl 9022 2011-07-14 19:21:36Z bobstayton $
            </releaseinfo>
        </info>
        <partintro xmlns="http://www.w3.org/1999/xhtml" id="partintro">
            <title>Introduction</title>
            <para>This is generated reference documentation for all
                user-specifiable processing instructions (PIs) in the DocBook
                XSL stylesheets for HTML output.
                <note>
                    <para>You add these PIs at particular points in a document to
                        cause specific “exceptions” to formatting/output behavior. To
                        make global changes in formatting/output behavior across an
                        entire document, it’s better to do it by setting an
                        appropriate stylesheet parameter (if there is one).
                    </para>
                </note>
            </para>
        </partintro>
    </doc:reference>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_background-color">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Sets background color for an image</refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml background-color</tag>
                PI before or
                after an image (<tag>graphic</tag>,<tag>inlinegraphic</tag>,
                <tag>imagedata</tag>, or
                <tag>videodata</tag>
                element) as a
                sibling to the element, to set a background color for the
                image.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml background-color="<replaceable>color</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>background-color="<replaceable>color</replaceable>"
                    </term>
                    <listitem>
                        <para>An HTML color value</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="BGcolor.html">Background color
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_background-color">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'background-color'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_bgcolor">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Sets background color on a CALS table row or table cell
        </refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml bgcolor</tag>
                PI as child of a CALS table row
                or cell to set a background color for that table row or cell.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml bgcolor="<replaceable>color</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>bgcolor="<replaceable>color</replaceable>"
                    </term>
                    <listitem>
                        <para>An HTML color value</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="BGtableColor.html#CellBGColor">
                    Cell background color
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_bgcolor">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'bgcolor'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_cellpadding">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies cellpadding in CALS table or qandaset output
        </refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml cellpadding</tag>
                PI as a child of a
                CALS
                <tag>table</tag>
                or
                <tag>qandaset</tag>
                to specify the value
                for the HTML
                <literal>cellpadding</literal>
                attribute in the
                output HTML table.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml cellpadding="<replaceable>number</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>cellpadding="<replaceable>number</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the cellpadding</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
            <para>
                <parameter>html.cellpadding</parameter>
            </para>
        </refsee>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="CellSpacing.html">Cell spacing
                and cell padding</link>,
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="QandAformat.html">Q and A
                    formatting
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_cellpadding">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'cellpadding'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_cellspacing">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies cellspacing in CALS table or qandaset output
        </refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml cellspacing</tag>
                PI as a child of a
                CALS
                <tag>table</tag>
                or
                <tag>qandaset</tag>
                to specify the value
                for the HTML
                <literal>cellspacing</literal>
                attribute in the
                output HTML table.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml cellspacing="<replaceable>number</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>cellspacing="<replaceable>number</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the cellspacing</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
            <para>
                <parameter>html.cellspacing</parameter>
            </para>
        </refsee>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="CellSpacing.html">Cell spacing
                and cell padding</link>,
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="QandAformat.html">Q and A
                    formatting
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_cellspacing">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'cellspacing'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_class">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Set value of the class attribute for a CALS table row
        </refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml class</tag>
                PI as a child of a
                <tag>row</tag>
                to specify a
                <literal>class</literal>
                attribute and value in the HTML output for that row.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml class="<replaceable>name</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>class="<replaceable>name</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the class name</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="CSSTableCells.html">Table styles
                    in HTML output
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_class">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'class'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_dir">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies a directory name in which to write files</refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>When chunking output, use the
                <tag class="xmlpi">dbhtml dir</tag>
                PI
                as a child of a chunk source to cause the output of that
                chunk to be written to the specified directory; also, use it
                as a child of a
                <tag>mediaobject</tag>
                to specify a
                directory into which any long-description files for that
                <tag>mediaobject</tag>
                will be written.
            </para>

            <para>The output directory specification is inherited by all
                chunks of the descendants of the element. If descendants need
                to go to a different directory, then add another
                <tag class="xmlpi">dbhtml dir</tag>
                processing
                instruction as a child of the source element
                for that chunk, and specify the path relative to the
                ancestor path.
            </para>

            <para>For example, to put most chunk files into
                <filename class="directory">shared</filename>
                but one chapter into
                <filename class="directory">exception</filename>
                at the same level, use:
            </para>

            <programlisting>&lt;book&gt;
                &lt;?dbhtml dir="shared"?&gt;
                ...
                &lt;chapter&gt;
                &lt;?dbhtml dir="../exception"?&gt;
                &lt;/chapter&gt;
                &lt;/book&gt;
            </programlisting>


        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml dir="<replaceable>path</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>dir="<replaceable>path</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the pathname for the directory</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
            <para>
                <parameter>base.dir</parameter>
            </para>
        </refsee>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Chunking.html#dbhtmlDirPI">
                    dbhtml dir processing instruction
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_dir">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'dir'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_filename">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies a filename for a chunk</refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>When chunking output, use the
                <tag class="xmlpi">dbhtml filename</tag>
                PI as a child of a chunk source to specify a filename for
                the output file for that chunk. Include the filename suffix.
            </para>

            <para>You cannot include a directory path in the filename value,
                or your links may not work. Add a
                <tag class="xmlpi">dbhtml dir</tag>
                processing instruction
                to specify the output directory. You can also combine the two
                specifications in one processing instruction:
                <tag class="xmlpi">dbhtml dir="mydir" filename="myfile.html"</tag>.
            </para>

        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml filename="<replaceable>filename</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>filename="<replaceable>path</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the filename for the file</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
            <para>
                <parameter>use.id.as.filename</parameter>
            </para>
        </refsee>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Chunking.html#DbhtmlFilenames">
                    dbhtml filenames
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_filename">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'filename'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_funcsynopsis-style">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies presentation style for a funcsynopsis</refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml funcsynopsis-style</tag>
                PI as a child of
                a
                <tag>funcsynopsis</tag>
                or anywhere within a funcsynopsis
                to control the presentation style for output of all
                <tag>funcprototype</tag>
                instances within that funcsynopsis.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml funcsynopsis-style="kr"|"ansi"</tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>funcsynopsis-style="kr"</term>
                    <listitem>
                        <para>Displays
                            <tag>funcprototype</tag>
                            output in K&amp;R style
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>funcsynopsis-style="ansi"</term>
                    <listitem>
                        <para>Displays
                            <tag>funcprototype</tag>
                            output in ANSI style
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
            <para>
                <parameter>funcsynopsis.style</parameter>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_funcsynopsis-style">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'funcsynopsis-style'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_img.src.path">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies a path to the location of an image file</refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml img.src.path</tag>
                PI before or
                after an image (<tag>graphic</tag>,
                <tag>inlinegraphic</tag>,<tag>imagedata</tag>, or
                <tag>videodata</tag>
                element) as a sibling to the element,
                to specify a path to the location of the image; in HTML
                output, the value specified for the
                <code>img.src.path</code>
                attribute is prepended to the
                filename.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml img.src.path="<replaceable>path</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>img.src.path="<replaceable>path</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the pathname to prepend to the name of the image file</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
            <para>
                <parameter>img.src.path</parameter>
            </para>
        </refsee>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg"
                      xlink:href="GraphicsLocations.html#UsingFileref">Using fileref
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_img.src.path">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'img.src.path'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_label-width">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies the label width for a qandaset</refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml label-width</tag>
                PI as a child of a
                <tag>qandaset</tag>
                to specify the width of labels.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml label-width="<replaceable>width</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>label-width="<replaceable>width</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the label width (including units)</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="QandAformat.html">Q and A
                    formatting
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_label-width">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'label-width'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_linenumbering.everyNth">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies interval for line numbers in verbatims</refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml linenumbering.everyNth</tag>
                PI as a child
                of a “verbatim” element –<tag>programlisting</tag>,
                <tag>screen</tag>,
                <tag>synopsis</tag>
                — to specify
                the interval at which lines are numbered.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml linenumbering.everyNth="<replaceable>N</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>linenumbering.everyNth="<replaceable>N</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies numbering interval; a number is output
                            before every<replaceable>N</replaceable>th line
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
            <para>
                <parameter>linenumbering.everyNth</parameter>
            </para>
        </refsee>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg"
                      xlink:href="AnnotateListing.html#LineNumbering">Line numbering
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_linenumbering.everyNth">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'linenumbering.everyNth'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_linenumbering.separator">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies separator text for line numbers in verbatims
        </refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml linenumbering.separator</tag>
                PI as a child
                of a “verbatim” element –<tag>programlisting</tag>,
                <tag>screen</tag>,
                <tag>synopsis</tag>
                — to specify
                the separator text output between the line numbers and content.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml linenumbering.separator="<replaceable>text</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>linenumbering.separator="<replaceable>text</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the text (zero or more characters)</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
            <para>
                <parameter>linenumbering.separator</parameter>
            </para>
        </refsee>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg"
                      xlink:href="AnnotateListing.html#LineNumbering">Line numbering
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_linenumbering.separator">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'linenumbering.separator'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_linenumbering.width">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies width for line numbers in verbatims</refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml linenumbering.width</tag>
                PI as a child
                of a “verbatim” element –<tag>programlisting</tag>,
                <tag>screen</tag>,
                <tag>synopsis</tag>
                — to specify
                the width set aside for line numbers.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml linenumbering.width="<replaceable>width</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>linenumbering.width="<replaceable>width</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the width (inluding units)</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
            <para>
                <parameter>linenumbering.width</parameter>
            </para>
        </refsee>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg"
                      xlink:href="AnnotateListing.html#LineNumbering">Line numbering
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_linenumbering.width">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'linenumbering.width'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_list-presentation">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies presentation style for a variablelist or
            segmentedlist
        </refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml list-presentation</tag>
                PI as a child of
                a
                <tag>variablelist</tag>
                or
                <tag>segmentedlist</tag>
                to
                control the presentation style for the list (to cause it, for
                example, to be displayed as a table).
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml list-presentation="list"|"table"</tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>list-presentation="list"</term>
                    <listitem>
                        <para>Displays the list as a list</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>list-presentation="table"</term>
                    <listitem>
                        <para>Displays the list as a table</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
            <itemizedlist>
                <listitem>
                    <para>
                        <parameter>variablelist.as.table</parameter>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        <parameter>segmentedlist.as.table</parameter>
                    </para>
                </listitem>
            </itemizedlist>
        </refsee>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg"
                      xlink:href="Variablelists.html#VarListFormatting">Variable list formatting in HTML
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_list-presentation">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'list-presentation'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_list-width">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies the width of a variablelist or simplelist
        </refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml list-width</tag>
                PI as a child of a
                <tag>variablelist</tag>
                or a
                <tag>simplelist</tag>
                presented
                as a table, to specify the output width.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml list-width="<replaceable>width</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>list-width="<replaceable>width</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the output width (including units)</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg"
                      xlink:href="Variablelists.html#VarListFormatting">Variable list formatting in HTML
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_list-width">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'list-width'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_row-height">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies the height for a CALS table row</refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml row-height</tag>
                PI as a child of a
                <tag>row</tag>
                to specify the height of the row.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml row-height="<replaceable>height</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>row-height="<replaceable>height</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the row height (including units)</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="RowHeight.html">Row height
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_row-height">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'row-height'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_start">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">(obsolete) Sets the starting number on an ordered list
        </refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para><emphasis>This PI is obsolete</emphasis>. The intent of
                this PI was to provide a means for setting a specific starting
                number for an ordered list. Instead of this PI, set a value
                for the
                <literal>override</literal>
                attribute on the first
                <tag>listitem</tag>
                in the list; that will have the same
                effect as what this PI was intended for.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml start="<replaceable>character</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>start="<replaceable>character</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the character to use as the starting
                            number; use 0-9, a-z, A-Z, or lowercase or uppercase
                            Roman numerals
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Orderedlists.html#ListStartNum">
                    List starting number
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_start">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="pi-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'start'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_stop-chunking">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Do not chunk any descendants of this element.</refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>When generating chunked HTML output, adding this PI as the child of an element that contains elements
                that would normally be generated on separate pages if generating chunked output causes chunking to stop
                at this point. No descendants of the current element will be split into new HTML pages:
                <programlisting>&lt;section&gt;
                    &lt;title&gt;Configuring pencil&lt;/title&gt;
                    &lt;?dbhtml stop-chunking?&gt;

                    ...

                    &lt;/section&gt;</programlisting>
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml stop-chunking</tag>
            </synopsis>
        </refsynopsisdiv>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Chunking.html">Chunking into
                    multiple HTML files
                </link>
            </para>
        </refsee>
    </doc:pi>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_table-summary">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies summary for CALS table, variablelist, segmentedlist,
            or qandaset output
        </refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml table-summary</tag>
                PI as a child of
                a CALS<tag>table</tag>,<tag>variablelist</tag>,
                <tag>segmentedlist</tag>, or
                <tag>qandaset</tag>
                to specify
                the text for the HTML
                <literal>summary</literal>
                attribute
                in the output HTML table.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml table-summary="<replaceable>text</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>table-summary="<replaceable>text</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the summary text (zero or more characters)</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg"
                        xlink:href="Variablelists.html#VarListFormatting">Variable list formatting in HTML</link>,
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="TableSummary.html">Table summary
                    text
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_table-summary">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'table-summary'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_table-width">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies the width for a CALS table</refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml table-width</tag>
                PI as a child of a
                CALS
                <tag>table</tag>
                to specify the width of the table in
                output.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml table-width="<replaceable>width</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>table-width="<replaceable>width</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the table width (including units or as a percentage)</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
            <para>
                <parameter>default.table.width</parameter>
            </para>
        </refsee>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="Tables.html#TableWidth">Table
                    width
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_table-width">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'table-width'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_term-presentation">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Sets character formatting for terms in a variablelist
        </refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml term-presentation</tag>
                PI as a child
                of a
                <tag>variablelist</tag>
                to set character formatting for
                the
                <tag>term</tag>
                output of the list.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml term-presentation="bold"|"italic"|"bold-italic"</tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>term-presentation="<replaceable>bold</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies that terms are displayed in bold</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>term-presentation="<replaceable>italic</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies that terms are displayed in italic</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>term-presentation="<replaceable>bold-italic</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies that terms are displayed in bold-italic</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg"
                      xlink:href="Variablelists.html#VarListFormatting">Variable list formatting in HTML
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_term-presentation">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'term-presentation'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_term-separator">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies separator text among terms in a varlistentry
        </refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml term-separator</tag>
                PI as a child
                of a
                <tag>variablelist</tag>
                to specify the separator text
                among
                <tag>term</tag>
                instances.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml term-separator="<replaceable>text</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>term-separator="<replaceable>text</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the text (zero or more characters)</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="params">
            <para>
                <parameter>variablelist.term.separator</parameter>
            </para>
        </refsee>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg"
                      xlink:href="Variablelists.html#VarListFormatting">Variable list formatting in HTML
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_term-separator">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'term-separator'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_term-width">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies the term width for a variablelist</refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml term-width</tag>
                PI as a child of a
                <tag>variablelist</tag>
                to specify the width for
                <tag>term</tag>
                output.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml term-width="<replaceable>width</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>term-width="<replaceable>width</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies the term width (including units)</para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg"
                      xlink:href="Variablelists.html#VarListFormatting">Variable list formatting in HTML
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_term-width">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'term-width'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhtml_toc">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Specifies whether a TOC should be generated for a qandaset
        </refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhtml toc</tag>
                PI as a child of a
                <tag>qandaset</tag>
                to specify whether a table of contents
                (TOC) is generated for the<tag>qandaset</tag>.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhtml toc="0"|"1"</tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>toc="0"</term>
                    <listitem>
                        <para>If zero, no TOC is generated</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>toc="1"</term>
                    <listitem>
                        <para>If
                            <code>1</code>
                            (or any non-zero value),
                            a TOC is generated
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para><link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="QandAtoc.html">Q and A list of
                questions</link>,
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="QandAformat.html">Q and A
                    formatting
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="pi.dbhtml_toc">
        <xsl:param name="node" select="."/>
        <xsl:call-template name="dbhtml-attribute">
            <xsl:with-param name="pis" select="$node/processing-instruction('dbhtml')"/>
            <xsl:with-param name="attribute" select="'toc'"/>
        </xsl:call-template>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbcmdlist">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Generates a hyperlinked list of commands</refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbcmdlist</tag>
                PI as the child of any
                element (for example,<tag>refsynopsisdiv</tag>) containing multiple
                <tag>cmdsynopsis</tag>
                instances; a hyperlinked navigational
                “command list” will be generated at the top of output for that
                element, enabling users to quickly jump
                to each command synopsis.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbcmdlist</tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <para>[No parameters]</para>
        </refparameter>
    </doc:pi>
    <xsl:template name="pi.dbcmdlist">
        <xsl:variable name="cmdsynopses" select="..//cmdsynopsis"/>
        <xsl:if test="count($cmdsynopses)&lt;1">
            <xsl:message>
                <xsl:text>No cmdsynopsis elements matched dbcmdlist PI, perhaps it's nested too deep?</xsl:text>
            </xsl:message>
        </xsl:if>
        <dl>
            <xsl:call-template name="process.cmdsynopsis.list">
                <xsl:with-param name="cmdsynopses" select="$cmdsynopses"/>
            </xsl:call-template>
        </dl>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbfunclist">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Generates a hyperlinked list of functions</refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbfunclist</tag>
                PI as the child of any
                element (for example,<tag>refsynopsisdiv</tag>) containing multiple
                <tag>funcsynopsis</tag>
                instances; a hyperlinked
                navigational “function list” will be generated at the top of
                output for that element, enabling users to quickly
                jump to to each function synopsis.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbfunclist</tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <para>[No parameters]</para>
        </refparameter>
    </doc:pi>
    <xsl:template name="pi.dbfunclist">
        <xsl:variable name="funcsynopses" select="..//funcsynopsis"/>
        <xsl:if test="count($funcsynopses)&lt;1">
            <xsl:message>
                <xsl:text>No funcsynopsis elements matched dbfunclist PI, perhaps it's nested too deep?</xsl:text>
            </xsl:message>
        </xsl:if>
        <dl>
            <xsl:call-template name="process.funcsynopsis.list">
                <xsl:with-param name="funcsynopses" select="$funcsynopses"/>
            </xsl:call-template>
        </dl>
    </xsl:template>
    <doc:pi xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0" name="dbhh">
        <refpurpose xmlns="http://www.w3.org/1999/xhtml">Sets topic name and topic id for context-sensitive HTML Help
        </refpurpose>
        <refdescription xmlns="http://www.w3.org/1999/xhtml">
            <para>Use the
                <tag class="xmlpi">dbhh</tag>
                PI as a child of components
                that should be used as targets for context-sensitive help requests.
            </para>
        </refdescription>
        <refsynopsisdiv xmlns="http://www.w3.org/1999/xhtml">
            <synopsis>
                <tag class="xmlpi">dbhh topicname="<replaceable>name</replaceable>" topicid="<replaceable>
                    id</replaceable>"
                </tag>
            </synopsis>
        </refsynopsisdiv>
        <refparameter xmlns="http://www.w3.org/1999/xhtml">
            <variablelist>
                <varlistentry>
                    <term>topicname="<replaceable>name</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies a unique string constant that identifies a help topic</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>topicid="<replaceable>id</replaceable>"
                    </term>
                    <listitem>
                        <para>Specifies a unique integer value for the
                            <literal>topicname</literal>
                            string
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refparameter>
        <refsee xmlns="http://www.w3.org/1999/xhtml" role="tcg">
            <para>
                <link xmlns:xlink="http://www.w3.org/1999/xlink" role="tcg" xlink:href="HtmlHelp.html#HHContextHelp">
                    Context-sensitive help
                </link>
            </para>
        </refsee>
    </doc:pi>
    <xsl:template name="dbhtml-attribute">
        <!-- * dbhtml-attribute is an interal utility template for retrieving -->
        <!-- * pseudo-attributes/parameters from PIs -->
        <xsl:param name="pis" select="processing-instruction('dbhtml')"/>
        <xsl:param name="attribute">filename</xsl:param>
        <xsl:call-template name="pi-attribute">
            <xsl:with-param name="pis" select="$pis"/>
            <xsl:with-param name="attribute" select="$attribute"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="processing-instruction()">
    </xsl:template>
    <xsl:template match="processing-instruction('dbhtml')">
        <!-- nop -->
    </xsl:template>
    <xsl:template match="processing-instruction('dbcmdlist')">
        <xsl:call-template name="pi.dbcmdlist"/>
    </xsl:template>
    <xsl:template name="process.cmdsynopsis.list">
        <xsl:param name="cmdsynopses"/>
        <!-- empty node list by default -->
        <xsl:param name="count" select="1"/>

        <xsl:choose>
            <xsl:when test="$count&gt;count($cmdsynopses)"/>
            <xsl:otherwise>
                <xsl:variable name="cmdsyn" select="$cmdsynopses[$count]"/>

                <dt>
                    <a>
                        <xsl:attribute name="href">
                            <xsl:text>#</xsl:text>
                            <xsl:call-template name="object.id">
                                <xsl:with-param name="object" select="$cmdsyn"/>
                            </xsl:call-template>
                        </xsl:attribute>

                        <xsl:choose>
                            <xsl:when test="$cmdsyn/@xreflabel">
                                <xsl:call-template name="xref.xreflabel">
                                    <xsl:with-param name="target" select="$cmdsyn"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:apply-templates select="$cmdsyn" mode="xref-to">
                                    <xsl:with-param name="target" select="$cmdsyn"/>
                                </xsl:apply-templates>
                            </xsl:otherwise>
                        </xsl:choose>
                    </a>
                </dt>

                <xsl:call-template name="process.cmdsynopsis.list">
                    <xsl:with-param name="cmdsynopses" select="$cmdsynopses"/>
                    <xsl:with-param name="count" select="$count+1"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="processing-instruction('dbfunclist')">
        <xsl:call-template name="pi.dbfunclist"/>
    </xsl:template>
    <xsl:template name="process.funcsynopsis.list">
        <xsl:param name="funcsynopses"/>
        <!-- empty node list by default -->
        <xsl:param name="count" select="1"/>

        <xsl:choose>
            <xsl:when test="$count&gt;count($funcsynopses)"/>
            <xsl:otherwise>
                <xsl:variable name="cmdsyn" select="$funcsynopses[$count]"/>

                <dt>
                    <a>
                        <xsl:attribute name="href">
                            <xsl:text>#</xsl:text>
                            <xsl:call-template name="object.id">
                                <xsl:with-param name="object" select="$cmdsyn"/>
                            </xsl:call-template>
                        </xsl:attribute>

                        <xsl:choose>
                            <xsl:when test="$cmdsyn/@xreflabel">
                                <xsl:call-template name="xref.xreflabel">
                                    <xsl:with-param name="target" select="$cmdsyn"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:apply-templates select="$cmdsyn" mode="xref-to">
                                    <xsl:with-param name="target" select="$cmdsyn"/>
                                </xsl:apply-templates>
                            </xsl:otherwise>
                        </xsl:choose>
                    </a>
                </dt>

                <xsl:call-template name="process.funcsynopsis.list">
                    <xsl:with-param name="funcsynopses" select="$funcsynopses"/>
                    <xsl:with-param name="count" select="$count+1"/>
                </xsl:call-template>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="dbhtml-dir">
        <xsl:param name="context" select="."/>
        <!-- directories are now inherited from previous levels -->
        <xsl:variable name="ppath">
            <xsl:if test="$context/parent::*">
                <xsl:call-template name="dbhtml-dir">
                    <xsl:with-param name="context" select="$context/parent::*"/>
                </xsl:call-template>
            </xsl:if>
        </xsl:variable>
        <xsl:variable name="path">
            <xsl:call-template name="pi.dbhtml_dir">
                <xsl:with-param name="node" select="$context"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$path = ''">
                <xsl:if test="$ppath != ''">
                    <xsl:value-of select="$ppath"/>
                </xsl:if>
            </xsl:when>
            <xsl:otherwise>
                <xsl:if test="$ppath != ''">
                    <xsl:value-of select="$ppath"/>
                    <xsl:if test="substring($ppath, string-length($ppath), 1) != '/'">
                        <xsl:text>/</xsl:text>
                    </xsl:if>
                </xsl:if>
                <xsl:value-of select="$path"/>
                <xsl:text>/</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <doc:reference xmlns="" xmlns:doc="http://nwalsh.com/xsl/documentation/1.0">
        <referenceinfo xmlns="http://www.w3.org/1999/xhtml">
            <releaseinfo role="meta">
                $Id: ebnf.xsl 9664 2012-11-07 20:02:17Z bobstayton $
            </releaseinfo>
            <author>
                <surname>Walsh</surname>
                <firstname>Norman</firstname>
            </author>
            <copyright>
                <year>1999</year>
                <year>2000</year>
                <holder>Norman Walsh</holder>
            </copyright>
        </referenceinfo>
        <title xmlns="http://www.w3.org/1999/xhtml">HTML EBNF Reference</title>

        <partintro xmlns="http://www.w3.org/1999/xhtml">
            <section>
                <title>Introduction</title>

                <para>This is technical reference documentation for the DocBook XSL
                    Stylesheets; it documents (some of) the parameters, templates, and
                    other elements of the stylesheets.
                </para>

                <para>This reference describes the templates and parameters relevant
                    to formatting EBNF markup.
                </para>

                <para>This is not intended to be
                    <quote>user</quote>
                    documentation.
                    It is provided for developers writing customization layers for the
                    stylesheets, and for anyone who's interested in<quote>how it
                        works</quote>.
                </para>

                <para>Although I am trying to be thorough, this documentation is known
                    to be incomplete. Don't forget to read the source, too :-)
                </para>
            </section>
        </partintro>
    </doc:reference>
    <xsl:template match="productionset">
        <table width="100%" cellpadding="5">
            <xsl:if test="$ebnf.table.bgcolor != ''">
                <xsl:attribute name="bgcolor">
                    <xsl:value-of select="$ebnf.table.bgcolor"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:if test="$ebnf.table.border != 0">
                <xsl:attribute name="border">1</xsl:attribute>
            </xsl:if>
            <xsl:attribute name="class">
                <xsl:value-of select="$class.prefix"/>
                <xsl:value-of select="local-name(.)"/>
            </xsl:attribute>
            <xsl:attribute name="summary">
                <xsl:text>EBNF</xsl:text>
                <xsl:if test="title|info/title">
                    <xsl:text> for </xsl:text>
                    <xsl:value-of select="title|info/title[1]"/>
                </xsl:if>
            </xsl:attribute>

            <xsl:if test="title|info/title">
                <tr>
                    <th align="{$direction.align.start}" valign="top">
                        <xsl:apply-templates select="." mode="class.attribute"/>
                        <xsl:apply-templates select="title|info/title[1]"/>
                    </th>
                </tr>
            </xsl:if>
            <tr>
                <td>
                    <table border="0" width="99%" cellpadding="0">
                        <xsl:if test="$ebnf.table.bgcolor != ''">
                            <xsl:attribute name="bgcolor">
                                <xsl:value-of select="$ebnf.table.bgcolor"/>
                            </xsl:attribute>
                        </xsl:if>
                        <xsl:attribute name="class">
                            <xsl:value-of select="$class.prefix"/>
                            <xsl:value-of select="local-name(.)"/>
                        </xsl:attribute>
                        <xsl:attribute name="summary">EBNF productions</xsl:attribute>
                        <xsl:apply-templates select="production|productionrecap"/>
                    </table>
                </td>
            </tr>
        </table>
    </xsl:template>
    <xsl:template match="productionset/title">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="production">
        <xsl:param name="recap" select="false()"/>
        <tr>
            <td align="{$direction.align.start}" valign="top" width="3%">
                <xsl:text>[</xsl:text>
                <xsl:apply-templates select="." mode="label.markup"/>
                <xsl:text>]</xsl:text>
            </td>
            <td align="{$direction.align.end}" valign="top" width="10%">
                <xsl:choose>
                    <xsl:when test="$recap">
                        <a>
                            <xsl:attribute name="href">
                                <xsl:call-template name="href.target">
                                    <xsl:with-param name="object" select="."/>
                                </xsl:call-template>
                            </xsl:attribute>
                            <xsl:apply-templates select="lhs"/>
                        </a>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="id.attribute"/>
                        <xsl:call-template name="anchor"/>
                        <xsl:apply-templates select="lhs"/>
                    </xsl:otherwise>
                </xsl:choose>
            </td>
            <td valign="top" width="5%" align="center">
                <xsl:copy-of select="$ebnf.assignment"/>
            </td>
            <td valign="top" width="52%">
                <xsl:apply-templates select="rhs"/>
                <xsl:copy-of select="$ebnf.statement.terminator"/>
            </td>
            <td align="{$direction.align.start}" valign="top" width="30%">
                <xsl:choose>
                    <xsl:when test="rhs/lineannotation|constraint">
                        <xsl:apply-templates select="rhs/lineannotation" mode="rhslo"/>
                        <xsl:apply-templates select="constraint"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text> </xsl:text>
                    </xsl:otherwise>
                </xsl:choose>
            </td>
        </tr>
    </xsl:template>
    <xsl:template match="productionrecap">
        <xsl:variable name="targets" select="key('id',@linkend)"/>
        <xsl:variable name="target" select="$targets[1]"/>

        <xsl:if test="count($targets)=0">
            <xsl:message>
                <xsl:text>Error: no ID for productionrecap linkend: </xsl:text>
                <xsl:value-of select="@linkend"/>
                <xsl:text>.</xsl:text>
            </xsl:message>
        </xsl:if>

        <xsl:if test="count($targets)&gt;1">
            <xsl:message>
                <xsl:text>Warning: multiple "IDs" for productionrecap linkend: </xsl:text>
                <xsl:value-of select="@linkend"/>
                <xsl:text>.</xsl:text>
            </xsl:message>
        </xsl:if>

        <xsl:apply-templates select="$target">
            <xsl:with-param name="recap" select="true()"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="lhs">
        <xsl:apply-templates/>
    </xsl:template>
    <xsl:template match="rhs">
        <xsl:apply-templates/>
        <xsl:if test="following-sibling::rhs">
            <xsl:text> |</xsl:text>
            <br/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="nonterminal">
        <xsl:variable name="linkend">
            <xsl:call-template name="xpointer.idref">
                <xsl:with-param name="xpointer" select="@def"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:call-template name="check.id.unique">
            <xsl:with-param name="linkend" select="$linkend"/>
        </xsl:call-template>

        <xsl:call-template name="check.idref.targets">
            <xsl:with-param name="linkend" select="$linkend"/>
            <xsl:with-param name="element-list">production</xsl:with-param>
        </xsl:call-template>

        <!-- If you don't provide content, you can't point outside this doc. -->
        <xsl:choose>
            <xsl:when test="*|text()"><!--nop--></xsl:when>
            <xsl:otherwise>
                <xsl:if test="$linkend = ''">
                    <xsl:message>
                        <xsl:text>Non-terminals with no content must point to </xsl:text>
                        <xsl:text>production elements in the current document.</xsl:text>
                    </xsl:message>
                    <xsl:message>
                        <xsl:text>Invalid xpointer for empty nt: </xsl:text>
                        <xsl:value-of select="@def"/>
                    </xsl:message>
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose>

        <xsl:variable name="href">
            <xsl:choose>
                <xsl:when test="$linkend != ''">
                    <xsl:variable name="targets" select="key('id',$linkend)"/>
                    <xsl:variable name="target" select="$targets[1]"/>
                    <xsl:call-template name="href.target">
                        <xsl:with-param name="object" select="$target"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="@def"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <a href="{$href}">
            <xsl:choose>
                <xsl:when test="*|text()">
                    <xsl:apply-templates/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:choose>
                        <xsl:when test="$linkend != ''">
                            <xsl:variable name="targets" select="key('id',$linkend)"/>
                            <xsl:variable name="target" select="$targets[1]"/>
                            <xsl:apply-templates select="$target/lhs"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:text>???</xsl:text>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:otherwise>
            </xsl:choose>
        </a>
    </xsl:template>
    <xsl:template match="rhs/lineannotation">
        <!--nop-->
    </xsl:template>
    <xsl:template match="rhs/lineannotation" mode="rhslo">
        <xsl:text>/* </xsl:text>
        <xsl:apply-templates/>
        <xsl:text> */</xsl:text>
        <br/>
    </xsl:template>
    <xsl:template match="constraint">
        <xsl:call-template name="check.id.unique">
            <xsl:with-param name="linkend" select="@linkend"/>
        </xsl:call-template>

        <xsl:call-template name="check.idref.targets">
            <xsl:with-param name="linkend" select="@linkend"/>
            <xsl:with-param name="element-list">constraintdef</xsl:with-param>
        </xsl:call-template>

        <xsl:variable name="href">
            <xsl:variable name="targets" select="key('id',@linkend)"/>
            <xsl:variable name="target" select="$targets[1]"/>
            <xsl:call-template name="href.target">
                <xsl:with-param name="object" select="$target"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:text>[ </xsl:text>

        <xsl:choose>
            <xsl:when test="@role">
                <xsl:value-of select="@role"/>
                <xsl:text>: </xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="targets" select="key('id',@linkend)"/>
                <xsl:variable name="target" select="$targets[1]"/>
                <xsl:if test="$target/@role">
                    <xsl:value-of select="$target/@role"/>
                    <xsl:text>: </xsl:text>
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose>

        <a href="{$href}">
            <xsl:variable name="targets" select="key('id',@linkend)"/>
            <xsl:variable name="target" select="$targets[1]"/>
            <xsl:apply-templates select="$target" mode="title.markup"/>
        </a>
        <xsl:text> ]</xsl:text>
        <xsl:if test="following-sibling::constraint">
            <br/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="constraintdef">
        <div>
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:call-template name="id.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="constraintdef/title">
        <p>
            <strong>
                <xsl:apply-templates/>
            </strong>
        </p>
    </xsl:template>
    <xsl:param name="chunker.output.method" select="'xml'"/>
    <xsl:param name="chunker.output.encoding" select="'UTF-8'"/>
    <xsl:param name="chunker.output.indent" select="'no'"/>
    <xsl:param name="chunker.output.omit-xml-declaration" select="'no'"/>
    <xsl:param name="chunker.output.standalone" select="'no'"/>
    <xsl:param name="chunker.output.doctype-public" select="'-//W3C//DTD XHTML 1.0 Strict//EN'"/>
    <xsl:param name="chunker.output.doctype-system" select="'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'"/>
    <xsl:param name="chunker.output.media-type" select="''"/>
    <xsl:param name="chunker.output.cdata-section-elements" select="''"/>
    <xsl:param name="chunk.base.dir">
        <xsl:choose>
            <xsl:when test="string-length($base.dir) = 0"/>
            <!-- make sure to add trailing slash if omitted by user -->
            <xsl:when test="substring($base.dir, string-length($base.dir), 1) = '/'">
                <xsl:value-of select="$base.dir"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="concat($base.dir, '/')"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:param>
    <xsl:param name="saxon.character.representation" select="'entity;decimal'"/>
    <xsl:template name="make-relative-filename">
        <xsl:param name="base.dir" select="'./'"/>
        <xsl:param name="base.name" select="''"/>

        <xsl:choose>
            <!-- put Saxon first to work around a bug in libxslt -->
            <xsl:when test="element-available('saxon:output')">
                <!-- Saxon doesn't make the chunks relative -->
                <xsl:value-of select="concat($base.dir,$base.name)"/>
            </xsl:when>
            <xsl:when test="element-available('exsl:document')">
                <!-- EXSL document does make the chunks relative, I think -->
                <xsl:choose>
                    <xsl:when test="count(parent::*) = 0">
                        <xsl:value-of select="concat($base.dir,$base.name)"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$base.name"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:when test="element-available('redirect:write')">
                <!-- Xalan doesn't make the chunks relative -->
                <xsl:value-of select="concat($base.dir,$base.name)"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="yes">
                    <xsl:text>Don't know how to chunk with </xsl:text>
                    <xsl:value-of select="system-property('xsl:vendor')"/>
                </xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="write.chunk">
        <xsl:param name="filename" select="''"/>
        <xsl:param name="quiet" select="$chunk.quietly"/>
        <xsl:param name="suppress-context-node-name" select="0"/>
        <xsl:param name="message-prolog"/>
        <xsl:param name="message-epilog"/>

        <xsl:param name="method" select="$chunker.output.method"/>
        <xsl:param name="encoding" select="$chunker.output.encoding"/>
        <xsl:param name="indent" select="$chunker.output.indent"/>
        <xsl:param name="omit-xml-declaration" select="$chunker.output.omit-xml-declaration"/>
        <xsl:param name="standalone" select="$chunker.output.standalone"/>
        <xsl:param name="doctype-public" select="$chunker.output.doctype-public"/>
        <xsl:param name="doctype-system" select="$chunker.output.doctype-system"/>
        <xsl:param name="media-type" select="$chunker.output.media-type"/>
        <xsl:param name="cdata-section-elements" select="$chunker.output.cdata-section-elements"/>

        <xsl:param name="content"/>

        <xsl:if test="$quiet = 0">
            <xsl:message>
                <xsl:if test="not($message-prolog = '')">
                    <xsl:value-of select="$message-prolog"/>
                </xsl:if>
                <xsl:text>Writing </xsl:text>
                <xsl:value-of select="$filename"/>
                <xsl:if test="name(.) != '' and $suppress-context-node-name = 0">
                    <xsl:text> for </xsl:text>
                    <xsl:value-of select="name(.)"/>
                    <xsl:if test="@id or @xml:id">
                        <xsl:text>(</xsl:text>
                        <xsl:value-of select="(@id|@xml:id)[1]"/>
                        <xsl:text>)</xsl:text>
                    </xsl:if>
                </xsl:if>
                <xsl:if test="not($message-epilog = '')">
                    <xsl:value-of select="$message-epilog"/>
                </xsl:if>
            </xsl:message>
        </xsl:if>

        <xsl:choose>
            <xsl:when test="element-available('exsl:document')">
                <xsl:choose>
                    <!-- Handle the permutations ... -->
                    <xsl:when test="$media-type != ''">
                        <xsl:choose>
                            <xsl:when test="$doctype-public != '' and $doctype-system != ''">
                                <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}"
                                               indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                               cdata-section-elements="{$cdata-section-elements}"
                                               media-type="{$media-type}" doctype-public="{$doctype-public}"
                                               doctype-system="{$doctype-system}" standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </exsl:document>
                            </xsl:when>
                            <xsl:when test="$doctype-public != '' and $doctype-system = ''">
                                <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}"
                                               indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                               cdata-section-elements="{$cdata-section-elements}"
                                               media-type="{$media-type}" doctype-public="{$doctype-public}"
                                               standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </exsl:document>
                            </xsl:when>
                            <xsl:when test="$doctype-public = '' and $doctype-system != ''">
                                <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}"
                                               indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                               cdata-section-elements="{$cdata-section-elements}"
                                               media-type="{$media-type}" doctype-system="{$doctype-system}"
                                               standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </exsl:document>
                            </xsl:when>
                            <xsl:otherwise><!-- $doctype-public = '' and $doctype-system = ''"> -->
                                <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}"
                                               indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                               cdata-section-elements="{$cdata-section-elements}"
                                               media-type="{$media-type}" standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </exsl:document>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:choose>
                            <xsl:when test="$doctype-public != '' and $doctype-system != ''">
                                <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}"
                                               indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                               cdata-section-elements="{$cdata-section-elements}"
                                               doctype-public="{$doctype-public}" doctype-system="{$doctype-system}"
                                               standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </exsl:document>
                            </xsl:when>
                            <xsl:when test="$doctype-public != '' and $doctype-system = ''">
                                <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}"
                                               indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                               cdata-section-elements="{$cdata-section-elements}"
                                               doctype-public="{$doctype-public}" standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </exsl:document>
                            </xsl:when>
                            <xsl:when test="$doctype-public = '' and $doctype-system != ''">
                                <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}"
                                               indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                               cdata-section-elements="{$cdata-section-elements}"
                                               doctype-system="{$doctype-system}" standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </exsl:document>
                            </xsl:when>
                            <xsl:otherwise><!-- $doctype-public = '' and $doctype-system = ''"> -->
                                <exsl:document href="{$filename}" method="{$method}" encoding="{$encoding}"
                                               indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                               cdata-section-elements="{$cdata-section-elements}"
                                               standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </exsl:document>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>

            <xsl:when test="element-available('saxon:output')">
                <xsl:choose>
                    <!-- Handle the permutations ... -->
                    <xsl:when test="$media-type != ''">
                        <xsl:choose>
                            <xsl:when test="$doctype-public != '' and $doctype-system != ''">
                                <saxon:output xmlns:saxon="http://icl.com/saxon"
                                              saxon:character-representation="{$saxon.character.representation}"
                                              href="{$filename}" method="{$method}" encoding="{$encoding}"
                                              indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                              cdata-section-elements="{$cdata-section-elements}"
                                              media-type="{$media-type}" doctype-public="{$doctype-public}"
                                              doctype-system="{$doctype-system}" standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </saxon:output>
                            </xsl:when>
                            <xsl:when test="$doctype-public != '' and $doctype-system = ''">
                                <saxon:output xmlns:saxon="http://icl.com/saxon"
                                              saxon:character-representation="{$saxon.character.representation}"
                                              href="{$filename}" method="{$method}" encoding="{$encoding}"
                                              indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                              cdata-section-elements="{$cdata-section-elements}"
                                              media-type="{$media-type}" doctype-public="{$doctype-public}"
                                              standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </saxon:output>
                            </xsl:when>
                            <xsl:when test="$doctype-public = '' and $doctype-system != ''">
                                <saxon:output xmlns:saxon="http://icl.com/saxon"
                                              saxon:character-representation="{$saxon.character.representation}"
                                              href="{$filename}" method="{$method}" encoding="{$encoding}"
                                              indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                              cdata-section-elements="{$cdata-section-elements}"
                                              media-type="{$media-type}" doctype-system="{$doctype-system}"
                                              standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </saxon:output>
                            </xsl:when>
                            <xsl:otherwise><!-- $doctype-public = '' and $doctype-system = ''"> -->
                                <saxon:output xmlns:saxon="http://icl.com/saxon"
                                              saxon:character-representation="{$saxon.character.representation}"
                                              href="{$filename}" method="{$method}" encoding="{$encoding}"
                                              indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                              cdata-section-elements="{$cdata-section-elements}"
                                              media-type="{$media-type}" standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </saxon:output>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:choose>
                            <xsl:when test="$doctype-public != '' and $doctype-system != ''">
                                <saxon:output xmlns:saxon="http://icl.com/saxon"
                                              saxon:character-representation="{$saxon.character.representation}"
                                              href="{$filename}" method="{$method}" encoding="{$encoding}"
                                              indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                              cdata-section-elements="{$cdata-section-elements}"
                                              doctype-public="{$doctype-public}" doctype-system="{$doctype-system}"
                                              standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </saxon:output>
                            </xsl:when>
                            <xsl:when test="$doctype-public != '' and $doctype-system = ''">
                                <saxon:output xmlns:saxon="http://icl.com/saxon"
                                              saxon:character-representation="{$saxon.character.representation}"
                                              href="{$filename}" method="{$method}" encoding="{$encoding}"
                                              indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                              cdata-section-elements="{$cdata-section-elements}"
                                              doctype-public="{$doctype-public}" standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </saxon:output>
                            </xsl:when>
                            <xsl:when test="$doctype-public = '' and $doctype-system != ''">
                                <saxon:output xmlns:saxon="http://icl.com/saxon"
                                              saxon:character-representation="{$saxon.character.representation}"
                                              href="{$filename}" method="{$method}" encoding="{$encoding}"
                                              indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                              cdata-section-elements="{$cdata-section-elements}"
                                              doctype-system="{$doctype-system}" standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </saxon:output>
                            </xsl:when>
                            <xsl:otherwise><!-- $doctype-public = '' and $doctype-system = ''"> -->
                                <saxon:output xmlns:saxon="http://icl.com/saxon"
                                              saxon:character-representation="{$saxon.character.representation}"
                                              href="{$filename}" method="{$method}" encoding="{$encoding}"
                                              indent="{$indent}" omit-xml-declaration="{$omit-xml-declaration}"
                                              cdata-section-elements="{$cdata-section-elements}"
                                              standalone="{$standalone}">
                                    <xsl:copy-of select="$content"/>
                                </saxon:output>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>

            <xsl:when test="element-available('redirect:write')">
                <!-- Xalan uses redirect -->
                <redirect:write xmlns:redirect="http://xml.apache.org/xalan/redirect" file="{$filename}">
                    <xsl:copy-of select="$content"/>
                </redirect:write>
            </xsl:when>

            <xsl:otherwise>
                <!-- it doesn't matter since we won't be making chunks... -->
                <xsl:message terminate="yes">
                    <xsl:text>Can't make chunks with </xsl:text>
                    <xsl:value-of select="system-property('xsl:vendor')"/>
                    <xsl:text>'s processor.</xsl:text>
                </xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="write.chunk.with.doctype">
        <xsl:param name="filename" select="''"/>
        <xsl:param name="quiet" select="$chunk.quietly"/>

        <xsl:param name="method" select="$chunker.output.method"/>
        <xsl:param name="encoding" select="$chunker.output.encoding"/>
        <xsl:param name="indent" select="$chunker.output.indent"/>
        <xsl:param name="omit-xml-declaration" select="$chunker.output.omit-xml-declaration"/>
        <xsl:param name="standalone" select="$chunker.output.standalone"/>
        <xsl:param name="doctype-public" select="$chunker.output.doctype-public"/>
        <xsl:param name="doctype-system" select="$chunker.output.doctype-system"/>
        <xsl:param name="media-type" select="$chunker.output.media-type"/>
        <xsl:param name="cdata-section-elements" select="$chunker.output.cdata-section-elements"/>

        <xsl:param name="content"/>

        <xsl:call-template name="write.chunk">
            <xsl:with-param name="filename" select="$filename"/>
            <xsl:with-param name="quiet" select="$quiet"/>
            <xsl:with-param name="method" select="$method"/>
            <xsl:with-param name="encoding" select="$encoding"/>
            <xsl:with-param name="indent" select="$indent"/>
            <xsl:with-param name="omit-xml-declaration" select="$omit-xml-declaration"/>
            <xsl:with-param name="standalone" select="$standalone"/>
            <xsl:with-param name="doctype-public" select="$doctype-public"/>
            <xsl:with-param name="doctype-system" select="$doctype-system"/>
            <xsl:with-param name="media-type" select="$media-type"/>
            <xsl:with-param name="cdata-section-elements" select="$cdata-section-elements"/>
            <xsl:with-param name="content" select="$content"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="write.text.chunk">
        <xsl:param name="filename" select="''"/>
        <xsl:param name="quiet" select="$chunk.quietly"/>
        <xsl:param name="suppress-context-node-name" select="0"/>
        <xsl:param name="message-prolog"/>
        <xsl:param name="message-epilog"/>
        <xsl:param name="method" select="'text'"/>
        <xsl:param name="encoding" select="$chunker.output.encoding"/>
        <xsl:param name="media-type" select="$chunker.output.media-type"/>
        <xsl:param name="content"/>

        <xsl:call-template name="write.chunk">
            <xsl:with-param name="filename" select="$filename"/>
            <xsl:with-param name="quiet" select="$quiet"/>
            <xsl:with-param name="suppress-context-node-name" select="$suppress-context-node-name"/>
            <xsl:with-param name="message-prolog" select="$message-prolog"/>
            <xsl:with-param name="message-epilog" select="$message-epilog"/>
            <xsl:with-param name="method" select="$method"/>
            <xsl:with-param name="encoding" select="$encoding"/>
            <xsl:with-param name="indent" select="'no'"/>
            <xsl:with-param name="omit-xml-declaration" select="'yes'"/>
            <xsl:with-param name="standalone" select="'no'"/>
            <xsl:with-param name="doctype-public"/>
            <xsl:with-param name="doctype-system"/>
            <xsl:with-param name="media-type" select="$media-type"/>
            <xsl:with-param name="cdata-section-elements"/>
            <xsl:with-param name="content" select="$content"/>
        </xsl:call-template>
    </xsl:template>
    <xsl:template match="/" mode="insert.html.p">
        <xsl:param name="mark" select="'?'"/>
        <xsl:apply-templates mode="insert.html.p">
            <xsl:with-param name="mark" select="$mark"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="*" mode="insert.html.p">
        <xsl:param name="mark" select="'?'"/>
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:apply-templates mode="insert.html.p">
                <xsl:with-param name="mark" select="$mark"/>
            </xsl:apply-templates>
        </xsl:copy>
    </xsl:template>
    <xsl:template xmlns:html="http://www.w3.org/1999/xhtml" match="html:p|p" mode="insert.html.p">
        <xsl:param name="mark" select="'?'"/>
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:if test="not(preceding::p|preceding::html:p)">
                <xsl:copy-of select="$mark"/>
            </xsl:if>
            <xsl:apply-templates mode="insert.html.p">
                <xsl:with-param name="mark" select="$mark"/>
            </xsl:apply-templates>
        </xsl:copy>
    </xsl:template>
    <xsl:template match="text()|processing-instruction()|comment()" mode="insert.html.p">
        <xsl:param name="mark" select="'?'"/>
        <xsl:copy/>
    </xsl:template>
    <xsl:template match="/" mode="insert.html.text">
        <xsl:param name="mark" select="'?'"/>
        <xsl:apply-templates mode="insert.html.text">
            <xsl:with-param name="mark" select="$mark"/>
        </xsl:apply-templates>
    </xsl:template>
    <xsl:template match="*" mode="insert.html.text">
        <xsl:param name="mark" select="'?'"/>
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:apply-templates mode="insert.html.text">
                <xsl:with-param name="mark" select="$mark"/>
            </xsl:apply-templates>
        </xsl:copy>
    </xsl:template>
    <xsl:template match="text()|processing-instruction()|comment()" mode="insert.html.text">
        <xsl:param name="mark" select="'?'"/>

        <xsl:if test="not(preceding::text())">
            <xsl:copy-of select="$mark"/>
        </xsl:if>

        <xsl:copy/>
    </xsl:template>
    <xsl:template match="processing-instruction()|comment()" mode="insert.html.text">
        <xsl:param name="mark" select="'?'"/>
        <xsl:copy/>
    </xsl:template>
    <xsl:template name="unwrap.p">
        <xsl:param name="p"/>
        <xsl:choose>
            <xsl:when
                    test="$exsl.node.set.available != 0                     and function-available('set:leading')                     and function-available('set:trailing')">
                <xsl:apply-templates select="exsl:node-set($p)" mode="unwrap.p"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="$p"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template xmlns:html="http://www.w3.org/1999/xhtml" match="html:p|p" mode="unwrap.p">
        <!-- xmlns:html is necessary for the xhtml stylesheet case -->
        <xsl:variable name="blocks"
                      select="address|blockquote|div|hr|h1|h2|h3|h4|h5|h6                         |layer|p|pre|table|dl|menu|ol|ul|form                         |html:address|html:blockquote|html:div|html:hr                         |html:h1|html:h2|html:h3|html:h4|html:h5|html:h6                         |html:layer|html:p|html:pre|html:table|html:dl                         |html:menu|html:ol|html:ul|html:form"/>
        <xsl:choose>
            <xsl:when test="$blocks">
                <xsl:call-template name="unwrap.p.nodes">
                    <xsl:with-param name="wrap" select="."/>
                    <xsl:with-param name="first" select="1"/>
                    <xsl:with-param name="nodes" select="node()"/>
                    <xsl:with-param name="blocks" select="$blocks"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy>
                    <xsl:copy-of select="@*"/>
                    <xsl:apply-templates mode="unwrap.p"/>
                </xsl:copy>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*" mode="unwrap.p">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:apply-templates mode="unwrap.p"/>
        </xsl:copy>
    </xsl:template>
    <xsl:template match="text()|processing-instruction()|comment()" mode="unwrap.p">
        <xsl:copy/>
    </xsl:template>
    <xsl:template name="unwrap.p.nodes">
        <xsl:param name="wrap" select="."/>
        <xsl:param name="first" select="0"/>
        <xsl:param name="nodes"/>
        <xsl:param name="blocks"/>
        <xsl:variable name="block" select="$blocks[1]"/>

        <!-- This template should never get called if these functions aren't available -->
        <!-- but this test is still necessary so that processors don't choke on the -->
        <!-- function calls if they don't support the set: functions -->
        <xsl:if test="function-available('set:leading')                 and function-available('set:trailing')">
            <xsl:choose>
                <xsl:when test="$blocks">
                    <xsl:variable name="leading" select="set:leading($nodes,$block)"/>
                    <xsl:variable name="trailing" select="set:trailing($nodes,$block)"/>

                    <xsl:if test="(($wrap/@id or $wrap/@xml:id)                          and $first = 1) or $leading">
                        <xsl:element name="{local-name($wrap)}" namespace="http://www.w3.org/1999/xhtml">
                            <xsl:for-each select="$wrap/@*">
                                <xsl:if test="$first != 0 or local-name(.) != 'id'">
                                    <xsl:copy/>
                                </xsl:if>
                            </xsl:for-each>
                            <xsl:apply-templates select="$leading" mode="unwrap.p"/>
                        </xsl:element>
                    </xsl:if>

                    <xsl:apply-templates select="$block" mode="unwrap.p"/>

                    <xsl:if test="$trailing">
                        <xsl:call-template name="unwrap.p.nodes">
                            <xsl:with-param name="wrap" select="$wrap"/>
                            <xsl:with-param name="nodes" select="$trailing"/>
                            <xsl:with-param name="blocks" select="$blocks[position() &gt; 1]"/>
                        </xsl:call-template>
                    </xsl:if>
                </xsl:when>

                <xsl:otherwise>
                    <xsl:if test="(($wrap/@id or $wrap/@xml:id) and $first = 1) or $nodes">
                        <xsl:element name="{local-name($wrap)}" namespace="http://www.w3.org/1999/xhtml">
                            <xsl:for-each select="$wrap/@*">
                                <xsl:if test="$first != 0 or local-name(.) != 'id'">
                                    <xsl:copy/>
                                </xsl:if>
                            </xsl:for-each>
                            <xsl:apply-templates select="$nodes" mode="unwrap.p"/>
                        </xsl:element>
                    </xsl:if>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:if>
    </xsl:template>
    <xsl:template match="/" mode="make.verbatim.mode">
        <xsl:apply-templates mode="make.verbatim.mode"/>
    </xsl:template>
    <xsl:template match="*" mode="make.verbatim.mode">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:apply-templates mode="make.verbatim.mode"/>
        </xsl:copy>
    </xsl:template>
    <xsl:template match="processing-instruction()|comment()" mode="make.verbatim.mode">
        <xsl:copy/>
    </xsl:template>
    <xsl:template match="text()" mode="make.verbatim.mode">
        <xsl:variable name="text" select="translate(., ' ', '&#xA0;')"/>

        <xsl:choose>
            <xsl:when test="not(contains($text, '&#10;'))">
                <xsl:value-of select="$text"/>
            </xsl:when>

            <xsl:otherwise>
                <xsl:variable name="len" select="string-length($text)"/>

                <xsl:choose>
                    <xsl:when test="$len = 1">
                        <br/><xsl:text>
</xsl:text>
                    </xsl:when>

                    <xsl:otherwise>
                        <xsl:variable name="half" select="$len div 2"/>
                        <xsl:call-template name="make-verbatim-recursive">
                            <xsl:with-param name="text" select="substring($text, 1, $half)"/>
                        </xsl:call-template>
                        <xsl:call-template name="make-verbatim-recursive">
                            <xsl:with-param name="text" select="substring($text, ($half + 1), $len)"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="make-verbatim-recursive">
        <xsl:param name="text" select="''"/>

        <xsl:choose>
            <xsl:when test="not(contains($text, '&#10;'))">
                <xsl:value-of select="$text"/>
            </xsl:when>

            <xsl:otherwise>
                <xsl:variable name="len" select="string-length($text)"/>

                <xsl:choose>
                    <xsl:when test="$len = 1">
                        <br/><xsl:text>
</xsl:text>
                    </xsl:when>

                    <xsl:otherwise>
                        <xsl:variable name="half" select="$len div 2"/>
                        <xsl:call-template name="make-verbatim-recursive">
                            <xsl:with-param name="text" select="substring($text, 1, $half)"/>
                        </xsl:call-template>
                        <xsl:call-template name="make-verbatim-recursive">
                            <xsl:with-param name="text" select="substring($text, ($half + 1), $len)"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="remove.empty.div">
        <xsl:param name="div"/>
        <xsl:choose>
            <xsl:when test="$exsl.node.set.available != 0">
                <xsl:apply-templates select="exsl:node-set($div)" mode="remove.empty.div"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="$div"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template xmlns:html="http://www.w3.org/1999/xhtml" match="html:p|p|html:div|div" mode="remove.empty.div">
        <xsl:if test="node()">
            <xsl:copy>
                <xsl:copy-of select="@*"/>
                <xsl:apply-templates mode="remove.empty.div"/>
            </xsl:copy>
        </xsl:if>
    </xsl:template>
    <xsl:template match="*" mode="remove.empty.div">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:apply-templates mode="remove.empty.div"/>
        </xsl:copy>
    </xsl:template>
    <xsl:template match="text()|processing-instruction()|comment()" mode="remove.empty.div">
        <xsl:copy/>
    </xsl:template>
    <xsl:template name="add.annotation.links">
        <xsl:param name="scripts" select="normalize-space($annotation.js)"/>
        <xsl:choose>
            <xsl:when test="contains($scripts, ' ')">
                <script type="text/javascript" src="{substring-before($scripts, ' ')}"/>
                <xsl:call-template name="add.annotation.links">
                    <xsl:with-param name="scripts" select="substring-after($scripts, ' ')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <script type="text/javascript" src="{$scripts}"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="annotation"/>
    <xsl:template name="apply-annotations">
        <xsl:if test="$annotation.support != 0">
            <!-- do any annotations apply to the context node? -->
            <xsl:variable name="id" select="(@id|@xml:id)[1]"/>

            <xsl:variable name="aids">
                <xsl:for-each select="//annotation">
                    <xsl:if test="@annotates=$id                     or starts-with(@annotates, concat($id, ' '))                     or contains(@annotates, concat(' ', $id, ' '))                     or substring(@annotates, string-length(@annotates)-3)                        = concat(' ', $id)">
                        <xsl:value-of select="generate-id()"/>
                        <xsl:text> </xsl:text>
                    </xsl:if>
                </xsl:for-each>
                <xsl:if test="normalize-space(@annotations) != ''">
                    <xsl:call-template name="annotations-pointed-to">
                        <xsl:with-param name="annotations" select="normalize-space(@annotations)"/>
                    </xsl:call-template>
                </xsl:if>
            </xsl:variable>

            <xsl:if test="$aids != ''">
                <xsl:call-template name="apply-annotations-by-gid">
                    <xsl:with-param name="gids" select="normalize-space($aids)"/>
                </xsl:call-template>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    <xsl:template name="annotations-pointed-to">
        <xsl:param name="annotations"/>
        <xsl:choose>
            <xsl:when test="contains($annotations, ' ')">
                <xsl:variable name="a" select="key('id', substring-before($annotations, ' '))"/>
                <xsl:if test="$a">
                    <xsl:value-of select="generate-id($a)"/>
                    <xsl:text> </xsl:text>
                </xsl:if>
                <xsl:call-template name="annotations-pointed-to">
                    <xsl:with-param name="annotations" select="substring-after($annotations, ' ')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="a" select="key('id', $annotations)"/>
                <xsl:if test="$a">
                    <xsl:value-of select="generate-id($a)"/>
                    <xsl:text> </xsl:text>
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="apply-annotations-by-gid">
        <xsl:param name="gids"/>

        <xsl:choose>
            <xsl:when test="contains($gids, ' ')">
                <xsl:variable name="gid" select="substring-before($gids, ' ')"/>
                <xsl:apply-templates select="key('gid', $gid)" mode="annotation-inline"/>
                <xsl:call-template name="apply-annotations-by-gid">
                    <xsl:with-param name="gids" select="substring-after($gids, ' ')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="key('gid', $gids)" mode="annotation-inline"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="annotation" mode="annotation-inline">
        <xsl:variable name="title">
            <xsl:choose>
                <xsl:when test="title">
                    <xsl:value-of select="title"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>[Annotation #</xsl:text>
                    <xsl:number count="annotation" level="any" format="1"/>
                    <xsl:text>]</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <a id="anch-{generate-id(.)}" href="#annot-{generate-id(.)}" title="{$title}">
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:attribute name="onClick">
                <xsl:text>popup_</xsl:text>
                <xsl:value-of select="generate-id(.)"/>
                <xsl:text>.showPopup('anch-</xsl:text>
                <xsl:value-of select="generate-id(.)"/>
                <xsl:text>'); return false;</xsl:text>
            </xsl:attribute>
            <img src="{$annotation.graphic.open}" border="0" alt="{$title}"/>
        </a>
    </xsl:template>
    <xsl:template match="annotation" mode="annotation-popup">
        <div class="{$class.prefix}annotation-nocss">
            <p>
                <a id="annot-{generate-id(.)}"/>
                <xsl:text>Annotation #</xsl:text>
                <xsl:number count="annotation" level="any" format="1"/>
                <xsl:text>:</xsl:text>
            </p>
        </div>

        <div id="popup-{generate-id(.)}" class="{$class.prefix}annotation-popup">
            <xsl:if test="string-length(.) &gt; 300">
                <xsl:attribute name="style">width:400px</xsl:attribute>
            </xsl:if>

            <xsl:call-template name="annotation-title"/>
            <div class="{$class.prefix}annotation-body">
                <xsl:apply-templates select="*[local-name(.) != 'title']"/>
            </div>
            <div class="{$class.prefix}annotation-close">
                <a href="#" onclick="popup_{generate-id(.)}.hidePopup();return false;">
                    <xsl:apply-templates select="." mode="class.attribute"/>
                    <img src="{$annotation.graphic.close}" alt="X" border="0"/>
                </a>
            </div>
        </div>
    </xsl:template>
    <xsl:template name="annotation-title">
        <div class="{$class.prefix}annotation-title">
            <xsl:choose>
                <xsl:when test="title">
                    <xsl:apply-templates select="title/node()"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:text>Annotation</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </div>
    </xsl:template>
    <xsl:template match="/*" mode="stripNS">
        <xsl:choose>
            <xsl:when test="self::ng:* or self::db:*">
                <xsl:element name="{local-name(.)}">
                    <xsl:copy-of
                            select="@*[not(name(.) = 'xml:id')                                 and not(name(.) = 'version')]"/>
                    <xsl:if test="@xml:id">
                        <xsl:attribute name="id">
                            <xsl:value-of select="@xml:id"/>
                        </xsl:attribute>
                    </xsl:if>

                    <xsl:call-template name="add-xml-base"/>

                    <xsl:apply-templates mode="stripNS"/>
                </xsl:element>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy>
                    <xsl:copy-of
                            select="@*[not(name(.) = 'xml:id')                                 and not(name(.) = 'version')]"/>
                    <xsl:if test="@xml:id">
                        <xsl:attribute name="id">
                            <xsl:value-of select="@xml:id"/>
                        </xsl:attribute>
                    </xsl:if>

                    <xsl:call-template name="add-xml-base"/>

                    <xsl:apply-templates mode="stripNS"/>
                </xsl:copy>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*" mode="stripNS">
        <xsl:choose>
            <xsl:when test="self::ng:* or self::db:*">
                <xsl:element name="{local-name(.)}">
                    <xsl:copy-of
                            select="@*[not(name(.) = 'xml:id')                                 and not(name(.) = 'version')]"/>
                    <xsl:if test="@xml:id">
                        <xsl:attribute name="id">
                            <xsl:value-of select="@xml:id"/>
                        </xsl:attribute>
                    </xsl:if>
                    <xsl:apply-templates mode="stripNS"/>
                </xsl:element>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy>
                    <xsl:copy-of
                            select="@*[not(name(.) = 'xml:id')                                 and not(name(.) = 'version')]"/>
                    <xsl:if test="@xml:id">
                        <xsl:attribute name="id">
                            <xsl:value-of select="@xml:id"/>
                        </xsl:attribute>
                    </xsl:if>
                    <xsl:apply-templates mode="stripNS"/>
                </xsl:copy>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="db:info" mode="stripNS">
        <xsl:variable name="info">
            <xsl:choose>
                <xsl:when
                        test="parent::db:article                       |parent::db:appendix                       |parent::db:bibliography                       |parent::db:book                       |parent::db:chapter                       |parent::db:glossary                       |parent::db:index                       |parent::db:part                       |parent::db:preface                       |parent::db:refentry                       |parent::db:reference                       |parent::db:refsect1                       |parent::db:refsect2                       |parent::db:refsect3                       |parent::db:refsection                       |parent::db:refsynopsisdiv                       |parent::db:sect1                       |parent::db:sect2                       |parent::db:sect3                       |parent::db:sect4                       |parent::db:sect5                       |parent::db:section                       |parent::db:setindex                       |parent::db:set                       |parent::db:slides                       |parent::db:sidebar">
                    <xsl:value-of select="local-name(parent::*)"/>
                    <xsl:text>info</xsl:text>
                </xsl:when>
                <xsl:when
                        test="parent::db:audioobject                       |parent::db:imageobject                       |parent::db:inlinemediaobject                       |parent::db:mediaobject                       |parent::db:mediaobjectco                       |parent::db:textobject                       |parent::db:videoobject">
                    <xsl:text>objectinfo</xsl:text>
                </xsl:when>
                <xsl:otherwise>blockinfo</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:element name="{$info}">
            <xsl:copy-of select="@*[not(name(.) = 'xml:id')                          and not(name(.) = 'version')]"/>
            <xsl:if test="@xml:id">
                <xsl:attribute name="id">
                    <xsl:value-of select="@xml:id"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:apply-templates mode="stripNS"/>
        </xsl:element>

        <xsl:if test="(not(../db:title) and not(../ng:title))                 and ($info = 'prefaceinfo'                      or $info = 'chapterinfo'                      or $info = 'sectioninfo'                      or $info = 'sect1info'                      or $info = 'sect2info'                      or $info = 'sect3info'                      or $info = 'sect4info'                      or $info = 'sect5info'                      or $info = 'refsectioninfo'                      or $info = 'refsect1info'                      or $info = 'refsect2info'                      or $info = 'refsect3info'                      or $info = 'blockinfo'                      or $info = 'appendixinfo')">
            <xsl:apply-templates select="db:title|ng:title" mode="stripNS"/>
        </xsl:if>

    </xsl:template>
    <xsl:template match="ng:tag|db:tag" mode="stripNS">
        <xsl:choose>
            <xsl:when test="@xlink:href">
                <ulink xmlns="" url="{@xlink:href}">
                    <sgmltag>
                        <xsl:copy-of
                                select="@*[not(name(.) = 'xml:id')           and not(name(.) = 'version')           and not(local-name(.) = 'href')]"/>
                        <xsl:if test="@xml:id">
                            <xsl:attribute name="id">
                                <xsl:value-of select="@xml:id"/>
                            </xsl:attribute>
                        </xsl:if>
                        <xsl:apply-templates mode="stripNS"/>
                    </sgmltag>
                </ulink>
            </xsl:when>
            <xsl:otherwise>
                <sgmltag xmlns="">
                    <xsl:copy-of
                            select="@*[not(name(.) = 'xml:id')                                 and not(name(.) = 'version')]"/>
                    <xsl:if test="@xml:id">
                        <xsl:attribute name="id">
                            <xsl:value-of select="@xml:id"/>
                        </xsl:attribute>
                    </xsl:if>
                    <xsl:apply-templates mode="stripNS"/>
                </sgmltag>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="db:link[@xlink:href]" mode="stripNS">
        <ulink xmlns="" url="{@xlink:href}">
            <xsl:if test="@role">
                <xsl:attribute name="role">
                    <xsl:value-of select="@role"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:apply-templates mode="stripNS"/>
        </ulink>
    </xsl:template>
    <xsl:template match="db:citetitle[@xlink:href]" mode="stripNS">
        <ulink xmlns="" url="{@xlink:href}">
            <citetitle>
                <xsl:copy-of
                        select="@*[not(name(.) = 'xml:id')       and not(name(.) = 'version')       and not(local-name(.) = 'href')]"/>
                <xsl:if test="@xml:id">
                    <xsl:attribute name="id">
                        <xsl:value-of select="@xml:id"/>
                    </xsl:attribute>
                </xsl:if>
                <xsl:apply-templates mode="stripNS"/>
            </citetitle>
        </ulink>
    </xsl:template>
    <xsl:template match="db:citetitle[@linkend]" mode="stripNS">
        <citetitle xmlns="">
            <xsl:copy-of
                    select="@*[not(name(.) = 'xml:id')     and not(name(.) = 'version')     and not(name(.) = 'linkend')     and not(local-name(.) = 'href')]"/>
            <xsl:if test="@xml:id">
                <xsl:attribute name="id">
                    <xsl:value-of select="@xml:id"/>
                </xsl:attribute>
            </xsl:if>
            <xsl:apply-templates mode="stripNS"/>
        </citetitle>
    </xsl:template>
    <xsl:template match="db:alt" mode="stripNS"/>
    <xsl:template
            match="ng:textdata|db:textdata                      |ng:imagedata|db:imagedata                      |ng:videodata|db:videodata                      |ng:audiodata|db:audiodata"
            mode="stripNS">
        <xsl:element name="{local-name(.)}">
            <xsl:copy-of
                    select="@*[not(name(.) = 'xml:id')                             and not(name(.) = 'version')                             and not(name(.) = 'entityref')]"/>
            <xsl:if test="@xml:id">
                <xsl:attribute name="id">
                    <xsl:value-of select="@xml:id"/>
                </xsl:attribute>
            </xsl:if>

            <xsl:choose>
                <xsl:when test="@entityref">
                    <xsl:attribute name="fileref">
                        <xsl:value-of select="unparsed-entity-uri(@entityref)"/>
                    </xsl:attribute>
                </xsl:when>
            </xsl:choose>

            <xsl:apply-templates mode="stripNS"/>
        </xsl:element>
    </xsl:template>
    <xsl:template name="add-xml-base">
        <xsl:if test="not(@xml:base)">
            <xsl:variable name="base">
                <xsl:choose>
                    <xsl:when test="function-available('saxon:systemId')">
                        <xsl:value-of select="saxon:systemId()"/>
                    </xsl:when>
                    <xsl:when test="function-available('NodeInfo:systemId')">
                        <xsl:value-of select="NodeInfo:systemId()"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message>
                            <xsl:text>WARNING: cannot add @xml:base to node </xsl:text>
                            <xsl:text>set root element.  </xsl:text>
                            <xsl:text>Relative paths may not work.</xsl:text>
                        </xsl:message>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <!-- debug
    <xsl:message>base is <xsl:value-of select="$base"/></xsl:message>
    -->
            <xsl:if test="$base != ''">
                <xsl:attribute name="xml:base">
                    <xsl:call-template name="systemIdToBaseURI">
                        <xsl:with-param name="systemId">
                            <!-- file: seems to confuse some processors. -->
                            <xsl:choose>
                                <!-- however, windows paths must use file:///c:/path -->
                                <xsl:when
                                        test="starts-with($base, 'file:///') and                               substring($base, 10, 1) = ':'">
                                    <xsl:value-of select="$base"/>
                                </xsl:when>
                                <xsl:when
                                        test="starts-with($base, 'file:/')                               and substring($base, 8, 1) = ':'">
                                    <xsl:value-of
                                            select="concat('file:///',                                        substring-after($base,'file:/'))"/>
                                </xsl:when>
                                <xsl:when test="starts-with($base, 'file:///')">
                                    <xsl:value-of select="substring-after($base,'file://')"/>
                                </xsl:when>
                                <xsl:when test="starts-with($base, 'file://')">
                                    <xsl:value-of select="substring-after($base,'file:/')"/>
                                </xsl:when>
                                <xsl:when test="starts-with($base, 'file:/')">
                                    <xsl:value-of select="substring-after($base,'file:')"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:value-of select="$base"/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:with-param>
                    </xsl:call-template>
                </xsl:attribute>
            </xsl:if>
        </xsl:if>
    </xsl:template>
    <xsl:template name="systemIdToBaseURI">
        <xsl:param name="systemId" select="''"/>
        <xsl:if test="contains($systemId,'/')">
            <xsl:value-of select="substring-before($systemId,'/')"/>
            <xsl:text>/</xsl:text>
            <xsl:call-template name="systemIdToBaseURI">
                <xsl:with-param name="systemId" select="substring-after($systemId,'/')"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>
    <xsl:template match="comment()|processing-instruction()|text()" mode="stripNS">
        <xsl:copy/>
    </xsl:template>
    <xsl:template match="/" priority="-1">
        <!-- need a local version of this variable because this module imported many places-->
        <xsl:variable name="local.exsl.node.set.available">
            <xsl:choose>
                <xsl:when exsl:foo=""
                          test="function-available('exsl:node-set') or                          contains(system-property('xsl:vendor'),                            'Apache Software Foundation')">
                    1
                </xsl:when>
                <xsl:otherwise>0</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="$local.exsl.node.set.available != 0                     and (*/self::ng:* or */self::db:*)">
                <xsl:message>
                    <xsl:text>Stripping namespace from DocBook 5 document. </xsl:text>
                    <xsl:text>It is suggested to use namespaced version of the stylesheets </xsl:text>
                    <xsl:text>available in distribution file 'docbook-xsl-ns' </xsl:text>
                    <xsl:text>at //http://sourceforge.net/projects/docbook/files/</xsl:text>
                    <xsl:text> which does not require namespace stripping step.</xsl:text>
                </xsl:message>
                <xsl:variable name="nons">
                    <xsl:apply-templates mode="stripNS"/>
                </xsl:variable>
                <xsl:message>Processing stripped document.</xsl:message>
                <xsl:apply-templates select="exsl:node-set($nons)"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="node()"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:param name="stylesheet.result.type" select="'xhtml'"/>
    <xsl:param name="htmlhelp.output" select="0"/>

    <!-- ================================== -->

    <xsl:key name="id" match="*" use="@id|@xml:id"/>
    <xsl:key name="gid" match="*" use="generate-id()"/>

    <!-- ================================== -->

    <xsl:template match="*">
        <xsl:message>
            <xsl:text>Element </xsl:text>
            <xsl:value-of select="local-name(.)"/>
            <xsl:text> in namespace '</xsl:text>
            <xsl:value-of select="namespace-uri(.)"/>
            <xsl:text>' encountered</xsl:text>
            <xsl:if test="parent::*">
                <xsl:text> in </xsl:text>
                <xsl:value-of select="name(parent::*)"/>
            </xsl:if>
            <xsl:text>, but no template matches.</xsl:text>
        </xsl:message>

        <span style="color: red">
            <xsl:text>&lt;</xsl:text>
            <xsl:value-of select="name(.)"/>
            <xsl:text>&gt;</xsl:text>
            <xsl:apply-templates/>
            <xsl:text>&lt;/</xsl:text>
            <xsl:value-of select="name(.)"/>
            <xsl:text>&gt;</xsl:text>
        </span>
    </xsl:template>

    <xsl:template match="text()">
        <xsl:value-of select="."/>
    </xsl:template>
    <xsl:template name="head.content.base">
        <xsl:param name="node" select="."/>
        <base href="{$html.base}"/>
    </xsl:template>

    <xsl:template name="head.content.abstract">
        <xsl:param name="node" select="."/>
        <xsl:variable name="info"
                      select="(articleinfo     |bookinfo     |prefaceinfo     |chapterinfo     |appendixinfo     |sectioninfo     |sect1info     |sect2info     |sect3info     |sect4info     |sect5info     |referenceinfo     |refentryinfo     |partinfo     |info     |docinfo)[1]"/>
        <xsl:if test="$info and $info/abstract">
            <meta name="description">
                <xsl:attribute name="content">
                    <xsl:for-each select="$info/abstract[1]/*">
                        <xsl:value-of select="normalize-space(.)"/>
                        <xsl:if test="position() &lt; last()">
                            <xsl:text> </xsl:text>
                        </xsl:if>
                    </xsl:for-each>
                </xsl:attribute>
            </meta>
        </xsl:if>
    </xsl:template>

    <xsl:template name="head.content.link.made">
        <xsl:param name="node" select="."/>

        <link rev="made" href="{$link.mailto.url}"/>
    </xsl:template>

    <xsl:template name="head.content.generator">
        <xsl:param name="node" select="."/>
        <meta name="generator" content="DocBook {$DistroTitle} V{$VERSION}"/>
    </xsl:template>

    <xsl:template name="head.content.style">
        <xsl:param name="node" select="."/>
        <style type="text/css"><xsl:text>
body { background-image: url('</xsl:text>
            <xsl:value-of select="$draft.watermark.image"/><xsl:text>');
       background-repeat: no-repeat;
       background-position: top left;
       /* The following properties make the watermark "fixed" on the page. */
       /* I think that's just a bit too distracting for the reader... */
       /* background-attachment: fixed; */
       /* background-position: center center; */
     }</xsl:text>
        </style>
    </xsl:template>
    <xsl:template name="output.html.stylesheets">
        <xsl:param name="stylesheets" select="''"/>

        <xsl:choose>
            <xsl:when test="contains($stylesheets, ' ')">
                <xsl:variable name="css.filename" select="substring-before($stylesheets, ' ')"/>

                <xsl:call-template name="make.css.link">
                    <xsl:with-param name="css.filename" select="$css.filename"/>
                </xsl:call-template>

                <xsl:call-template name="output.html.stylesheets">
                    <xsl:with-param name="stylesheets" select="substring-after($stylesheets, ' ')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="$stylesheets != ''">
                <xsl:call-template name="make.css.link">
                    <xsl:with-param name="css.filename" select="$stylesheets"/>
                </xsl:call-template>
            </xsl:when>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="output.html.scripts">
        <xsl:param name="scripts" select="''"/>

        <xsl:choose>
            <xsl:when test="contains($scripts, ' ')">
                <xsl:variable name="script.filename" select="substring-before($scripts, ' ')"/>

                <xsl:call-template name="make.script.link">
                    <xsl:with-param name="script.filename" select="$script.filename"/>
                </xsl:call-template>

                <xsl:call-template name="output.html.scripts">
                    <xsl:with-param name="scripts" select="substring-after($scripts, ' ')"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:when test="$scripts != ''">
                <xsl:call-template name="make.script.link">
                    <xsl:with-param name="script.filename" select="$scripts"/>
                </xsl:call-template>
            </xsl:when>
        </xsl:choose>
    </xsl:template>

    <!-- ============================== -->

    <xsl:template match="*" mode="head.keywords.content">
        <xsl:apply-templates select="chapterinfo/keywordset" mode="html.header"/>
        <xsl:apply-templates select="appendixinfo/keywordset" mode="html.header"/>
        <xsl:apply-templates select="prefaceinfo/keywordset" mode="html.header"/>
        <xsl:apply-templates select="bookinfo/keywordset" mode="html.header"/>
        <xsl:apply-templates select="setinfo/keywordset" mode="html.header"/>
        <xsl:apply-templates select="articleinfo/keywordset" mode="html.header"/>
        <xsl:apply-templates select="artheader/keywordset" mode="html.header"/>
        <xsl:apply-templates select="sect1info/keywordset" mode="html.header"/>
        <xsl:apply-templates select="sect2info/keywordset" mode="html.header"/>
        <xsl:apply-templates select="sect3info/keywordset" mode="html.header"/>
        <xsl:apply-templates select="sect4info/keywordset" mode="html.header"/>
        <xsl:apply-templates select="sect5info/keywordset" mode="html.header"/>
        <xsl:apply-templates select="sectioninfo/keywordset" mode="html.header"/>
        <xsl:apply-templates select="refsect1info/keywordset" mode="html.header"/>
        <xsl:apply-templates select="refsect2info/keywordset" mode="html.header"/>
        <xsl:apply-templates select="refsect3info/keywordset" mode="html.header"/>
        <xsl:apply-templates select="bibliographyinfo/keywordset" mode="html.header"/>
        <xsl:apply-templates select="glossaryinfo/keywordset" mode="html.header"/>
        <xsl:apply-templates select="indexinfo/keywordset" mode="html.header"/>
        <xsl:apply-templates select="refentryinfo/keywordset" mode="html.header"/>
        <xsl:apply-templates select="partinfo/keywordset" mode="html.header"/>
        <xsl:apply-templates select="referenceinfo/keywordset" mode="html.header"/>
        <xsl:apply-templates select="docinfo/keywordset" mode="html.header"/>
        <xsl:apply-templates select="info/keywordset" mode="html.header"/>

        <xsl:if test="$inherit.keywords != 0                 and parent::*">
            <xsl:apply-templates select="parent::*" mode="head.keywords.content"/>
        </xsl:if>
    </xsl:template>

    <!-- ============================== -->

    <xsl:template name="system.head.content">
        <xsl:param name="node" select="."/>

        <!-- FIXME: When chunking, only the annotations actually used
              in this chunk should be referenced. I don't think it
              does any harm to reference them all, but it adds
              unnecessary bloat to each chunk. -->
        <xsl:if test="$annotation.support != 0 and //annotation">
            <xsl:call-template name="add.annotation.links"/>
            <script type="text/javascript">
      <xsl:text>
// Create PopupWindow objects</xsl:text>
                <xsl:for-each select="//annotation">
        <xsl:text>
var popup_</xsl:text>
                    <xsl:value-of select="generate-id(.)"/>
                    <xsl:text> = new PopupWindow("popup-</xsl:text>
                    <xsl:value-of select="generate-id(.)"/>
        <xsl:text>");
</xsl:text>
                    <xsl:text>popup_</xsl:text>
                    <xsl:value-of select="generate-id(.)"/>
        <xsl:text>.offsetY = 15;
</xsl:text>
                    <xsl:text>popup_</xsl:text>
                    <xsl:value-of select="generate-id(.)"/>
        <xsl:text>.autoHide();
</xsl:text>
                </xsl:for-each>
            </script>

            <style type="text/css">
                <xsl:value-of select="$annotation.css"/>
            </style>
        </xsl:if>

        <!-- system.head.content is like user.head.content, except that
       it is called before head.content. This is important because it
       means, for example, that <style> elements output by system.head.content
       have a lower CSS precedence than the users stylesheet. -->
    </xsl:template>

    <!-- ============================== -->

    <xsl:template name="user.preroot">
        <!-- Pre-root output, can be used to output comments and PIs. -->
        <!-- This must not output any element content! -->
    </xsl:template>

    <xsl:template name="user.head.title">
        <xsl:param name="node" select="."/>
        <xsl:param name="title"/>

        <title>
            <xsl:copy-of select="$title"/>
        </title>
    </xsl:template>

    <xsl:template name="user.head.content">
        <xsl:param name="node" select="."/>
    </xsl:template>

    <xsl:template name="user.header.navigation">
        <xsl:param name="node" select="."/>
        <xsl:param name="prev" select="/foo"/>
        <xsl:param name="next" select="/foo"/>
        <xsl:param name="nav.context"/>
    </xsl:template>

    <xsl:template name="user.header.content">
        <xsl:param name="node" select="."/>
    </xsl:template>

    <xsl:template name="user.footer.navigation">
        <xsl:param name="node" select="."/>
        <xsl:param name="prev" select="/foo"/>
        <xsl:param name="next" select="/foo"/>
        <xsl:param name="nav.context"/>
    </xsl:template>

    <!-- To use the same stripped nodeset everywhere, it should
be created as a global variable here.
Used by docbook.xsl, chunk-code.xsl and chunkfast.xsl -->
    <xsl:variable name="no.namespace">
        <xsl:if test="$exsl.node.set.available != 0                     and (*/self::ng:* or */self::db:*)">
            <xsl:apply-templates select="/*" mode="stripNS"/>
        </xsl:if>
    </xsl:variable>

    <xsl:template match="/">
        <!-- * Get a title for current doc so that we let the user -->
        <!-- * know what document we are processing at this point. -->
        <xsl:variable name="doc.title">
            <xsl:call-template name="get.doc.title"/>
        </xsl:variable>
        <xsl:choose>
            <!-- Hack! If someone hands us a DocBook V5.x or DocBook NG document,
         toss the namespace and continue.  Use the docbook5 namespaced
         stylesheets for DocBook5 if you don't want to use this feature.-->
            <!-- include extra test for Xalan quirk -->
            <xsl:when test="$exsl.node.set.available != 0                     and (*/self::ng:* or */self::db:*)">
                <xsl:call-template name="log.message">
                    <xsl:with-param name="level">Note</xsl:with-param>
                    <xsl:with-param name="source" select="$doc.title"/>
                    <xsl:with-param name="context-desc">
                        <xsl:text>namesp. cut</xsl:text>
                    </xsl:with-param>
                    <xsl:with-param name="message">
                        <xsl:text>stripped namespace before processing</xsl:text>
                    </xsl:with-param>
                </xsl:call-template>
                <!-- DEBUG: to save stripped document.
      <xsl:message>Saving stripped document.</xsl:message>
      <xsl:call-template name="write.chunk">
        <xsl:with-param name="filename" select="'/tmp/stripped.xml'"/>
        <xsl:with-param name="method" select="'xml'"/>
        <xsl:with-param name="content">
          <xsl:copy-of select="exsl:node-set($no.namespace)"/>
        </xsl:with-param>
      </xsl:call-template>
      -->
                <xsl:call-template name="log.message">
                    <xsl:with-param name="level">Note</xsl:with-param>
                    <xsl:with-param name="source" select="$doc.title"/>
                    <xsl:with-param name="context-desc">
                        <xsl:text>namesp. cut</xsl:text>
                    </xsl:with-param>
                    <xsl:with-param name="message">
                        <xsl:text>processing stripped document</xsl:text>
                    </xsl:with-param>
                </xsl:call-template>
                <xsl:apply-templates select="exsl:node-set($no.namespace)"/>
            </xsl:when>
            <!-- Can't process unless namespace removed -->
            <xsl:when test="*/self::ng:* or */self::db:*">
                <xsl:message terminate="yes">
                    <xsl:text>Unable to strip the namespace from DB5 document,</xsl:text>
                    <xsl:text> cannot proceed.</xsl:text>
                </xsl:message>
            </xsl:when>
            <xsl:otherwise>
                <xsl:choose>
                    <xsl:when test="$rootid != ''">
                        <xsl:choose>
                            <xsl:when test="count(key('id',$rootid)) = 0">
                                <xsl:message terminate="yes">
                                    <xsl:text>ID '</xsl:text>
                                    <xsl:value-of select="$rootid"/>
                                    <xsl:text>' not found in document.</xsl:text>
                                </xsl:message>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:if test="$collect.xref.targets = 'yes' or                             $collect.xref.targets = 'only'">
                                    <xsl:apply-templates select="key('id', $rootid)" mode="collect.targets"/>
                                </xsl:if>
                                <xsl:if test="$collect.xref.targets != 'only'">
                                    <xsl:apply-templates select="key('id',$rootid)" mode="process.root"/>
                                    <xsl:if test="$tex.math.in.alt != ''">
                                        <xsl:apply-templates select="key('id',$rootid)" mode="collect.tex.math"/>
                                    </xsl:if>
                                </xsl:if>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:if test="$collect.xref.targets = 'yes' or                         $collect.xref.targets = 'only'">
                            <xsl:apply-templates select="/" mode="collect.targets"/>
                        </xsl:if>
                        <xsl:if test="$collect.xref.targets != 'only'">
                            <xsl:apply-templates select="/" mode="process.root"/>
                            <xsl:if test="$tex.math.in.alt != ''">
                                <xsl:apply-templates select="/" mode="collect.tex.math"/>
                            </xsl:if>
                        </xsl:if>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="root.attributes">
        <!-- customize to add attributes to <html> element  -->
    </xsl:template>
    <xsl:template name="root.messages">
        <!-- redefine this any way you'd like to output messages -->
        <!-- DO NOT OUTPUT ANYTHING FROM THIS TEMPLATE -->
    </xsl:template>

    <!-- ================================== -->

    <xsl:template name="chunk">
        <xsl:param name="node" select="."/>

        <!-- The default is that we are not chunking... -->
        <xsl:text>0</xsl:text>
    </xsl:template>

    <!-- publican templates -->
    <xsl:template name="language.to.xslthl">
        <xsl:param name="context"/>

        <xsl:choose>
            <xsl:when test="$context/@language != ''">
                <xsl:value-of select="$context/@language"/>
            </xsl:when>
            <xsl:when test="$highlight.default.language != ''">
                <xsl:value-of select="$highlight.default.language"/>
            </xsl:when>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="apply-highlighting">
        <xsl:choose>
            <!-- Do we want syntax highlighting -->
            <xsl:when test="$highlight.source != 0 and function-available('perl:highlight')">
                <xsl:variable name="language">
                    <xsl:call-template name="language.to.xslthl">
                        <xsl:with-param name="context" select="."/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:choose>
                    <xsl:when test="$language != ''">
                        <xsl:variable name="content">
                            <xsl:apply-templates/>
                        </xsl:variable>
                        <xsl:apply-templates select="perl:highlight($language, exsl:node-set($content))"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <!-- No syntax highlighting -->
            <xsl:otherwise>
                <xsl:apply-templates/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="graphical.admonition">
        <xsl:variable name="admon.type">
            <xsl:choose>
                <xsl:when test="local-name(.)='note'">Note</xsl:when>
                <xsl:when test="local-name(.)='warning'">Warning</xsl:when>
                <xsl:when test="local-name(.)='important'">Important</xsl:when>
                <xsl:otherwise>Note</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="alt">
            <xsl:call-template name="gentext">
                <xsl:with-param name="key" select="$admon.type"/>
            </xsl:call-template>
        </xsl:variable>

        <div>
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:if test="$admon.style != ''">
                <xsl:attribute name="style">
                    <xsl:value-of select="$admon.style"/>
                </xsl:attribute>
            </xsl:if>

            <xsl:call-template name="common.html.attributes"/>
            <xsl:if test="$admon.textlabel != 0 or title">
                <div class="{$class.prefix}admonition_header">
                    <p>
                        <strong>
                            <xsl:apply-templates select="." mode="object.title.markup"/>
                        </strong>
                    </p>
                </div>
            </xsl:if>
            <div class="{$class.prefix}admonition">
                <xsl:apply-templates/>
            </div>
        </div>
    </xsl:template>
    <xsl:template match="substeps">
        <xsl:variable name="numeration">
            <xsl:call-template name="procedure.step.numeration"/>
        </xsl:variable>
        <ol class="{$class.prefix}{$numeration}">
            <xsl:call-template name="anchor"/>
            <xsl:apply-templates/>
        </ol>
    </xsl:template>
    <xsl:template match="orderedlist">
        <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:if test="title">
                <xsl:call-template name="formal.object.heading"/>
            </xsl:if>
            <!-- Preserve order of PIs and comments -->
            <xsl:apply-templates
                    select="*[not(self::listitem or self::title or self::titleabbrev)] |                                       comment()[not(preceding-sibling::listitem)] |            processing-instruction()[not(preceding-sibling::listitem)]"/>
            <ol>
                <xsl:if test="@role">
                    <xsl:apply-templates select="." mode="class.attribute">
                        <xsl:with-param name="class" select="@role"/>
                    </xsl:apply-templates>
                </xsl:if>
                <xsl:if test="@numeration">
                    <xsl:apply-templates select="." mode="class.attribute">
                        <xsl:with-param name="class" select="@numeration"/>
                    </xsl:apply-templates>
                </xsl:if>
                <xsl:apply-templates
                        select="listitem | comment()[preceding-sibling::listitem] | processing-instruction()[preceding-sibling::listitem]"/>
            </ol>
        </div>
    </xsl:template>
    <xsl:template match="procedure">
        <xsl:variable name="param.placement"
                      select="substring-after(normalize-space($formal.title.placement), concat(local-name(.), ' '))"/>

        <xsl:variable name="placement">
            <xsl:choose>
                <xsl:when test="contains($param.placement, ' ')">
                    <xsl:value-of select="substring-before($param.placement, ' ')"/>
                </xsl:when>
                <xsl:when test="$param.placement = ''">before</xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$param.placement"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <!-- Preserve order of PIs and comments -->
        <xsl:variable name="preamble"
                      select="*[not(self::step or self::title or self::titleabbrev)] |comment()[not(preceding-sibling::step)] |processing-instruction()[not(preceding-sibling::step)]"/>
        <div>
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:call-template name="anchor">
                <xsl:with-param name="conditional">
                    <xsl:choose>
                        <xsl:when test="title">0</xsl:when>
                        <xsl:otherwise>1</xsl:otherwise>
                    </xsl:choose>
                </xsl:with-param>
            </xsl:call-template>
            <xsl:if test="title and $placement = 'before'">
                <xsl:call-template name="formal.object.heading"/>
            </xsl:if>
            <xsl:apply-templates select="$preamble"/>
            <xsl:choose>
                <xsl:when test="count(step) = 1">
                    <ul>
                        <xsl:apply-templates
                                select="step |comment()[preceding-sibling::step] |processing-instruction()[preceding-sibling::step]"/>
                    </ul>
                </xsl:when>
                <xsl:otherwise>
                    <ol>
                        <xsl:attribute name="class">
                            <xsl:value-of select="$class.prefix"/>
                            <xsl:value-of select="substring($procedure.step.numeration.formats,1,1)"/>
                        </xsl:attribute>
                        <xsl:apply-templates
                                select="step |comment()[preceding-sibling::step] |processing-instruction()[preceding-sibling::step]"/>
                    </ol>
                </xsl:otherwise>
            </xsl:choose>
            <xsl:if test="title and $placement != 'before'">
                <xsl:call-template name="formal.object.heading"/>
            </xsl:if>
        </div>
    </xsl:template>
    <xsl:template name="longdesc.link">
        <xsl:param name="longdesc.uri" select="''"/>

        <xsl:variable name="this.uri">
            <xsl:call-template name="make-relative-filename">
                <xsl:with-param name="base.dir" select="$base.dir"/>
                <xsl:with-param name="base.name">
                    <xsl:call-template name="href.target.uri"/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="href.to">
            <xsl:call-template name="trim.common.uri.paths">
                <xsl:with-param name="uriA" select="$longdesc.uri"/>
                <xsl:with-param name="uriB" select="$this.uri"/>
                <xsl:with-param name="return" select="'A'"/>
            </xsl:call-template>
        </xsl:variable>
        <div class="{$class.prefix}longdesc-link">
            <br/>
            <span class="{$class.prefix}longdesc-link">
                <xsl:text>[</xsl:text>
                <a href="{$href.to}">D</a>
                <xsl:text>]</xsl:text>
            </span>
        </div>
    </xsl:template>

    <xsl:template name="head.content">
        <xsl:param name="node" select="."/>
        <xsl:param name="title">
            <xsl:apply-templates select="$node" mode="object.title.markup.textonly"/>
        </xsl:param>

        <title>
            <xsl:copy-of select="$title"/>
        </title>

        <xsl:if test="$html.stylesheet != ''">
            <xsl:call-template name="output.html.stylesheets">
                <xsl:with-param name="stylesheets" select="normalize-space($html.stylesheet)"/>
            </xsl:call-template>
        </xsl:if>
        <xsl:if test="$html.stylesheet.print != ''">
            <link rel="stylesheet" media="print">
                <xsl:attribute name="href">
                    <xsl:value-of select="$html.stylesheet.print"/>
                </xsl:attribute>
                <xsl:if test="$html.stylesheet.type != ''">
                    <xsl:attribute name="type">
                        <xsl:value-of select="$html.stylesheet.type"/>
                    </xsl:attribute>
                </xsl:if>
            </link>
        </xsl:if>

        <xsl:if test="$link.mailto.url != ''">
            <link rev="made" href="{$link.mailto.url}"/>
        </xsl:if>

        <xsl:if test="$html.base != ''">
            <base href="{$html.base}"/>
        </xsl:if>

        <meta name="generator">
            <xsl:attribute name="content">
                <xsl:text>publican </xsl:text><xsl:value-of select="$publican.version"/>
            </xsl:attribute>
        </meta>

        <meta name="package">
            <xsl:attribute name="content">
                <xsl:copy-of select="$package"/>
            </xsl:attribute>
        </meta>
        <xsl:if test="$generate.meta.abstract != 0">
            <xsl:variable name="info"
                          select="(articleinfo |bookinfo |prefaceinfo |chapterinfo |appendixinfo |sectioninfo |sect1info |sect2info |sect3info |sect4info |sect5info |referenceinfo |refentryinfo |partinfo |info |docinfo)[1]"/>
            <xsl:if test="$info and $info/abstract">
                <meta name="description">
                    <xsl:attribute name="content">
                        <xsl:for-each select="$info/abstract[1]/*">
                            <xsl:value-of select="normalize-space(.)"/>
                            <xsl:if test="position() &lt; last()">
                                <xsl:text> </xsl:text>
                            </xsl:if>
                        </xsl:for-each>
                    </xsl:attribute>
                </meta>
            </xsl:if>
        </xsl:if>
        <xsl:if test="$embedtoc != 0 ">
            <link rel="stylesheet" type="text/css">
                <xsl:attribute name="href"><xsl:value-of select="$tocpath"/>/../common/<xsl:value-of
                        select="$langpath"/>/css/menu.css
                </xsl:attribute>
            </link>
            <link rel="stylesheet" type="text/css">
                <xsl:attribute name="href"><xsl:value-of select="$tocpath"/>/../menu.css
                </xsl:attribute>
            </link>
            <link rel="stylesheet" type="text/css">
                <xsl:attribute name="href"><xsl:value-of select="$tocpath"/>/../print.css
                </xsl:attribute>
                <xsl:attribute name="media">print</xsl:attribute>
            </link>
            <xsl:if test="$brand != 'common'">
                <link rel="stylesheet" type="text/css">
                    <xsl:attribute name="href"><xsl:value-of select="$tocpath"/>/../<xsl:value-of
                            select="$brand"/>/<xsl:value-of select="$langpath"/>/css/menu.css
                    </xsl:attribute>
                </link>
            </xsl:if>
            <script type="text/javascript">
                <xsl:attribute name="src"><xsl:value-of select="$tocpath"/>/../jquery-1.7.1.min.js
                </xsl:attribute>
            </script>
            <script type="text/javascript">
                <xsl:attribute name="src"><xsl:value-of select="$tocpath"/>/labels.js
                </xsl:attribute>
            </script>
            <script type="text/javascript">
                <xsl:attribute name="src"><xsl:value-of select="$tocpath"/>/../toc.js
                </xsl:attribute>
            </script>
            <script type="text/javascript">
                <xsl:if test="$web.type = ''">
                    current_book = '<xsl:copy-of select="$pop_name"/>';
                    current_version = '<xsl:copy-of select="$pop_ver"/>';
                    current_product = '<xsl:copy-of select="$pop_prod"/>';
                </xsl:if>
                <xsl:if test="$web.type != ''">
                    current_book = '';
                    current_version = '';
                </xsl:if>
                toc_path = '<xsl:value-of select="$tocpath"/>';
                loadMenu();
            </script>
        </xsl:if>

        <xsl:apply-templates select="." mode="head.keywords.content"/>
    </xsl:template>
    <xsl:template name="body.attributes">
        <xsl:if test="starts-with($writing.mode, 'rl')">
            <xsl:attribute name="dir">rtl</xsl:attribute>
        </xsl:if>
        <xsl:variable name="class">
            <xsl:if test="($draft.mode = 'yes' or ($draft.mode = 'maybe' and (ancestor-or-self::set | ancestor-or-self::book | ancestor-or-self::article)[1]/@status = 'draft'))">
                <xsl:value-of select="ancestor-or-self::*[@status][1]/@status"/><xsl:text> </xsl:text>
            </xsl:if>
            <xsl:if test="$embedtoc != 0">
                <xsl:text>toc_embeded </xsl:text>
            </xsl:if>
            <xsl:if test="$desktop != 0">
                <xsl:text>desktop </xsl:text>
            </xsl:if>
        </xsl:variable>
        <xsl:if test="$class != ''">
            <xsl:attribute name="class">
                <xsl:value-of select="$class.prefix"/>
                <xsl:value-of select="$class"/>
            </xsl:attribute>
        </xsl:if>
    </xsl:template>
    <xsl:template name="user.footer.content">
        <xsl:param name="node" select="."/>
        <xsl:if test="$confidential = '1'">
            <div class="{$class.prefix}confidential">
                <xsl:value-of select="$confidential.text"/>
            </div>
        </xsl:if>
        <xsl:if test="$embedtoc != 0">
            <div id="site_footer"/>
            <script type="text/javascript">
                $("#site_footer").load("<xsl:value-of select="$tocpath"/>/../footer.html");
            </script>
        </xsl:if>
    </xsl:template>
    <xsl:template match="formalpara">
        <xsl:call-template name="paragraph">
            <xsl:with-param name="class">
                <xsl:choose>
                    <xsl:when test="@role and $para.propagates.style != 0">
                        <xsl:value-of select="@role"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:text>formalpara</xsl:text>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:with-param>
            <xsl:with-param name="content">
                <xsl:apply-templates/>
            </xsl:with-param>
        </xsl:call-template>
        <!--xsl:apply-templates/-->
    </xsl:template>
    <xsl:template match="formalpara/title|formalpara/info/title">
        <xsl:variable name="titleStr">
            <xsl:apply-templates/>
        </xsl:variable>
        <div class="{$class.prefix}title">
            <xsl:copy-of select="$titleStr"/>
        </div>
    </xsl:template>
    <xsl:template match="itemizedlist">
        <div>
            <xsl:call-template name="common.html.attributes"/>
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:call-template name="anchor"/>
            <xsl:if test="title">
                <xsl:call-template name="formal.object.heading"/>
            </xsl:if>

            <!-- Preserve order of PIs and comments -->
            <xsl:apply-templates
                    select="*[not(self::listitem or self::title or self::titleabbrev)] |           comment()[not(preceding-sibling::listitem)] |           processing-instruction()[not(preceding-sibling::listitem)]"/>
            <ul>
                <xsl:if test="@role">
                    <xsl:apply-templates select="." mode="class.attribute">
                        <xsl:with-param name="class" select="@role"/>
                    </xsl:apply-templates>
                </xsl:if>
                <xsl:if test="$css.decoration != 0">
                    <xsl:attribute name="type">
                        <xsl:call-template name="list.itemsymbol"/>
                    </xsl:attribute>
                </xsl:if>

                <xsl:if test="@spacing='compact'">
                    <xsl:attribute name="compact">
                        <xsl:value-of select="@spacing"/>
                    </xsl:attribute>
                </xsl:if>
                <xsl:apply-templates
                        select="listitem | comment()[preceding-sibling::listitem] | processing-instruction()[preceding-sibling::listitem]"/>
            </ul>
        </div>
    </xsl:template>
    <xsl:template match="ulink" name="ulink">
        <xsl:param name="url" select="@url"/>
        <xsl:variable name="link">
            <a>
                <xsl:if test="@id or @xml:id">
                    <xsl:attribute name="id">
                        <xsl:value-of select="(@id|@xml:id)[1]"/>
                    </xsl:attribute>
                </xsl:if>
                <xsl:attribute name="href">
                    <xsl:value-of select="$url"/>
                </xsl:attribute>
                <xsl:if test="$ulink.target != ''">
                    <xsl:attribute name="target">
                        <xsl:value-of select="$ulink.target"/>
                    </xsl:attribute>
                </xsl:if>
                <xsl:if test="@role">
                    <xsl:apply-templates select="." mode="class.attribute">
                        <xsl:with-param name="class" select="@role"/>
                    </xsl:apply-templates>
                </xsl:if>
                <xsl:choose>
                    <xsl:when test="count(child::node())=0">
                        <xsl:value-of select="$url"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:apply-templates/>
                    </xsl:otherwise>
                </xsl:choose>
            </a>
        </xsl:variable>
        <xsl:copy-of select="$link"/>
    </xsl:template>
    <xsl:template match="*" mode="class.attribute">
        <xsl:param name="class" select="local-name(.)"/>
        <!-- permit customization of class attributes -->
        <!-- Use element name by default -->
        <xsl:attribute name="class">
            <!--xsl:value-of select="$class"/-->
            <xsl:apply-templates select="." mode="class.value">
                <xsl:with-param name="class" select="$class"/>
            </xsl:apply-templates>
            <xsl:if test="@role">
                <xsl:text> </xsl:text>
                <xsl:value-of select="@role"/>
            </xsl:if>
        </xsl:attribute>
    </xsl:template>
    <xsl:template match="imagedata">
        <xsl:variable name="filename">
            <xsl:call-template name="mediaobject.filename">
                <xsl:with-param name="object" select=".."/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="@format='linespecific'">
                <xsl:choose>
                    <xsl:when test="$use.extensions != '0'                         and $textinsert.extension != '0'">
                        <xsl:choose>
                            <xsl:when test="element-available('stext:insertfile')">
                                <stext:insertfile xmlns:stext="http://nwalsh.com/xslt/ext/com.nwalsh.saxon.TextFactory"
                                                  href="{$filename}" encoding="{$textdata.default.encoding}"/>
                            </xsl:when>
                            <xsl:when test="element-available('xtext:insertfile')">
                                <xtext:insertfile xmlns:xtext="xalan://com.nwalsh.xalan.Text" href="{$filename}"/>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message terminate="yes">
                                    <xsl:text>No insertfile extension available.</xsl:text>
                                </xsl:message>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:type="simple" xlink:show="embed"
                           xlink:actuate="onLoad" href="{$filename}"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:variable name="longdesc.uri">
                    <xsl:call-template name="longdesc.uri">
                        <xsl:with-param name="mediaobject" select="ancestor::imageobject/parent::*"/>
                    </xsl:call-template>
                </xsl:variable>

                <xsl:variable name="phrases"
                              select="ancestor::mediaobject/textobject[phrase]                             |ancestor::inlinemediaobject/textobject[phrase]                             |ancestor::mediaobjectco/textobject[phrase]"/>

                <xsl:call-template name="process.image">
                    <xsl:with-param name="alt">
                        <xsl:apply-templates select="$phrases[not(@role) or @role!='tex'][1]"/>
                    </xsl:with-param>
                    <xsl:with-param name="longdesc">
                        <xsl:call-template name="write.longdesc">
                            <xsl:with-param name="mediaobject" select="ancestor::imageobject/parent::*"/>
                        </xsl:call-template>
                    </xsl:with-param>
                </xsl:call-template>

                <xsl:if test="$html.longdesc != 0 and $html.longdesc.link != 0                     and ancestor::imageobject/parent::*/textobject[not(phrase)]">
                    <xsl:call-template name="longdesc.link">
                        <xsl:with-param name="longdesc.uri" select="$longdesc.uri"/>
                    </xsl:call-template>
                </xsl:if>
                <xsl:if test="$html.longdesc.embed != 0 and ancestor::imageobject/parent::*/textobject[not(phrase)]">
                    <div class="{$class.prefix}longdesc">
                        <xsl:for-each select="ancestor::imageobject/parent::*/textobject[not(phrase)]">
                            <xsl:apply-templates select="./*"/>
                        </xsl:for-each>
                    </div>
                </xsl:if>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="qandaset">
        <div class="{$class.prefix}qandaset">
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template name="process.qandaset">
        <div class="{$class.prefix}qandaset">
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="qandadiv">
        <xsl:variable name="preamble"
                      select="*[local-name(.) != 'title'                                           and local-name(.) != 'titleabbrev'                                           and local-name(.) != 'qandadiv'                                           and local-name(.) != 'qandaentry']"/>

        <xsl:if test="blockinfo/title|info/title|title">
            <div class="{$class.prefix}qandadiv">
                <xsl:apply-templates select="(blockinfo/title|info/title|title)[1]"/>
            </div>
        </xsl:if>

        <xsl:variable name="toc">
            <xsl:call-template name="dbhtml-attribute">
                <xsl:with-param name="pis" select="processing-instruction('dbhtml')"/>
                <xsl:with-param name="attribute" select="'toc'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="toc.params">
            <xsl:call-template name="find.path.params">
                <xsl:with-param name="table" select="normalize-space($generate.toc)"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:if test="(contains($toc.params, 'toc') and $toc != '0') or $toc = '1'">
            <div class="{$class.prefix}toc">
                <xsl:call-template name="process.qanda.toc"/>
            </div>
        </xsl:if>
        <xsl:if test="$preamble">
            <div class="{$class.prefix}preamble">
                <xsl:apply-templates select="$preamble"/>
            </div>
        </xsl:if>
        <div>
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:apply-templates select="qandadiv|qandaentry"/>
        </div>
    </xsl:template>
    <xsl:template match="qandaentry">
        <div>
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="question">
        <xsl:variable name="deflabel">
            <xsl:choose>
                <xsl:when test="ancestor-or-self::*[@defaultlabel]">
                    <xsl:value-of select="(ancestor-or-self::*[@defaultlabel])[last()] /@defaultlabel"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$qanda.defaultlabel"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        <xsl:variable name="label.content">
            <xsl:apply-templates select="." mode="label.markup"/>
            <xsl:if test="$deflabel = 'number' and not(label)">
                <xsl:apply-templates select="." mode="intralabel.punctuation"/>
            </xsl:if>
        </xsl:variable>
        <div>
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:call-template name="anchor">
                <xsl:with-param name="node" select=".."/>
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
            <!--xsl:call-template name="anchor">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template-->
            <xsl:if test="string-length($label.content) &gt; 0">
                <div class="{$class.prefix}label">
                    <xsl:copy-of select="$label.content"/>
                </div>
            </xsl:if>
            <div class="{$class.prefix}data">
                <xsl:apply-templates/>
            </div>
        </div>
    </xsl:template>
    <xsl:template match="answer">
        <xsl:variable name="deflabel">
            <xsl:choose>
                <xsl:when test="ancestor-or-self::*[@defaultlabel]">
                    <xsl:value-of select="(ancestor-or-self::*[@defaultlabel])[last()] /@defaultlabel"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$qanda.defaultlabel"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <div>
            <xsl:apply-templates select="." mode="class.attribute"/>
            <xsl:variable name="answer.label">
                <xsl:apply-templates select="." mode="label.markup"/>
            </xsl:variable>
            <xsl:if test="string-length($answer.label) &gt; 0">
                <div class="{$class.prefix}label">
                    <xsl:copy-of select="$answer.label"/>
                </div>
            </xsl:if>
            <div class="{$class.prefix}data">
                <xsl:apply-templates/>
            </div>
        </div>
    </xsl:template>
    <xsl:template
            match="perl_Alert | perl_BaseN | perl_BString | perl_Char | perl_Comment | perl_DataType | perl_DecVal | perl_Error | perl_Float | perl_Function | perl_IString | perl_Keyword | perl_Operator | perl_Others | perl_RegionMarker | perl_Reserved | perl_String | perl_Variable | perl_Warning ">
        <xsl:variable name="name">
            <xsl:value-of select="local-name(.)"/>
        </xsl:variable>
        <xsl:variable name="content">
            <xsl:apply-templates/>
        </xsl:variable>
        <xsl:choose>
            <xsl:when test="contains($content,'&#10;')">
                <span>
                    <xsl:attribute name="class">
                        <xsl:value-of select="$class.prefix"/><xsl:value-of select="$name"/>
                    </xsl:attribute>
                    <xsl:value-of select="substring-before($content,'&#10;')"/>
                </span><xsl:text>
</xsl:text>
                <span>
                    <xsl:attribute name="class">
                        <xsl:value-of select="$class.prefix"/><xsl:value-of select="$name"/>
                    </xsl:attribute>
                    <xsl:value-of select="substring-after($content,'&#10;')"/>
                </span>
            </xsl:when>
            <xsl:otherwise>
                <span>
                    <xsl:attribute name="class">
                        <xsl:value-of select="$class.prefix"/><xsl:value-of select="$name"/>
                    </xsl:attribute>
                    <xsl:value-of select="$content"/>
                </span>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <!--<xsl:template match="productnumber" mode="book.titlepage.recto.auto.mode">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</xsl:template>
<xsl:template match="productname" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </span>
</xsl:template>
<xsl:template match="productnumber" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </span>
</xsl:template>
<xsl:template match="productname" mode="book.titlepage.recto.auto.mode">
<xsl:apply-templates select="." mode="book.titlepage.recto.mode"/>
</xsl:template>
<xsl:template match="orgdiv" mode="titlepage.mode">
  <xsl:if test="preceding-sibling::*[1][self::orgname]">
    <xsl:text> </xsl:text>
  </xsl:if>
  <span>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </span>
</xsl:template>
<xsl:template match="orgname" mode="titlepage.mode">
  <span>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </span>
</xsl:template><xsl:template name="book.titlepage.recto">
  <xsl:choose>
    <xsl:when test="bookinfo/productname">
	<div class="{$class.prefix}producttitle" xsl:use-attribute-sets="book.titlepage.recto.style">
	  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/productname"/>
	  <xsl:text> </xsl:text>
	  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/productnumber"/>
	</div>
    </xsl:when>
  </xsl:choose>
  <xsl:choose>
    <xsl:when test="bookinfo/title">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="bookinfo/subtitle">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="titlepage.mode" select="bookinfo/edition"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/corpauthor"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/authorgroup"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/author"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/othercredit"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/releaseinfo"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/copyright"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/legalnotice"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/pubdate"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/revision"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/revhistory"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="bookinfo/abstract"/>
  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template><xsl:template match="legalnotice" mode="titlepage.mode">
  <xsl:variable name="id"><xsl:call-template name="object.id"/></xsl:variable>
  <xsl:choose>
    <xsl:when test="$generate.legalnotice.link != 0">
      <xsl:variable name="filename">
        <xsl:call-template name="make-relative-filename">
          <xsl:with-param name="base.dir" select="$base.dir"/>
	  <xsl:with-param name="base.name">
            <xsl:apply-templates mode="chunk-filename" select="."/>
	  </xsl:with-param>
        </xsl:call-template>
      </xsl:variable>

      <xsl:variable name="title">
        <xsl:apply-templates select="." mode="title.markup"/>
      </xsl:variable>

      <xsl:variable name="href">
        <xsl:apply-templates mode="chunk-filename" select="."/>
      </xsl:variable>

      <a href="{$href}"><xsl:copy-of select="$title"/></a>

      <xsl:call-template name="write.chunk">
        <xsl:with-param name="filename" select="$filename"/>
        <xsl:with-param name="quiet" select="$chunk.quietly"/>
        <xsl:with-param name="content">
        <xsl:call-template name="user.preroot"/>
          <html>
            <head>
              <xsl:call-template name="system.head.content"/>
              <xsl:call-template name="head.content"/>
              <xsl:call-template name="user.head.content"/>
            </head>
            <body>
              <xsl:call-template name="body.attributes"/>
              <div>
                <xsl:apply-templates select="." mode="class.attribute"/>
                <xsl:apply-templates mode="titlepage.mode"/>
              </div>
            </body>
          </html>
          <xsl:value-of select="$chunk.append"/>
        </xsl:with-param>
      </xsl:call-template>
    </xsl:when>
    <xsl:otherwise>
      <div>
        <xsl:apply-templates select="." mode="class.attribute"/>
        <a id="{$id}"/>
	<h1 class="{$class.prefix}legalnotice">
    <xsl:call-template name="gentext">
      <xsl:with-param name="key">LegalNotice</xsl:with-param>
    </xsl:call-template>
	</h1>
        <xsl:apply-templates mode="titlepage.mode"/>
      </div>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template><xsl:template match="chapter/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="component.title">
    <xsl:with-param name="node" select="ancestor::chapter[1]"/>
  </xsl:call-template>
</xsl:template><xsl:template match="section/title|section/info/title|sectioninfo/title" mode="titlepage.mode" priority="2">
  <xsl:call-template name="section.title"/>
</xsl:template><xsl:template match="edition" mode="titlepage.mode">
  <p>
    <xsl:apply-templates select="." mode="class.attribute"/>
    <xsl:call-template name="gentext">
      <xsl:with-param name="key" select="'Edition'"/>
    </xsl:call-template>
    <xsl:call-template name="gentext.space"/>
    <xsl:apply-templates mode="titlepage.mode"/>
  </p>
</xsl:template><xsl:template name="article.titlepage.recto">
  <xsl:choose>
    <xsl:when test="articleinfo/productname">
	<div class="{$class.prefix}producttitle" xsl:use-attribute-sets="book.titlepage.recto.style">
	  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="articleinfo/productname"/>
	  <xsl:text> </xsl:text>
	  <xsl:apply-templates mode="book.titlepage.recto.auto.mode" select="articleinfo/productnumber"/>
	</div>
    </xsl:when>
  </xsl:choose>
  <xsl:choose>
    <xsl:when test="articleinfo/title">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/title"/>
    </xsl:when>
    <xsl:when test="artheader/title">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/title"/>
    </xsl:when>
    <xsl:when test="info/title">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/title"/>
    </xsl:when>
    <xsl:when test="title">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="title"/>
    </xsl:when>
  </xsl:choose>

  <xsl:choose>
    <xsl:when test="articleinfo/subtitle">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/subtitle"/>
    </xsl:when>
    <xsl:when test="artheader/subtitle">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/subtitle"/>
    </xsl:when>
    <xsl:when test="info/subtitle">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/subtitle"/>
    </xsl:when>
    <xsl:when test="subtitle">
      <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="subtitle"/>
    </xsl:when>
  </xsl:choose>

  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/corpauthor"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/corpauthor"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/corpauthor"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/authorgroup"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/authorgroup"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/authorgroup"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/author"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/author"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/author"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/othercredit"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/othercredit"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/othercredit"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/releaseinfo"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/releaseinfo"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/releaseinfo"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/copyright"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/copyright"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/copyright"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/legalnotice"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/legalnotice"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/legalnotice"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/pubdate"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/pubdate"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/pubdate"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/revision"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/revision"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/revision"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/revhistory"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/revhistory"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/revhistory"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="articleinfo/abstract"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="artheader/abstract"/>
  <xsl:apply-templates mode="article.titlepage.recto.auto.mode" select="info/abstract"/>
</xsl:template>-->
    <xsl:template name="paragraph">
        <xsl:param name="class" select="''"/>
        <xsl:param name="content"/>

        <xsl:variable name="p">
            <div class="{$class.prefix}para">
                <xsl:call-template name="dir"/>
                <xsl:if test="$class != ''">
                    <xsl:apply-templates select="." mode="class.attribute">
                        <xsl:with-param name="class" select="$class"/>
                    </xsl:apply-templates>
                </xsl:if>
                <xsl:if test="@id or @xml:id">
                    <xsl:attribute name="id">
                        <xsl:value-of select="(@id|@xml:id)[1]"/>
                    </xsl:attribute>
                </xsl:if>
                <xsl:copy-of select="$content"/>
            </div>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="$html.cleanup != 0">
                <xsl:call-template name="unwrap.p">
                    <xsl:with-param name="p" select="$p"/>
                </xsl:call-template>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="$p"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="simpara">
        <!-- see also listitem/simpara in lists.xsl -->
        <div class="{$class.prefix}para">
            <xsl:if test="@role and $para.propagates.style != 0">
                <xsl:apply-templates select="." mode="class.attribute">
                    <xsl:with-param name="class" select="@role"/>
                </xsl:apply-templates>
            </xsl:if>

            <xsl:call-template name="anchor"/>
            <p/>
            <xsl:apply-templates/>
        </div>
    </xsl:template>
    <xsl:template match="collab" mode="titlepage.mode">
    </xsl:template>
    <xsl:template match="funcprototype">
        <xsl:variable name="html-style">
            <xsl:call-template name="dbhtml-attribute">
                <xsl:with-param name="pis" select="ancestor::funcsynopsis//processing-instruction('dbhtml')"/>
                <xsl:with-param name="attribute" select="'funcsynopsis-style'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="style">
            <xsl:choose>
                <xsl:when test="$html-style != ''">
                    <xsl:value-of select="$html-style"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$funcsynopsis.style"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <!--
  <xsl:variable name="tabular-p"
                select="$funcsynopsis.tabular.threshold &gt; 0
                        and string-length(.) &gt; $funcsynopsis.tabular.threshold"/>
-->

        <xsl:variable name="tabular-p" select="false()"/>

        <xsl:choose>
            <xsl:when test="$style = 'kr' and $tabular-p">
                <xsl:apply-templates select="." mode="kr-tabular"/>
            </xsl:when>
            <xsl:when test="$style = 'kr'">
                <xsl:apply-templates select="." mode="kr-nontabular"/>
            </xsl:when>
            <xsl:when test="$style = 'ansi' and $tabular-p">
                <xsl:apply-templates select="." mode="ansi-tabular"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="." mode="ansi-nontabular"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="process.image">
        <!-- When this template is called, the current node should be  -->
        <!-- a graphic, inlinegraphic, imagedata, or videodata. All    -->
        <!-- those elements have the same set of attributes, so we can -->
        <!-- handle them all in one place.                             -->
        <xsl:param name="tag" select="'img'"/>
        <xsl:param name="alt"/>
        <xsl:param name="longdesc"/>

        <!-- The HTML img element only supports the notion of content-area
       scaling; it doesn't support the distinction between a
       content-area and a viewport-area, so we have to make some
       compromises.

       1. If only the content-area is specified, everything is fine.
          (If you ask for a three inch image, that's what you'll get.)

       2. If only the viewport-area is provided:
          - If scalefit=1, treat it as both the content-area and
            the viewport-area. (If you ask for an image in a five inch
            area, we'll make the image five inches to fill that area.)
          - If scalefit=0, ignore the viewport-area specification.

          Note: this is not quite the right semantic and has the additional
          problem that it can result in anamorphic scaling, which scalefit
          should never cause.

       3. If both the content-area and the viewport-area is specified
          on a graphic element, ignore the viewport-area.
          (If you ask for a three inch image in a five inch area, we'll assume
           it's better to give you a three inch image in an unspecified area
           than a five inch image in a five inch area.

       Relative units also cause problems. As a general rule, the stylesheets
       are operating too early and too loosely coupled with the rendering engine
       to know things like the current font size or the actual dimensions of
       an image. Therefore:

       1. We use a fixed size for pixels, $pixels.per.inch

       2. We use a fixed size for "em"s, $points.per.em

       Percentages are problematic. In the following discussion, we speak
       of width and contentwidth, but the same issues apply to depth and
       contentdepth

       1. A width of 50% means "half of the available space for the image."
          That's fine. But note that in HTML, this is a dynamic property and
          the image size will vary if the browser window is resized.

       2. A contentwidth of 50% means "half of the actual image width". But
          the stylesheets have no way to assess the image's actual size. Treating
          this as a width of 50% is one possibility, but it produces behavior
          (dynamic scaling) that seems entirely out of character with the
          meaning.

          Instead, the stylesheets define a $nominal.image.width
          and convert percentages to actual values based on that nominal size.

       Scale can be problematic. Scale applies to the contentwidth, so
       a scale of 50 when a contentwidth is not specified is analagous to a
       width of 50%. (If a contentwidth is specified, the scaling factor can
       be applied to that value and no problem exists.)

       If scale is specified but contentwidth is not supplied, the
       nominal.image.width is used to calculate a base size
       for scaling.

       Warning: as a consequence of these decisions, unless the aspect ratio
       of your image happens to be exactly the same as (nominal width / nominal height),
       specifying contentwidth="50%" and contentdepth="50%" is NOT going to
       scale the way you expect (or really, the way it should).

       Don't do that. In fact, a percentage value is not recommended for content
       size at all. Use scale instead.

       Finally, align and valign are troublesome. Horizontal alignment is now
       supported by wrapping the image in a <div align="{@align}"> (in block
       contexts!). I can't think of anything (practical) to do about vertical
       alignment.
  -->

        <xsl:variable name="width-units">
            <xsl:choose>
                <xsl:when test="$ignore.image.scaling != 0"/>
                <xsl:when test="@width">
                    <xsl:call-template name="length-units">
                        <xsl:with-param name="length" select="@width"/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:when test="not(@depth) and $default.image.width != ''">
                    <xsl:call-template name="length-units">
                        <xsl:with-param name="length" select="$default.image.width"/>
                    </xsl:call-template>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="width">
            <xsl:choose>
                <xsl:when test="$ignore.image.scaling != 0"/>
                <xsl:when test="@width">
                    <xsl:choose>
                        <xsl:when test="$width-units = '%'">
                            <xsl:value-of select="@width"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:call-template name="length-spec">
                                <xsl:with-param name="length" select="@width"/>
                            </xsl:call-template>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:when test="not(@depth) and $default.image.width != ''">
                    <xsl:value-of select="$default.image.width"/>
                </xsl:when>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="scalefit">
            <xsl:choose>
                <xsl:when test="$ignore.image.scaling != 0">0</xsl:when>
                <xsl:when test="@contentwidth or @contentdepth">0</xsl:when>
                <xsl:when test="@scale">0</xsl:when>
                <xsl:when test="@scalefit">
                    <xsl:value-of select="@scalefit"/>
                </xsl:when>
                <xsl:when test="$width != '' or @depth">1</xsl:when>
                <xsl:otherwise>0</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="scale">
            <xsl:choose>
                <xsl:when test="$ignore.image.scaling != 0">1.0</xsl:when>
                <xsl:when test="@contentwidth or @contentdepth">1.0</xsl:when>
                <xsl:when test="@scale">
                    <xsl:value-of select="@scale div 100.0"/>
                </xsl:when>
                <xsl:otherwise>1.0</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="filename">
            <xsl:choose>
                <xsl:when test="local-name(.) = 'graphic'                       or local-name(.) = 'inlinegraphic'">
                    <!-- handle legacy graphic and inlinegraphic by new template -->
                    <xsl:call-template name="mediaobject.filename">
                        <xsl:with-param name="object" select="."/>
                    </xsl:call-template>
                </xsl:when>
                <xsl:otherwise>
                    <!-- imagedata, videodata, audiodata -->
                    <xsl:call-template name="mediaobject.filename">
                        <xsl:with-param name="object" select=".."/>
                    </xsl:call-template>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="output_filename">
            <xsl:choose>
                <xsl:when test="$embedtoc != 0 and contains($filename, 'Common_Content')">
                    <xsl:value-of select=" concat($tocpath, '/../', $brand, '/',$langpath)"/>
                    <xsl:value-of select="substring-after($filename, 'Common_Content')"/>
                </xsl:when>
                <xsl:when test="@entityref">
                    <xsl:value-of select="$filename"/>
                </xsl:when>
                <!--
        Moved test for $keep.relative.image.uris to template below:
            <xsl:template match="@fileref">
      -->
                <xsl:otherwise>
                    <xsl:value-of select="$filename"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="img.src.path.pi">
            <xsl:call-template name="dbhtml-attribute">
                <xsl:with-param name="pis" select="../processing-instruction('dbhtml')"/>
                <xsl:with-param name="attribute" select="'img.src.path'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="filename.for.graphicsize">
            <xsl:choose>
                <xsl:when test="$img.src.path.pi != ''">
                    <xsl:value-of select="concat($img.src.path.pi, $filename)"/>
                </xsl:when>
                <xsl:when
                        test="$img.src.path != '' and                       $graphicsize.use.img.src.path != 0 and                       $tag = 'img' and                       not(starts-with($filename, '/')) and                       not(contains($filename, '://'))">
                    <xsl:value-of select="concat($img.src.path, $filename)"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$filename"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="realintrinsicwidth">
            <!-- This funny compound test works around a bug in XSLTC -->
            <xsl:choose>
                <xsl:when test="$use.extensions != 0 and $graphicsize.extension != 0">
                    <xsl:choose>
                        <xsl:when test="function-available('simg:getWidth')">
                            <xsl:value-of
                                    select="simg:getWidth(simg:new($filename.for.graphicsize),                                                 $nominal.image.width)"/>
                        </xsl:when>
                        <xsl:when test="function-available('ximg:getWidth')">
                            <xsl:value-of
                                    select="ximg:getWidth(ximg:new($filename.for.graphicsize),                                                 $nominal.image.width)"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="0"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="0"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="intrinsicwidth">
            <xsl:choose>
                <xsl:when test="$realintrinsicwidth = 0">
                    <xsl:value-of select="$nominal.image.width"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$realintrinsicwidth"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="intrinsicdepth">
            <!-- This funny compound test works around a bug in XSLTC -->
            <xsl:choose>
                <xsl:when test="$use.extensions != 0 and $graphicsize.extension != 0">
                    <xsl:choose>
                        <xsl:when test="function-available('simg:getDepth')">
                            <xsl:value-of
                                    select="simg:getDepth(simg:new($filename.for.graphicsize),                                                 $nominal.image.depth)"/>
                        </xsl:when>
                        <xsl:when test="function-available('ximg:getDepth')">
                            <xsl:value-of
                                    select="ximg:getDepth(ximg:new($filename.for.graphicsize),                                                 $nominal.image.depth)"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$nominal.image.depth"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$nominal.image.depth"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="contentwidth">
            <xsl:choose>
                <xsl:when test="$ignore.image.scaling != 0"/>
                <xsl:when test="@contentwidth">
                    <xsl:variable name="units">
                        <xsl:call-template name="length-units">
                            <xsl:with-param name="length" select="@contentwidth"/>
                        </xsl:call-template>
                    </xsl:variable>

                    <xsl:choose>
                        <xsl:when test="$units = '%'">
                            <xsl:variable name="cmagnitude">
                                <xsl:call-template name="length-magnitude">
                                    <xsl:with-param name="length" select="@contentwidth"/>
                                </xsl:call-template>
                            </xsl:variable>
                            <xsl:value-of select="$intrinsicwidth * $cmagnitude div 100.0"/>
                            <xsl:text>px</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:call-template name="length-spec">
                                <xsl:with-param name="length" select="@contentwidth"/>
                            </xsl:call-template>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$intrinsicwidth"/>
                    <xsl:text>px</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="scaled.contentwidth">
            <xsl:if test="$contentwidth != ''">
                <xsl:variable name="cwidth.in.points">
                    <xsl:call-template name="length-in-points">
                        <xsl:with-param name="length" select="$contentwidth"/>
                        <xsl:with-param name="pixels.per.inch" select="$pixels.per.inch"/>
                        <xsl:with-param name="em.size" select="$points.per.em"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:value-of select="$cwidth.in.points div 72.0 * $pixels.per.inch * $scale"/>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="html.width">
            <xsl:choose>
                <xsl:when test="$ignore.image.scaling != 0"/>
                <xsl:when test="$width-units = '%'">
                    <xsl:value-of select="$width"/>
                </xsl:when>
                <xsl:when test="$width != ''">
                    <xsl:variable name="width.in.points">
                        <xsl:call-template name="length-in-points">
                            <xsl:with-param name="length" select="$width"/>
                            <xsl:with-param name="pixels.per.inch" select="$pixels.per.inch"/>
                            <xsl:with-param name="em.size" select="$points.per.em"/>
                        </xsl:call-template>
                    </xsl:variable>
                    <xsl:value-of select="round($width.in.points div 72.0 * $pixels.per.inch)"/>
                </xsl:when>
                <xsl:otherwise/>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="contentdepth">
            <xsl:choose>
                <xsl:when test="$ignore.image.scaling != 0"/>
                <xsl:when test="@contentdepth">
                    <xsl:variable name="units">
                        <xsl:call-template name="length-units">
                            <xsl:with-param name="length" select="@contentdepth"/>
                        </xsl:call-template>
                    </xsl:variable>

                    <xsl:choose>
                        <xsl:when test="$units = '%'">
                            <xsl:variable name="cmagnitude">
                                <xsl:call-template name="length-magnitude">
                                    <xsl:with-param name="length" select="@contentdepth"/>
                                </xsl:call-template>
                            </xsl:variable>
                            <xsl:value-of select="$intrinsicdepth * $cmagnitude div 100.0"/>
                            <xsl:text>px</xsl:text>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:call-template name="length-spec">
                                <xsl:with-param name="length" select="@contentdepth"/>
                            </xsl:call-template>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$intrinsicdepth"/>
                    <xsl:text>px</xsl:text>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="scaled.contentdepth">
            <xsl:if test="$contentdepth != ''">
                <xsl:variable name="cdepth.in.points">
                    <xsl:call-template name="length-in-points">
                        <xsl:with-param name="length" select="$contentdepth"/>
                        <xsl:with-param name="pixels.per.inch" select="$pixels.per.inch"/>
                        <xsl:with-param name="em.size" select="$points.per.em"/>
                    </xsl:call-template>
                </xsl:variable>
                <xsl:value-of select="$cdepth.in.points div 72.0 * $pixels.per.inch * $scale"/>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="depth-units">
            <xsl:if test="@depth">
                <xsl:call-template name="length-units">
                    <xsl:with-param name="length" select="@depth"/>
                </xsl:call-template>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="depth">
            <xsl:if test="@depth">
                <xsl:choose>
                    <xsl:when test="$depth-units = '%'">
                        <xsl:value-of select="@depth"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:call-template name="length-spec">
                            <xsl:with-param name="length" select="@depth"/>
                        </xsl:call-template>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:if>
        </xsl:variable>

        <xsl:variable name="html.depth">
            <xsl:choose>
                <xsl:when test="$ignore.image.scaling != 0"/>
                <xsl:when test="$depth-units = '%'">
                    <xsl:value-of select="$depth"/>
                </xsl:when>
                <xsl:when test="@depth and @depth != ''">
                    <xsl:variable name="depth.in.points">
                        <xsl:call-template name="length-in-points">
                            <xsl:with-param name="length" select="$depth"/>
                            <xsl:with-param name="pixels.per.inch" select="$pixels.per.inch"/>
                            <xsl:with-param name="em.size" select="$points.per.em"/>
                        </xsl:call-template>
                    </xsl:variable>
                    <xsl:value-of select="round($depth.in.points div 72.0 * $pixels.per.inch)"/>
                </xsl:when>
                <xsl:otherwise/>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="viewport">
            <xsl:choose>
                <xsl:when test="$ignore.image.scaling != 0">0</xsl:when>
                <xsl:when
                        test="local-name(.) = 'inlinegraphic'                       or ancestor::inlinemediaobject                       or ancestor::inlineequation">
                    0
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$make.graphic.viewport"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <!--
  <xsl:message>=====================================
scale: <xsl:value-of select="$scale"/>, <xsl:value-of select="$scalefit"/>
@contentwidth <xsl:value-of select="@contentwidth"/>
$contentwidth <xsl:value-of select="$contentwidth"/>
scaled.contentwidth: <xsl:value-of select="$scaled.contentwidth"/>
@width: <xsl:value-of select="@width"/>
width: <xsl:value-of select="$width"/>
html.width: <xsl:value-of select="$html.width"/>
@contentdepth <xsl:value-of select="@contentdepth"/>
$contentdepth <xsl:value-of select="$contentdepth"/>
scaled.contentdepth: <xsl:value-of select="$scaled.contentdepth"/>
@depth: <xsl:value-of select="@depth"/>
depth: <xsl:value-of select="$depth"/>
html.depth: <xsl:value-of select="$html.depth"/>
align: <xsl:value-of select="@align"/>
valign: <xsl:value-of select="@valign"/></xsl:message>
-->

        <xsl:variable name="scaled"
                      select="@width|@depth|@contentwidth|@contentdepth                         |@scale|@scalefit"/>

        <xsl:variable name="img">
            <xsl:choose>
                <xsl:when test="@format = 'SVG' and $svg.object != 0">
                    <object data="{$output_filename}" type="image/svg+xml">
                        <xsl:call-template name="process.image.attributes">
                            <!--xsl:with-param name="alt" select="$alt"/ there's no alt here-->
                            <xsl:with-param name="html.depth" select="$html.depth"/>
                            <xsl:with-param name="html.width" select="$html.width"/>
                            <xsl:with-param name="longdesc" select="$longdesc"/>
                            <xsl:with-param name="scale" select="$scale"/>
                            <xsl:with-param name="scalefit" select="$scalefit"/>
                            <xsl:with-param name="scaled.contentdepth" select="$scaled.contentdepth"/>
                            <xsl:with-param name="scaled.contentwidth" select="$scaled.contentwidth"/>
                            <xsl:with-param name="viewport" select="$viewport"/>
                        </xsl:call-template>
                        <xsl:if test="@align">
                            <xsl:attribute name="align">
                                <xsl:choose>
                                    <xsl:when test="@align = 'center'">middle</xsl:when>
                                    <xsl:otherwise>
                                        <xsl:value-of select="@align"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:attribute>
                        </xsl:if>
                        <xsl:if test="$use.embed.for.svg != 0">
                            <embed src="{$output_filename}" type="image/svg+xml">
                                <xsl:call-template name="process.image.attributes">
                                    <!--xsl:with-param name="alt" select="$alt"/ there's no alt here -->
                                    <xsl:with-param name="html.depth" select="$html.depth"/>
                                    <xsl:with-param name="html.width" select="$html.width"/>
                                    <xsl:with-param name="longdesc" select="$longdesc"/>
                                    <xsl:with-param name="scale" select="$scale"/>
                                    <xsl:with-param name="scalefit" select="$scalefit"/>
                                    <xsl:with-param name="scaled.contentdepth" select="$scaled.contentdepth"/>
                                    <xsl:with-param name="scaled.contentwidth" select="$scaled.contentwidth"/>
                                    <xsl:with-param name="viewport" select="$viewport"/>
                                </xsl:call-template>
                            </embed>
                        </xsl:if>
                        <!-- Added this line to fix object breaking IE7 BZ #486501 -->
                        <xsl:text> </xsl:text><xsl:value-of select="$alt"/>
                    </object>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:element name="{$tag}" namespace="http://www.w3.org/1999/xhtml">
                        <xsl:if test="$tag = 'img' and ../../self::imageobjectco">
                            <xsl:variable name="mapname">
                                <xsl:call-template name="object.id">
                                    <xsl:with-param name="object" select="../../areaspec"/>
                                </xsl:call-template>
                            </xsl:variable>
                            <xsl:choose>
                                <xsl:when test="$scaled">
                                    <!-- It might be possible to handle some scaling; needs -->
                                    <!-- more investigation -->
                                    <xsl:message>
                                        <xsl:text>Warning: imagemaps not supported </xsl:text>
                                        <xsl:text>on scaled images</xsl:text>
                                    </xsl:message>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:attribute name="border">0</xsl:attribute>
                                    <xsl:attribute name="usemap">
                                        <xsl:value-of select="concat('#', $mapname)"/>
                                    </xsl:attribute>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:if>

                        <xsl:attribute name="src">
                            <xsl:choose>
                                <xsl:when
                                        test="$img.src.path != '' and                            $tag = 'img' and                              not(starts-with($output_filename, '/')) and                            not(contains($output_filename, '://'))">
                                    <xsl:value-of select="$img.src.path"/>
                                </xsl:when>
                            </xsl:choose>
                            <xsl:value-of select="$output_filename"/>
                        </xsl:attribute>

                        <xsl:if test="@align">
                            <xsl:attribute name="align">
                                <xsl:choose>
                                    <xsl:when test="@align = 'center'">middle</xsl:when>
                                    <xsl:otherwise>
                                        <xsl:value-of select="@align"/>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:attribute>
                        </xsl:if>

                        <xsl:call-template name="process.image.attributes">
                            <xsl:with-param name="alt">
                                <xsl:choose>
                                    <xsl:when test="$alt != ''">
                                        <xsl:copy-of select="$alt"/>
                                    </xsl:when>
                                    <xsl:when test="ancestor::figure">
                                        <xsl:value-of select="normalize-space(ancestor::figure/title)"/>
                                    </xsl:when>
                                </xsl:choose>
                            </xsl:with-param>
                            <xsl:with-param name="html.depth" select="$html.depth"/>
                            <xsl:with-param name="html.width" select="$html.width"/>
                            <xsl:with-param name="longdesc" select="$longdesc"/>
                            <xsl:with-param name="scale" select="$scale"/>
                            <xsl:with-param name="scalefit" select="$scalefit"/>
                            <xsl:with-param name="scaled.contentdepth" select="$scaled.contentdepth"/>
                            <xsl:with-param name="scaled.contentwidth" select="$scaled.contentwidth"/>
                            <xsl:with-param name="viewport" select="$viewport"/>
                        </xsl:call-template>
                    </xsl:element>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="bgcolor">
            <xsl:call-template name="dbhtml-attribute">
                <xsl:with-param name="pis" select="../processing-instruction('dbhtml')"/>
                <xsl:with-param name="attribute" select="'background-color'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="use.viewport"
                      select="$viewport != 0                         and ($html.width != ''                              or ($html.depth != '' and $depth-units != '%')                              or $bgcolor != ''                              or @valign)"/>

        <xsl:choose>
            <xsl:when test="$use.viewport">
                <table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0">
                    <xsl:if test="$html.width != ''">
                        <xsl:attribute name="width">
                            <xsl:value-of select="$html.width"/>
                        </xsl:attribute>
                    </xsl:if>
                    <tr>
                        <xsl:if test="$html.depth != '' and $depth-units != '%'">
                            <!-- don't do this for percentages because browsers get confused -->
                            <xsl:choose>
                                <xsl:when test="$css.decoration != 0">
                                    <xsl:attribute name="style">
                                        <xsl:text>height: </xsl:text>
                                        <xsl:value-of select="$html.depth"/>
                                        <xsl:text>px</xsl:text>
                                    </xsl:attribute>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:attribute name="height">
                                        <xsl:value-of select="$html.depth"/>
                                    </xsl:attribute>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:if>
                        <td>
                            <xsl:if test="$bgcolor != ''">
                                <xsl:choose>
                                    <xsl:when test="$css.decoration != 0">
                                        <xsl:attribute name="style">
                                            <xsl:text>background-color: </xsl:text>
                                            <xsl:value-of select="$bgcolor"/>
                                        </xsl:attribute>
                                    </xsl:when>
                                    <xsl:otherwise>
                                        <xsl:attribute name="bgcolor">
                                            <xsl:value-of select="$bgcolor"/>
                                        </xsl:attribute>
                                    </xsl:otherwise>
                                </xsl:choose>
                            </xsl:if>
                            <xsl:if test="@align">
                                <xsl:attribute name="align">
                                    <xsl:value-of select="@align"/>
                                </xsl:attribute>
                            </xsl:if>
                            <xsl:if test="@valign">
                                <xsl:attribute name="valign">
                                    <xsl:value-of select="@valign"/>
                                </xsl:attribute>
                            </xsl:if>
                            <xsl:copy-of select="$img"/>
                        </td>
                    </tr>
                </table>
            </xsl:when>
            <xsl:otherwise>
                <xsl:copy-of select="$img"/>
            </xsl:otherwise>
        </xsl:choose>

        <xsl:if test="$tag = 'img' and ../../self::imageobjectco and not($scaled)">
            <xsl:variable name="mapname">
                <xsl:call-template name="object.id">
                    <xsl:with-param name="object" select="../../areaspec"/>
                </xsl:call-template>
            </xsl:variable>

            <map name="{$mapname}">
                <xsl:for-each select="../../areaspec//area">
                    <xsl:variable name="units">
                        <xsl:choose>
                            <xsl:when test="@units = 'other' and @otherunits">
                                <xsl:value-of select="@otherunits"/>
                            </xsl:when>
                            <xsl:when test="@units">
                                <xsl:value-of select="@units"/>
                            </xsl:when>
                            <!-- areaspec|areaset/area -->
                            <xsl:when test="../@units = 'other' and ../@otherunits">
                                <xsl:value-of select="../@otherunits"/>
                            </xsl:when>
                            <xsl:when test="../@units">
                                <xsl:value-of select="../@units"/>
                            </xsl:when>
                            <!-- areaspec/areaset/area -->
                            <xsl:when test="../../@units = 'other' and ../../@otherunits">
                                <xsl:value-of select="../@otherunits"/>
                            </xsl:when>
                            <xsl:when test="../../@units">
                                <xsl:value-of select="../../@units"/>
                            </xsl:when>
                            <xsl:otherwise>calspair</xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>

                    <xsl:choose>
                        <xsl:when test="$units = 'calspair' or                           $units = 'imagemap'">
                            <xsl:variable name="coords" select="normalize-space(@coords)"/>

                            <area shape="rect">
                                <xsl:variable name="linkends">
                                    <xsl:choose>
                                        <xsl:when test="@linkends">
                                            <xsl:value-of select="normalize-space(@linkends)"/>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:value-of select="normalize-space(../@linkends)"/>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:variable>

                                <xsl:variable name="href">
                                    <xsl:choose>
                                        <xsl:when test="@xlink:href">
                                            <xsl:value-of select="@xlink:href"/>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:value-of select="../@xlink:href"/>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:variable>

                                <xsl:choose>
                                    <xsl:when test="$linkends != ''">
                                        <xsl:variable name="linkend">
                                            <xsl:choose>
                                                <xsl:when test="contains($linkends, ' ')">
                                                    <xsl:value-of select="substring-before($linkends, ' ')"/>
                                                </xsl:when>
                                                <xsl:otherwise>
                                                    <xsl:value-of select="$linkends"/>
                                                </xsl:otherwise>
                                            </xsl:choose>
                                        </xsl:variable>
                                        <xsl:variable name="target" select="key('id', $linkend)[1]"/>

                                        <xsl:if test="$target">
                                            <xsl:attribute name="href">
                                                <xsl:call-template name="href.target">
                                                    <xsl:with-param name="object" select="$target"/>
                                                </xsl:call-template>
                                            </xsl:attribute>
                                        </xsl:if>
                                    </xsl:when>
                                    <xsl:when test="$href != ''">
                                        <xsl:attribute name="href">
                                            <xsl:value-of select="$href"/>
                                        </xsl:attribute>
                                    </xsl:when>
                                </xsl:choose>

                                <xsl:if test="alt">
                                    <xsl:attribute name="alt">
                                        <xsl:value-of select="alt[1]"/>
                                    </xsl:attribute>
                                </xsl:if>

                                <xsl:attribute name="coords">
                                    <xsl:choose>
                                        <xsl:when test="$units = 'calspair'">

                                            <xsl:variable name="p1" select="substring-before($coords, ' ')"/>
                                            <xsl:variable name="p2" select="substring-after($coords, ' ')"/>

                                            <xsl:variable name="x1" select="substring-before($p1,',')"/>
                                            <xsl:variable name="y1" select="substring-after($p1,',')"/>
                                            <xsl:variable name="x2" select="substring-before($p2,',')"/>
                                            <xsl:variable name="y2" select="substring-after($p2,',')"/>

                                            <xsl:variable name="x1p" select="$x1 div 100.0"/>
                                            <xsl:variable name="y1p" select="$y1 div 100.0"/>
                                            <xsl:variable name="x2p" select="$x2 div 100.0"/>
                                            <xsl:variable name="y2p" select="$y2 div 100.0"/>

                                            <!--
                    <xsl:message>
                      <xsl:text>units: </xsl:text>
                      <xsl:value-of select="$units"/>
                      <xsl:text> </xsl:text>
                      <xsl:value-of select="$x1p"/><xsl:text>, </xsl:text>
                      <xsl:value-of select="$y1p"/><xsl:text>, </xsl:text>
                      <xsl:value-of select="$x2p"/><xsl:text>, </xsl:text>
                      <xsl:value-of select="$y2p"/><xsl:text>, </xsl:text>
                    </xsl:message>
         
                    <xsl:message>
                      <xsl:text>      </xsl:text>
                      <xsl:value-of select="$intrinsicwidth"/>
                      <xsl:text>, </xsl:text>
                      <xsl:value-of select="$intrinsicdepth"/>
                    </xsl:message>
         
                    <xsl:message>
                      <xsl:text>      </xsl:text>
                      <xsl:value-of select="$units"/>
                      <xsl:text> </xsl:text>
                      <xsl:value-of 
                            select="round($x1p * $intrinsicwidth div 100.0)"/>
                      <xsl:text>,</xsl:text>
                      <xsl:value-of select="round($intrinsicdepth
                                       - ($y2p * $intrinsicdepth div 100.0))"/>
                      <xsl:text>,</xsl:text>
                      <xsl:value-of select="round($x2p * 
                                            $intrinsicwidth div 100.0)"/>
                      <xsl:text>,</xsl:text>
                      <xsl:value-of select="round($intrinsicdepth
                                       - ($y1p * $intrinsicdepth div 100.0))"/>
                    </xsl:message>
         -->
                                            <xsl:value-of select="round($x1p * $intrinsicwidth div 100.0)"/>
                                            <xsl:text>,</xsl:text>
                                            <xsl:value-of
                                                    select="round($intrinsicdepth                                         - ($y2p * $intrinsicdepth div 100.0))"/>
                                            <xsl:text>,</xsl:text>
                                            <xsl:value-of select="round($x2p * $intrinsicwidth div 100.0)"/>
                                            <xsl:text>,</xsl:text>
                                            <xsl:value-of
                                                    select="round($intrinsicdepth                                       - ($y1p * $intrinsicdepth div 100.0))"/>
                                        </xsl:when>
                                        <xsl:otherwise>
                                            <xsl:copy-of select="$coords"/>
                                        </xsl:otherwise>
                                    </xsl:choose>
                                </xsl:attribute>
                            </area>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message>
                                <xsl:text>Warning: only calspair or </xsl:text>
                                <xsl:text>otherunits='imagemap' supported </xsl:text>
                                <xsl:text>in imageobjectco</xsl:text>
                            </xsl:message>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:for-each>
            </map>
        </xsl:if>
    </xsl:template>
    <xsl:template match="tgroup" name="tgroup">
        <xsl:if test="not(@cols) or @cols = '' or string(number(@cols)) = 'NaN'">
            <xsl:message terminate="yes">
                <xsl:text>Error: CALS tables must specify the number of columns.</xsl:text>
            </xsl:message>
        </xsl:if>

        <xsl:variable name="summary">
            <xsl:call-template name="dbhtml-attribute">
                <xsl:with-param name="pis" select="processing-instruction('dbhtml')"/>
                <xsl:with-param name="attribute" select="'table-summary'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="cellspacing">
            <xsl:call-template name="dbhtml-attribute">
                <xsl:with-param name="pis" select="processing-instruction('dbhtml')"/>
                <xsl:with-param name="attribute" select="'cellspacing'"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="cellpadding">
            <xsl:call-template name="dbhtml-attribute">
                <xsl:with-param name="pis" select="processing-instruction('dbhtml')[1]"/>
                <xsl:with-param name="attribute" select="'cellpadding'"/>
            </xsl:call-template>
        </xsl:variable>

        <table>
            <xsl:choose>
                <!-- If there's a textobject/phrase for the table summary, use it -->
                <xsl:when test="../textobject/phrase">
                    <xsl:attribute name="summary">
                        <xsl:value-of select="../textobject/phrase"/>
                    </xsl:attribute>
                </xsl:when>

                <!-- If there's a <?dbhtml table-summary="foo"?> PI, use it for
           the HTML table summary attribute -->
                <xsl:when test="$summary != ''">
                    <xsl:attribute name="summary">
                        <xsl:value-of select="$summary"/>
                    </xsl:attribute>
                </xsl:when>

                <!-- Otherwise, if there's a title, use that -->
                <xsl:when test="../title">
                    <xsl:attribute name="summary">
                        <xsl:value-of select="string(../title)"/>
                    </xsl:attribute>
                </xsl:when>

                <!-- Otherwise, forget the whole idea -->
                <xsl:otherwise><!-- nevermind --></xsl:otherwise>
            </xsl:choose>

            <xsl:if test="$cellspacing != '' or $html.cellspacing != ''">
                <xsl:attribute name="cellspacing">
                    <xsl:choose>
                        <xsl:when test="$cellspacing != ''">
                            <xsl:value-of select="$cellspacing"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$html.cellspacing"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:attribute>
            </xsl:if>

            <xsl:if test="$cellpadding != '' or $html.cellpadding != ''">
                <xsl:attribute name="cellpadding">
                    <xsl:choose>
                        <xsl:when test="$cellpadding != ''">
                            <xsl:value-of select="$cellpadding"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$html.cellpadding"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:attribute>
            </xsl:if>

            <xsl:if test="../@pgwide=1 or local-name(.) = 'entrytbl'">
                <xsl:attribute name="width">100%</xsl:attribute>
            </xsl:if>
            <!--
snip border rubbish. BZ #875967
-->
            <xsl:variable name="colgroup">
                <colgroup>
                    <xsl:call-template name="generate.colgroup">
                        <xsl:with-param name="cols" select="@cols"/>
                    </xsl:call-template>
                </colgroup>
            </xsl:variable>

            <xsl:variable name="explicit.table.width">
                <xsl:call-template name="dbhtml-attribute">
                    <xsl:with-param name="pis" select="../processing-instruction('dbhtml')[1]"/>
                    <xsl:with-param name="attribute" select="'table-width'"/>
                </xsl:call-template>
            </xsl:variable>

            <xsl:variable name="table.width">
                <xsl:choose>
                    <xsl:when test="$explicit.table.width != ''">
                        <xsl:value-of select="$explicit.table.width"/>
                    </xsl:when>
                    <xsl:when test="$default.table.width = ''">
                        <xsl:text>100%</xsl:text>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="$default.table.width"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>

            <xsl:if test="$default.table.width != ''                   or $explicit.table.width != ''">
                <xsl:attribute name="width">
                    <xsl:choose>
                        <xsl:when test="contains($table.width, '%')">
                            <xsl:value-of select="$table.width"/>
                        </xsl:when>
                        <xsl:when
                                test="$use.extensions != 0                           and $tablecolumns.extension != 0">
                            <xsl:choose>
                                <xsl:when test="function-available('stbl:convertLength')">
                                    <xsl:value-of select="stbl:convertLength($table.width)"/>
                                </xsl:when>
                                <xsl:when test="function-available('xtbl:convertLength')">
                                    <xsl:value-of select="xtbl:convertLength($table.width)"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:message terminate="yes">
                                        <xsl:text>No convertLength function available.</xsl:text>
                                    </xsl:message>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="$table.width"/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:attribute>
            </xsl:if>

            <xsl:choose>
                <xsl:when test="$use.extensions != 0                       and $tablecolumns.extension != 0">
                    <xsl:choose>
                        <xsl:when test="function-available('stbl:adjustColumnWidths')">
                            <xsl:copy-of select="stbl:adjustColumnWidths($colgroup)"/>
                        </xsl:when>
                        <xsl:when test="function-available('xtbl:adjustColumnWidths')">
                            <xsl:copy-of select="xtbl:adjustColumnWidths($colgroup)"/>
                        </xsl:when>
                        <xsl:when test="function-available('ptbl:adjustColumnWidths')">
                            <xsl:copy-of select="ptbl:adjustColumnWidths($colgroup)"/>
                        </xsl:when>
                        <xsl:when test="function-available('perl:adjustColumnWidths')">
                            <xsl:copy-of select="perl:adjustColumnWidths($table.width, $colgroup)"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message terminate="yes">
                                <xsl:text>No adjustColumnWidths function available.</xsl:text>
                            </xsl:message>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:copy-of select="$colgroup"/>
                </xsl:otherwise>
            </xsl:choose>

            <xsl:apply-templates select="thead"/>
            <xsl:apply-templates select="tfoot"/>
            <xsl:apply-templates select="tbody"/>

            <xsl:if test=".//footnote">
                <tbody class="{$class.prefix}footnotes">
                    <tr>
                        <td colspan="{@cols}">
                            <xsl:apply-templates select=".//footnote" mode="table.footnote.mode"/>
                        </td>
                    </tr>
                </tbody>
            </xsl:if>
        </table>
    </xsl:template>
    <xsl:template match="programlistingco|screenco">
        <xsl:variable name="verbatim" select="programlisting|screen"/>

        <xsl:choose>
            <xsl:when test="$use.extensions != '0' and $callouts.extension != '0'">
                <xsl:variable name="rtf">
                    <xsl:apply-templates select="$verbatim">
                        <xsl:with-param name="suppress-numbers" select="'1'"/>
                    </xsl:apply-templates>
                </xsl:variable>

                <xsl:variable name="rtf-with-callouts">
                    <xsl:choose>
                        <xsl:when test="function-available('sverb:insertCallouts')">
                            <xsl:copy-of select="sverb:insertCallouts(areaspec,$rtf)"/>
                        </xsl:when>
                        <xsl:when test="function-available('xverb:insertCallouts')">
                            <xsl:copy-of select="xverb:insertCallouts(areaspec,$rtf)"/>
                        </xsl:when>
                        <xsl:when test="function-available('perl:insertCallouts')">
                            <xsl:copy-of select="perl:insertCallouts(areaspec,exsl:node-set($rtf))"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:message terminate="yes">
                                <xsl:text>No insertCallouts function is available.</xsl:text>
                            </xsl:message>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:variable>

                <xsl:choose>
                    <xsl:when
                            test="$verbatim/@linenumbering = 'numbered'                         and $linenumbering.extension != '0'">
                        <div>
                            <xsl:call-template name="common.html.attributes"/>
                            <xsl:call-template name="number.rtf.lines">
                                <xsl:with-param name="rtf" select="$rtf-with-callouts"/>
                                <xsl:with-param name="pi.context" select="programlisting|screen"/>
                            </xsl:call-template>
                            <xsl:apply-templates select="calloutlist"/>
                        </div>
                    </xsl:when>
                    <xsl:otherwise>
                        <div>
                            <xsl:call-template name="common.html.attributes"/>
                            <xsl:copy-of select="$rtf-with-callouts"/>
                            <xsl:apply-templates select="calloutlist"/>
                        </div>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <div>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:apply-templates/>
                </div>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="co" name="co">
        <!-- Support a single linkend in HTML -->
        <xsl:variable name="targets" select="key('id', @linkends)"/>
        <xsl:variable name="target" select="$targets[1]"/>
        <xsl:choose>
            <xsl:when test="$target">
                <a>
                    <xsl:apply-templates select="." mode="common.html.attributes"/>
                    <xsl:if test="@id or @xml:id">
                        <xsl:attribute name="id">
                            <xsl:value-of select="(@id|@xml:id)[1]"/>
                        </xsl:attribute>
                    </xsl:if>
                    <xsl:attribute name="href">
                        <xsl:call-template name="href.target">
                            <xsl:with-param name="object" select="$target"/>
                        </xsl:call-template>
                    </xsl:attribute>
                    <xsl:apply-templates select="." mode="callout-bug"/>
                </a>
            </xsl:when>
            <xsl:otherwise>
                <xsl:apply-templates select="." mode="callout-bug"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="co" mode="callout-bug">
        <xsl:call-template name="callout-bug">
            <xsl:with-param name="conum">
                <xsl:number count="co" level="any" from="programlisting|screen|literallayout|synopsis" format="1"/>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>
    <xsl:template name="callout-bug">
        <xsl:param name="conum" select="1"/>

        <xsl:choose>
            <xsl:when test="$callout.graphics != 0                     and $conum &lt;= $callout.graphics.number.limit">
                <img class="{$class.prefix}callout" src="{$callout.graphics.path}{$conum}{$callout.graphics.extension}"
                     alt="{$conum}" border="0">
                    <xsl:if test="@id or @xml:id">
                        <xsl:attribute name="id">
                            <xsl:value-of select="(@id|@xml:id)[1]"/>
                        </xsl:attribute>
                    </xsl:if>
                </img>
            </xsl:when>
            <xsl:when test="$callout.unicode != 0                     and $conum &lt;= $callout.unicode.number.limit">
                <xsl:choose>
                    <xsl:when test="$callout.unicode.start.character = 10102">
                        <xsl:choose>
                            <xsl:when test="$conum = 1">❶</xsl:when>
                            <xsl:when test="$conum = 2">❷</xsl:when>
                            <xsl:when test="$conum = 3">❸</xsl:when>
                            <xsl:when test="$conum = 4">❹</xsl:when>
                            <xsl:when test="$conum = 5">❺</xsl:when>
                            <xsl:when test="$conum = 6">❻</xsl:when>
                            <xsl:when test="$conum = 7">❼</xsl:when>
                            <xsl:when test="$conum = 8">❽</xsl:when>
                            <xsl:when test="$conum = 9">❾</xsl:when>
                            <xsl:when test="$conum = 10">❿</xsl:when>
                        </xsl:choose>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:message>
                            <xsl:text>Don't know how to generate Unicode callouts </xsl:text>
                            <xsl:text>when $callout.unicode.start.character is </xsl:text>
                            <xsl:value-of select="$callout.unicode.start.character"/>
                        </xsl:message>
                        <xsl:text>(</xsl:text>
                        <xsl:value-of select="$conum"/>
                        <xsl:text>)</xsl:text>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>(</xsl:text>
                <xsl:value-of select="$conum"/>
                <xsl:text>)</xsl:text>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template name="number.rtf.lines">
        <xsl:param name="rtf" select="''"/>
        <xsl:param name="pi.context" select="."/>

        <!-- Save the global values -->
        <xsl:variable name="global.linenumbering.everyNth" select="$linenumbering.everyNth"/>

        <xsl:variable name="global.linenumbering.separator" select="$linenumbering.separator"/>

        <xsl:variable name="global.linenumbering.width" select="$linenumbering.width"/>

        <!-- Extract the <?dbhtml linenumbering.*?> PI values -->
        <xsl:variable name="pi.linenumbering.everyNth">
            <xsl:call-template name="pi.dbhtml_linenumbering.everyNth">
                <xsl:with-param name="node" select="$pi.context"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="pi.linenumbering.separator">
            <xsl:call-template name="pi.dbhtml_linenumbering.separator">
                <xsl:with-param name="node" select="$pi.context"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="pi.linenumbering.width">
            <xsl:call-template name="pi.dbhtml_linenumbering.width">
                <xsl:with-param name="node" select="$pi.context"/>
            </xsl:call-template>
        </xsl:variable>

        <!-- Construct the 'in-context' values -->
        <xsl:variable name="linenumbering.everyNth">
            <xsl:choose>
                <xsl:when test="$pi.linenumbering.everyNth != ''">
                    <xsl:value-of select="$pi.linenumbering.everyNth"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$global.linenumbering.everyNth"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="linenumbering.separator">
            <xsl:choose>
                <xsl:when test="$pi.linenumbering.separator != ''">
                    <xsl:value-of select="$pi.linenumbering.separator"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$global.linenumbering.separator"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="linenumbering.width">
            <xsl:choose>
                <xsl:when test="$pi.linenumbering.width != ''">
                    <xsl:value-of select="$pi.linenumbering.width"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$global.linenumbering.width"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:variable name="linenumbering.startinglinenumber">
            <xsl:choose>
                <xsl:when test="$pi.context/@startinglinenumber">
                    <xsl:value-of select="$pi.context/@startinglinenumber"/>
                </xsl:when>
                <xsl:when test="$pi.context/@continuation='continues'">
                    <xsl:variable name="lastLine">
                        <xsl:choose>
                            <xsl:when test="$pi.context/self::programlisting">
                                <xsl:call-template name="lastLineNumber">
                                    <xsl:with-param name="listings"
                                                    select="preceding::programlisting[@linenumbering='numbered']"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:when test="$pi.context/self::screen">
                                <xsl:call-template name="lastLineNumber">
                                    <xsl:with-param name="listings"
                                                    select="preceding::screen[@linenumbering='numbered']"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:when test="$pi.context/self::literallayout">
                                <xsl:call-template name="lastLineNumber">
                                    <xsl:with-param name="listings"
                                                    select="preceding::literallayout[@linenumbering='numbered']"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:when test="$pi.context/self::address">
                                <xsl:call-template name="lastLineNumber">
                                    <xsl:with-param name="listings"
                                                    select="preceding::address[@linenumbering='numbered']"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:when test="$pi.context/self::synopsis">
                                <xsl:call-template name="lastLineNumber">
                                    <xsl:with-param name="listings"
                                                    select="preceding::synopsis[@linenumbering='numbered']"/>
                                </xsl:call-template>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:message>
                                    <xsl:text>Unexpected verbatim environment: </xsl:text>
                                    <xsl:value-of select="local-name($pi.context)"/>
                                </xsl:message>
                                <xsl:value-of select="0"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>

                    <xsl:value-of select="$lastLine + 1"/>
                </xsl:when>
                <xsl:otherwise>1</xsl:otherwise>
            </xsl:choose>
        </xsl:variable>

        <xsl:choose>
            <xsl:when test="function-available('sverb:numberLines')">
                <xsl:copy-of select="sverb:numberLines($rtf)"/>
            </xsl:when>
            <xsl:when test="function-available('xverb:numberLines')">
                <xsl:copy-of select="xverb:numberLines($rtf)"/>
            </xsl:when>
            <xsl:when test="function-available('perl:numberLines')">
                <xsl:copy-of select="perl:numberLines($linenumbering.startinglinenumber, $rtf)"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:message terminate="yes">
                    <xsl:text>No numberLines function available.</xsl:text>
                </xsl:message>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="*" mode="html.title.attribute">
        <xsl:variable name="is.title">
            <xsl:call-template name="gentext.template.exists">
                <xsl:with-param name="context" select="'title'"/>
                <xsl:with-param name="name" select="local-name(.)"/>
                <xsl:with-param name="lang">
                    <xsl:call-template name="l10n.language"/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="is.title-numbered">
            <xsl:call-template name="gentext.template.exists">
                <xsl:with-param name="context" select="'title-numbered'"/>
                <xsl:with-param name="name" select="local-name(.)"/>
                <xsl:with-param name="lang">
                    <xsl:call-template name="l10n.language"/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="is.title-unnumbered">
            <xsl:call-template name="gentext.template.exists">
                <xsl:with-param name="context" select="'title-unnumbered'"/>
                <xsl:with-param name="name" select="local-name(.)"/>
                <xsl:with-param name="lang">
                    <xsl:call-template name="l10n.language"/>
                </xsl:with-param>
            </xsl:call-template>
        </xsl:variable>

        <xsl:variable name="has.title.markup">
            <xsl:apply-templates select="." mode="title.markup">
                <xsl:with-param name="verbose" select="0"/>
            </xsl:apply-templates>
        </xsl:variable>

        <xsl:variable name="gentext.title">
            <xsl:if test="$has.title.markup != '???TITLE???' and                   ($is.title != 0 or                   $is.title-numbered != 0 or                   $is.title-unnumbered != 0)">
                <xsl:apply-templates select="." mode="object.title.markup.textonly"/>
            </xsl:if>
        </xsl:variable>

        <xsl:choose>
            <!--xsl:when test="string-length($gentext.title) != 0">
      <xsl:attribute name="title">
        <xsl:value-of select="$gentext.title"/>
      </xsl:attribute>
    </xsl:when-->
            <!-- Fall back to alt if available -->
            <xsl:when test="alt">
                <xsl:attribute name="title">
                    <xsl:value-of select="normalize-space(alt)"/>
                </xsl:attribute>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="footnote">
        <xsl:variable name="href">
            <xsl:text>#ftn.</xsl:text>
            <xsl:call-template name="object.id">
                <xsl:with-param name="conditional" select="0"/>
            </xsl:call-template>
        </xsl:variable>

        <xsl:call-template name="anchor">
            <xsl:with-param name="conditional" select="0"/>
        </xsl:call-template>
        <a href="{$href}">
            <xsl:apply-templates select="." mode="class.attribute"/>
            <sup>
                <xsl:apply-templates select="." mode="class.attribute"/>
                <xsl:call-template name="id.attribute">
                    <xsl:with-param name="conditional" select="0"/>
                </xsl:call-template>
                <!-- MOVED UP BZ #
      <xsl:call-template name="anchor">
        <xsl:with-param name="conditional" select="0"/>
      </xsl:call-template>
-->
                <xsl:text>[</xsl:text>
                <xsl:apply-templates select="." mode="footnote.number"/>
                <xsl:text>]</xsl:text>
            </sup>
        </a>
    </xsl:template>
    <xsl:template match="*" mode="process.root">
        <xsl:variable name="doc" select="self::*"/>

        <xsl:call-template name="user.preroot"/>
        <xsl:call-template name="root.messages"/>

        <xsl:choose>
            <xsl:when test="$body.only != 0">
                <xsl:apply-templates select="."/>
            </xsl:when>
            <xsl:otherwise>
                <html>
                    <xsl:call-template name="root.attributes"/>
                    <head>
                        <xsl:call-template name="system.head.content">
                            <xsl:with-param name="node" select="$doc"/>
                        </xsl:call-template>
                        <xsl:call-template name="head.content">
                            <xsl:with-param name="node" select="$doc"/>
                        </xsl:call-template>
                        <xsl:call-template name="user.head.content">
                            <xsl:with-param name="node" select="$doc"/>
                        </xsl:call-template>
                    </head>
                    <body>
                        <xsl:call-template name="body.attributes"/>
                        <xsl:call-template name="user.header.content">
                            <xsl:with-param name="node" select="$doc"/>
                        </xsl:call-template>
                        <xsl:apply-templates select="."/>
                        <xsl:call-template name="user.footer.content">
                            <xsl:with-param name="node" select="$doc"/>
                        </xsl:call-template>
                    </body>
                </html>
                <xsl:value-of select="$html.append"/>

                <!-- Generate any css files only once, not once per chunk -->
                <xsl:call-template name="generate.css.files"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
</xsl:stylesheet>