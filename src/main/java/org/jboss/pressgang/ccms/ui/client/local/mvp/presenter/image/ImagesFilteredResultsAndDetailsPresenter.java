package org.jboss.pressgang.ccms.ui.client.local.mvp.presenter.image;

import com.google.gwt.event.dom.client.*;
import com.google.gwt.event.shared.HandlerManager;
import com.google.gwt.http.client.URL;
import com.google.gwt.user.client.Window;
import com.google.gwt.user.client.ui.DialogBox;
import com.google.gwt.user.client.ui.HasWidgets;
import com.google.gwt.user.client.ui.PushButton;
import com.google.gwt.user.client.ui.TextArea;
import org.jboss.pressgang.ccms.rest.v1.collections.RESTImageCollectionV1;
import org.jboss.pressgang.ccms.rest.v1.collections.RESTLanguageImageCollectionV1;
import org.jboss.pressgang.ccms.rest.v1.collections.items.RESTImageCollectionItemV1;
import org.jboss.pressgang.ccms.rest.v1.collections.items.RESTLanguageImageCollectionItemV1;
import org.jboss.pressgang.ccms.rest.v1.components.ComponentImageV1;
import org.jboss.pressgang.ccms.rest.v1.entities.RESTImageV1;
import org.jboss.pressgang.ccms.rest.v1.entities.RESTLanguageImageV1;
import org.jboss.pressgang.ccms.rest.v1.entities.RESTStringConstantV1;
import org.jboss.pressgang.ccms.ui.client.local.constants.Constants;
import org.jboss.pressgang.ccms.ui.client.local.constants.ServiceConstants;
import org.jboss.pressgang.ccms.ui.client.local.mvp.events.viewevents.ImagesFilteredResultsAndImageViewEvent;
import org.jboss.pressgang.ccms.ui.client.local.mvp.events.viewevents.SearchResultsAndTopicViewEvent;
import org.jboss.pressgang.ccms.ui.client.local.mvp.presenter.base.BaseTemplatePresenterInterface;
import org.jboss.pressgang.ccms.ui.client.local.mvp.presenter.base.searchandedit.BaseSearchAndEditPresenter;
import org.jboss.pressgang.ccms.ui.client.local.mvp.presenter.base.searchandedit.DisplayNewEntityCallback;
import org.jboss.pressgang.ccms.ui.client.local.mvp.presenter.base.searchandedit.GetNewEntityCallback;
import org.jboss.pressgang.ccms.ui.client.local.mvp.view.base.BaseTemplateViewInterface;
import org.jboss.pressgang.ccms.ui.client.local.mvp.view.base.searchandedit.BaseSearchAndEditViewInterface;
import org.jboss.pressgang.ccms.ui.client.local.preferences.Preferences;
import org.jboss.pressgang.ccms.ui.client.local.resources.strings.PressGangCCMSUI;
import org.jboss.pressgang.ccms.ui.client.local.restcalls.FailOverRESTCall;
import org.jboss.pressgang.ccms.ui.client.local.restcalls.FailOverRESTCallDatabase;
import org.jboss.pressgang.ccms.ui.client.local.restcalls.RESTCallBack;
import org.jboss.pressgang.ccms.ui.client.local.server.ServerDetails;
import org.jboss.pressgang.ccms.ui.client.local.ui.editor.image.RESTImageV1Editor;
import org.jboss.pressgang.ccms.ui.client.local.ui.editor.image.RESTLanguageImageV1Editor;
import org.jboss.pressgang.ccms.ui.client.local.utilities.GWTUtilities;
import org.jboss.pressgang.ccms.utils.constants.CommonFilterConstants;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.vectomatic.file.File;
import org.vectomatic.file.FileList;
import org.vectomatic.file.FileReader;
import org.vectomatic.file.FileUploadExt;
import org.vectomatic.file.events.ErrorHandler;
import org.vectomatic.file.events.LoadEndEvent;
import org.vectomatic.file.events.LoadEndHandler;

import javax.enterprise.context.Dependent;
import javax.inject.Inject;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import static org.jboss.pressgang.ccms.ui.client.local.utilities.GWTUtilities.clearContainerAndAddTopLevelPanel;
import static org.jboss.pressgang.ccms.ui.client.local.utilities.GWTUtilities.removeHistoryToken;

/**
 * The presenter used to add logic to the image search and edit view.
 * <p/>
 * Images are a little different to other entities in that one of the properties, imageBase64, is generated by the server from
 * the binary image data. This property is used by the GWT application to display the image, which means that when editing
 * uploading a new image we actually have to save to the server instead of applying all changes locally and then saving them all
 * in one hit.
 * <p/>
 * It also means that when we create a new image we actually create and save a new image, instead of creating an in memory image
 * that is edited and then saved.
 *
 * @author Matthew Casperson
 */
@Dependent
public class ImagesFilteredResultsAndDetailsPresenter
        extends
        BaseSearchAndEditPresenter<
                RESTImageV1,
                RESTImageCollectionV1,
                RESTImageCollectionItemV1,
                RESTImageV1Editor>
        implements BaseTemplatePresenterInterface {


    public interface Display extends BaseSearchAndEditViewInterface<RESTImageV1, RESTImageCollectionV1, RESTImageCollectionItemV1> {
        /**
         * The interface that defines the bulk image upload dialog box.
         */
        public interface BulkUploadDisplay {
            /**
             * @return A reference to the dialog box.
             */
            @NotNull
            DialogBox getDialogBox();

            /**
             * @return The OK button
             */
            @NotNull
            PushButton getOK();

            /**
             * @return The Cancel button
             */
            @NotNull
            PushButton getCancel();

            /**
             * @return The file upload element
             */
            @NotNull
            FileUploadExt getFiles();

            /**
             * @return The description to be added to each new image
             */
            @NotNull
            TextArea getDescription();
        }

        BulkUploadDisplay getBulkUploadDialog();
    }


    /**
     * History token
     */
    public static final String HISTORY_TOKEN = "ImageFilteredResultsAndImageView";

    /**
     * A logger.
     */
    private static final Logger LOGGER = Logger.getLogger(ImagesFilteredResultsAndDetailsPresenter.class.getName());

    /**
     * A reference to the StringConstants that holds the locales.
     */
    private String[] locales;

    @Inject
    private HandlerManager eventBus;

    @Inject
    private Display display;

    @Inject
    private ImageFilteredResultsPresenter imageFilteredResultsComponent;

    @Inject
    private ImagePresenter imageComponent;

    private String queryString;

    @Override
    public void go(@NotNull final HasWidgets container) {
        clearContainerAndAddTopLevelPanel(container, display);
        bindSearchAndEditExtended(ServiceConstants.IMAGES_TOPIC, HISTORY_TOKEN, queryString);
    }

    @Override
    public void close() {

    }

    @Override
    public void bindSearchAndEditExtended(final int topicId, @NotNull final String pageId, @NotNull final String queryString) {
        display.setFeedbackLink(Constants.KEY_SURVEY_LINK + HISTORY_TOKEN);

        imageComponent.bindExtended(ServiceConstants.IMAGE_HELP_TOPIC, pageId);
        imageFilteredResultsComponent.bindExtendedFilteredResults(ServiceConstants.SEARCH_VIEW_HELP_TOPIC, pageId, queryString);

        /* A call back used to get a fresh copy of the entity that was selected */
        final GetNewEntityCallback<RESTImageV1> getNewEntityCallback = new GetNewEntityCallback<RESTImageV1>() {


            @Override
            public void getNewEntity(@NotNull final RESTImageV1 selectedEntity, @NotNull final DisplayNewEntityCallback<RESTImageV1> displayCallback) {

                final RESTCallBack<RESTImageV1> callback = new RESTCallBack<RESTImageV1>() {
                    @Override
                    public void success(@NotNull final RESTImageV1 retValue) {
                        checkArgument(retValue.getLanguageImages_OTM() != null, "The initially retrieved entity should have a language images collection");
                        displayCallback.displayNewEntity(retValue);
                    }
                };

                FailOverRESTCall.performRESTCall(FailOverRESTCallDatabase.getImageWithoutPreview(selectedEntity.getId()), callback, display);
            }
        };

        super.bindSearchAndEdit(topicId, pageId, Preferences.IMAGE_VIEW_MAIN_SPLIT_WIDTH, imageComponent.getDisplay(), imageComponent.getDisplay(), imageFilteredResultsComponent.getDisplay(),
                imageFilteredResultsComponent, display, display, getNewEntityCallback);

        populateLocales();
    }

    @Override
    public void parseToken(@NotNull final String historyToken) {
        queryString = removeHistoryToken(historyToken, HISTORY_TOKEN);
        if (!queryString.startsWith(Constants.QUERY_PATH_SEGMENT_PREFIX)) {
            queryString = Constants.QUERY_PATH_SEGMENT_PREFIX;
        }
    }

    /**
     * Here we load the actual language images associated with the image
     */
    @Override
    protected void loadAdditionalDisplayedItemData() {

        checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem() != null, "There should be a displayed collection item.");
        checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem() != null, "The displayed collection item to reference a valid entity.");
        checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem().getId() != null, "The displayed collection item to reference a valid entity and have a valid id");

        final RESTCallBack<RESTImageV1> callback = new RESTCallBack<RESTImageV1>() {
            @Override
            public void success(@NotNull final RESTImageV1 retValue) {
                checkArgument(retValue.getLanguageImages_OTM() != null, "The image should have the language image children populated.");

                /*
                 * Do a shallow copy here, because Chrome has issues with System.arraycopy - see
                 * http://code.google.com/p/chromium/issues/detail?id=56588
                 */
                retValue.cloneInto(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem(), false);

                finishLoading();
            }
        };

        FailOverRESTCall.performRESTCall(FailOverRESTCallDatabase.getImage(imageFilteredResultsComponent.getProviderData().getSelectedItem().getItem().getId()), callback, display);
    }

    @NotNull
    private RESTCallBack<RESTImageV1> getDefaultImageRestCallback() {
        return new RESTCallBack<RESTImageV1>() {
            @Override
            public void success(@NotNull final RESTImageV1 retValue) {

                checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem() != null, "There should be a displayed collection item.");
                checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem() != null, "The displayed collection item to reference a valid entity.");
                checkState(imageFilteredResultsComponent.getProviderData().getSelectedItem() != null, "There should be a selected collection item.");
                checkState(imageFilteredResultsComponent.getProviderData().getSelectedItem().getItem() != null, "The selected collection item to reference a valid entity.");

                retValue.cloneInto(imageFilteredResultsComponent.getProviderData().getSelectedItem().getItem(), false);
                retValue.cloneInto(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem(), false);
                initializeViews();
                updateDisplayWithNewEntityData(false);

                Window.alert(PressGangCCMSUI.INSTANCE.ImageUplodedSuccessfully());
            }

            @Override
            public void failed() {
                Window.alert(PressGangCCMSUI.INSTANCE.ImageUploadFailure());
            }
        };
    }

    @NotNull
    private List<String> getUnassignedLocales() {

        checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem() != null, "There should be a displayed collection item.");
        checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem() != null, "The displayed collection item to reference a valid entity.");
        checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem().getLanguageImages_OTM() != null, "The displayed collection item to reference a valid entity and have a valid collection of language images.");

        final List<String> newLocales = new ArrayList<String>(Arrays.asList(locales));

        /* Make it so you can't add a locale if it already exists */
        if (imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem().getLanguageImages_OTM() != null) {
            for (@NotNull final RESTLanguageImageCollectionItemV1 langImage : imageFilteredResultsComponent.getProviderData()
                    .getDisplayedItem().getItem().getLanguageImages_OTM().returnExistingAndAddedCollectionItems()) {
                newLocales.remove(langImage.getItem().getLocale());
            }
        }

        return newLocales;
    }

    private void populateLocales() {
        final RESTCallBack<RESTStringConstantV1> callback = new RESTCallBack<RESTStringConstantV1>() {
            @Override
            public void success(@NotNull final RESTStringConstantV1 retValue) {
                /* Get the list of locales from the StringConstant */
                locales = retValue.getValue().replaceAll("\\r\\n", "").replaceAll("\\n", "").replaceAll(" ", "").split(",");

                finishLoading();
            }
        };

        FailOverRESTCall.performRESTCall(FailOverRESTCallDatabase.getStringConstant(ServiceConstants.LOCALE_STRING_CONSTANT), callback, display);
    }

    /**
     * Each Language Image has an upload button that needs to be bound to some behaviour.
     */
    private void bindImageUploadButtons() {

        checkState(imageComponent.getDisplay().getEditor() != null, "display.getEditor() cannot be null");

        for (@NotNull final RESTLanguageImageV1Editor editor : imageComponent.getDisplay().getEditor().languageImages_OTMEditor().itemsEditor().getEditors()) {
            editor.getUploadButton().addClickHandler(new ClickHandler() {
                @Override
                public void onClick(final ClickEvent event) {

                    /*
                     * There should only be one file, but use a loop to accommodate any changes that might implement multiple
                     * files
                     */
                    for (@NotNull final File file : editor.getUpload().getFiles()) {
                        display.addWaitOperation();

                        final FileReader reader = new FileReader();

                        reader.addErrorHandler(new ErrorHandler() {
                            @Override
                            public void onError(@NotNull final org.vectomatic.file.events.ErrorEvent event) {
                                imageComponent.getDisplay().removeWaitOperation();
                            }
                        });

                        reader.addLoadEndHandler(new LoadEndHandler() {
                            @Override
                            public void onLoadEnd(@NotNull final LoadEndEvent event) {
                                try {
                                    checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem() != null, "There should be a displayed collection item.");
                                    checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem() != null, "The displayed collection item to reference a valid entity.");
                                    checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem().getId() != null, "The displayed collection item to reference a valid entity and have a valid id");

                                    final String result = reader.getStringResult();
                                    final byte[] buffer = GWTUtilities.getByteArray(result, 1);

                                    /* Flush any changes */
                                    imageComponent.getDisplay().getDriver().flush();
                                    
                                    /*
                                     * Create the image to be modified. This is so we don't send off unnecessary data.
                                     */
                                    final RESTImageV1 updateImage = new RESTImageV1();
                                    updateImage.setId(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem().getId());
                                    updateImage.explicitSetDescription(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem().getDescription());

                                    /* Create the language image */
                                    final RESTLanguageImageV1 updatedLanguageImage = new RESTLanguageImageV1();
                                    updatedLanguageImage.setId(editor.self.getItem().getId());
                                    updatedLanguageImage.explicitSetImageData(buffer);
                                    updatedLanguageImage.explicitSetFilename(file.getName());

                                    /* Add the language image */
                                    updateImage.explicitSetLanguageImages_OTM(new RESTLanguageImageCollectionV1());
                                    updateImage.getLanguageImages_OTM().addUpdateItem(updatedLanguageImage);

                                    FailOverRESTCall.performRESTCall(FailOverRESTCallDatabase.updateImage(updateImage), getDefaultImageRestCallback(), display);
                                } finally {
                                    display.removeWaitOperation();
                                }
                            }
                        });

                        reader.readAsBinaryString(file);

                        /* we only upload one file */
                        break;
                    }
                }
            });
        }
    }

    @Override
    public boolean hasUnsavedChanges() {
        if (imageFilteredResultsComponent.getProviderData().getDisplayedItem() != null) {

            checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem() != null, "There should be a displayed collection item.");
            checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem() != null, "The displayed collection item to reference a valid entity.");
            checkState(imageFilteredResultsComponent.getProviderData().getSelectedItem() != null, "There should be a selected collection item.");
            checkState(imageFilteredResultsComponent.getProviderData().getSelectedItem().getItem() != null, "The selected collection item to reference a valid entity.");

            imageComponent.getDisplay().getDriver().flush();

            return !GWTUtilities.stringEqualsEquatingNullWithEmptyString(imageFilteredResultsComponent.getProviderData()
                    .getSelectedItem().getItem().getDescription(), imageFilteredResultsComponent.getProviderData()
                    .getDisplayedItem().getItem().getDescription());
        }
        return false;
    }

    /**
     * Potentially two REST calls have to finish before we can display the page. This function will be called as each REST call
     * finishes, and when all the information has been gathered, the page will be displayed.
     */
    private void finishLoading() {
        if (locales != null && imageFilteredResultsComponent.getProviderData().getDisplayedItem() != null) {
            initializeViews();
        }
    }

    @Override
    protected void bindActionButtons() {
        imageComponent.getDisplay().getSave().addClickHandler(new ClickHandler() {
            @Override
            public void onClick(final ClickEvent event) {
                if (hasUnsavedChanges()) {

                    checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem() != null, "There should be a displayed collection item.");
                    checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem() != null, "The displayed collection item to reference a valid entity.");

                    /*
                     * Create the image to be modified. This is so we don't send off unnessessary data.
                     */
                    final RESTImageV1 updateImage = new RESTImageV1();
                    updateImage.setId(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem().getId());
                    updateImage.explicitSetDescription(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem().getDescription());

                    FailOverRESTCall.performRESTCall(FailOverRESTCallDatabase.updateImage(updateImage), getDefaultImageRestCallback(), display);
                } else {
                    Window.alert(PressGangCCMSUI.INSTANCE.NoUnsavedChanges());
                }

            }
        });

        imageComponent.getDisplay().getAddLocale().addClickHandler(new ClickHandler() {
            @Override
            public void onClick(final ClickEvent event) {
                imageComponent.getDisplay().getAddLocaleDialog().getDialogBox().center();
                imageComponent.getDisplay().getAddLocaleDialog().getDialogBox().show();
            }
        });

        imageComponent.getDisplay().getRemoveLocale().addClickHandler(new ClickHandler() {
            @Override
            public void onClick(final ClickEvent event) {
                if (Window.confirm(PressGangCCMSUI.INSTANCE.ConfirmDelete())) {

                    final int selectedTab = imageComponent.getDisplay().getEditor().languageImages_OTMEditor().getSelectedIndex();
                    if (selectedTab != -1) {

                        checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem() != null, "There should be a displayed collection item.");
                        checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem() != null, "The displayed collection item to reference a valid entity.");

                        final RESTLanguageImageCollectionItemV1 selectedImage = imageComponent.getDisplay().getEditor()
                                .languageImages_OTMEditor().itemsEditor().getList().get(selectedTab);

                        /* Adding or removing a locale will save changes to the description */
                        imageComponent.getDisplay().getDriver().flush();

                        /*
                         * Create the image to be modified. This is so we don't send off unnessessary data.
                         */
                        final RESTImageV1 updateImage = new RESTImageV1();
                        updateImage.setId(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem().getId());
                        updateImage.explicitSetDescription(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem().getDescription());

                        /* Create the language image */
                        final RESTLanguageImageV1 languageImage = new RESTLanguageImageV1();
                        languageImage.setId(selectedImage.getItem().getId());

                        /* Add the langauge image */
                        updateImage.explicitSetLanguageImages_OTM(new RESTLanguageImageCollectionV1());
                        updateImage.getLanguageImages_OTM().addRemoveItem(languageImage);

                        FailOverRESTCall.performRESTCall(FailOverRESTCallDatabase.updateImage(updateImage), getDefaultImageRestCallback(), display);
                    }
                }
            }
        });

        imageComponent.getDisplay().getAddLocaleDialog().getOk().addClickHandler(new ClickHandler() {
            @Override
            public void onClick(final ClickEvent event) {

                checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem() != null, "There should be a displayed collection item.");
                checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem() != null, "The displayed collection item to reference a valid entity.");

                imageComponent.getDisplay().getAddLocaleDialog().getDialogBox().hide();

                final String selectedLocale = imageComponent.getDisplay().getAddLocaleDialog().getLocales()
                        .getItemText(imageComponent.getDisplay().getAddLocaleDialog().getLocales().getSelectedIndex());

                /* Don't add locales twice */
                if (imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem().getLanguageImages_OTM() != null) {
                    for (@NotNull final RESTLanguageImageCollectionItemV1 langImage : imageFilteredResultsComponent.getProviderData()
                            .getDisplayedItem().getItem().getLanguageImages_OTM().returnExistingAndAddedCollectionItems()) {
                        if (langImage.getItem().getLocale().equals(selectedLocale)) {
                            return;
                        }
                    }
                }

                /* Adding or removing a locate will also save any changes to the description */
                imageComponent.getDisplay().getDriver().flush();

                /*
                 * Create the image to be modified. This is so we don't send off unnessessary data.
                 */
                final RESTImageV1 updateImage = new RESTImageV1();
                updateImage.setId(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem().getId());
                updateImage.explicitSetDescription(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem().getDescription());

                /* Create the language image */
                final RESTLanguageImageV1 languageImage = new RESTLanguageImageV1();
                languageImage.explicitSetLocale(selectedLocale);

                /* Add the langauge image */
                updateImage.explicitSetLanguageImages_OTM(new RESTLanguageImageCollectionV1());
                updateImage.getLanguageImages_OTM().addNewItem(languageImage);

                FailOverRESTCall.performRESTCall(FailOverRESTCallDatabase.updateImage(updateImage), getDefaultImageRestCallback(), display);
            }
        });

        imageComponent.getDisplay().getAddLocaleDialog().getCancel().addClickHandler(new ClickHandler() {
            @Override
            public void onClick(final ClickEvent event) {
                imageComponent.getDisplay().getAddLocaleDialog().getDialogBox().hide();
            }
        });

        imageComponent.getDisplay().getViewImage().addClickHandler(new ClickHandler() {
            @Override
            public void onClick(@NotNull final ClickEvent event) {

                checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem() != null, "There should be a displayed collection item.");
                checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem() != null, "The displayed collection item to reference a valid entity.");

                final int selectedTab = imageComponent.getDisplay().getEditor().languageImages_OTMEditor().getSelectedIndex();
                if (selectedTab != -1) {
                    final RESTLanguageImageCollectionItemV1 selectedImage = imageComponent.getDisplay().getEditor()
                            .languageImages_OTMEditor().itemsEditor().getList().get(selectedTab);

                    Window.open(ServerDetails.getSavedServer().getRestEndpoint() + "/1/image/get/raw/" +
                            imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem().getId() + "?" + selectedImage.getItem().getLocale(),
                            null, null);
                }
            }
        });

        imageComponent.getDisplay().getFindTopics().addClickHandler(new ClickHandler() {

            @Override
            public void onClick(@NotNull final ClickEvent event) {

                checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem() != null, "There should be a displayed collection item.");
                checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem() != null, "The displayed collection item to reference a valid entity.");

                final String docbookFileName = ComponentImageV1.getDocbookFileName(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem());

                if (docbookFileName != null && !docbookFileName.isEmpty() && isOKToProceed()) {

                    final String searchQuery = "images/" + docbookFileName;

                    eventBus.fireEvent(new SearchResultsAndTopicViewEvent(Constants.QUERY_PATH_SEGMENT_PREFIX
                            + org.jboss.pressgang.ccms.utils.constants.CommonFilterConstants.TOPIC_XML_FILTER_VAR + "=" + (Constants.ENCODE_QUERY_OPTIONS ? URL.encodePathSegment(searchQuery) : searchQuery), event.getNativeEvent()
                            .getKeyCode() == KeyCodes.KEY_CTRL));
                }

            }
        });
    }

    /**
     * Open a popup window that displays the image defined in the base64 parameter
     *
     * @param base64 The BASE64 representation of the image to be displayed
     */
    native private void displayImageInPopup(@NotNull final String base64) /*-{
		var win = $wnd.open("data:image/jpeg;base64," + base64, "_blank",
			"width=" + (screen.width - 200) + ", height="
				+ (screen.height - 200) + ", left=100, top=100"); // a window object
	}-*/;

    private void doSearch(final boolean newWindow) {
        if (isOKToProceed()) {
            eventBus.fireEvent(new ImagesFilteredResultsAndImageViewEvent(imageFilteredResultsComponent.getQuery(), newWindow));
        }
    }

    @Override
    protected void bindFilteredResultsButtons() {
        imageFilteredResultsComponent.getDisplay().getEntitySearch().addClickHandler(new ClickHandler() {
            @Override
            public void onClick(@NotNull final ClickEvent event) {
                doSearch(GWTUtilities.isEventToOpenNewWindow(event));
            }
        });

        final KeyPressHandler searchKeyPressHandler = new KeyPressHandler() {
            @Override
            public void onKeyPress(@NotNull final KeyPressEvent event) {
                LOGGER.log(Level.INFO, "ENTER BaseSearchAndEditViewInterface.bindFilteredResultsButtons() KeyPressHandler.onKeyPress()");

                final int charCode = event.getUnicodeCharCode();
                if (charCode == 0) {
                    // it's probably Firefox
                    final int keyCode = event.getNativeEvent().getKeyCode();
                    // beware! keyCode=40 means "down arrow", while charCode=40 means '('
                    // always check the keyCode against a list of "known to be buggy" codes!
                    if (keyCode == KeyCodes.KEY_ENTER) {
                        doSearch(false);
                    }
                } else if (charCode == KeyCodes.KEY_ENTER) {
                    doSearch(false);
                }

            }
        };

        imageFilteredResultsComponent.getDisplay().getImageDescriptionFilter().addKeyPressHandler(searchKeyPressHandler);
        imageFilteredResultsComponent.getDisplay().getImageIdFilter().addKeyPressHandler(searchKeyPressHandler);
        imageFilteredResultsComponent.getDisplay().getImageOriginalFileNameFilter().addKeyPressHandler(searchKeyPressHandler);

        imageFilteredResultsComponent.getDisplay().getCreate().addClickHandler(new ClickHandler() {
            @Override
            public void onClick(@NotNull final ClickEvent event) {
                if (isOKToProceed()) {

                    final RESTCallBack<RESTStringConstantV1> callback = new RESTCallBack<RESTStringConstantV1>() {
                        @Override
                        public void success(@NotNull final RESTStringConstantV1 retValue) {
                            checkArgument(retValue.getValue() != null, "The returned string constant should have a valid value.");

                                    /* When we have the default locale, create a new image */
                            final RESTLanguageImageV1 langImage = new RESTLanguageImageV1();
                            langImage.explicitSetLocale(retValue.getValue());

                            final RESTImageV1 newImage = new RESTImageV1();
                            newImage.explicitSetLanguageImages_OTM(new RESTLanguageImageCollectionV1());
                            newImage.getLanguageImages_OTM().addNewItem(langImage);

                            final RESTCallBack<RESTImageV1> callback = new RESTCallBack<RESTImageV1>() {
                                @Override
                                public void success(@NotNull final RESTImageV1 retValue) {
                                    final RESTImageCollectionItemV1 selectedImageCollectionItem = new RESTImageCollectionItemV1();
                                    selectedImageCollectionItem.setItem(retValue.clone(false));
                                    imageFilteredResultsComponent.getProviderData().setSelectedItem(selectedImageCollectionItem);

                                    final RESTImageCollectionItemV1 displayedImageCollectionItem = new RESTImageCollectionItemV1();
                                    displayedImageCollectionItem.setItem(retValue.clone(false));
                                    imageFilteredResultsComponent.getProviderData().setDisplayedItem(displayedImageCollectionItem);

                                    initializeViews();

                                            /* Display the entities property view */
                                    switchView(imageComponent.getDisplay());

                                            /* Reload the filtered results view */
                                    updateDisplayWithNewEntityData(true);
                                }
                            };

                            FailOverRESTCall.performRESTCall(FailOverRESTCallDatabase.createImage(newImage), callback, display);
                        }
                    };

                    FailOverRESTCall.performRESTCall(FailOverRESTCallDatabase.getStringConstant(ServiceConstants.DEFAULT_LOCALE_ID), callback, display);
                }
            }
        });

        imageFilteredResultsComponent.getDisplay().getBulkUpload().addClickHandler(new ClickHandler() {
            @Override
            public void onClick(@NotNull final ClickEvent event) {
                display.getBulkUploadDialog().getDialogBox().center();
            }
        });

        display.getBulkUploadDialog().getCancel().addClickHandler(new ClickHandler() {
            @Override
            public void onClick(@NotNull final ClickEvent event) {
                display.getBulkUploadDialog().getDialogBox().hide();
            }
        });

        display.getBulkUploadDialog().getOK().addClickHandler(new ClickHandler() {
            @Override
            public void onClick(@NotNull final ClickEvent event) {
                display.getBulkUploadDialog().getDialogBox().hide();

                if (display.getBulkUploadDialog().getFiles().getFiles().getLength() == 0) {
                    Window.alert(PressGangCCMSUI.INSTANCE.NoFilesSelected());
                } else {
                    /* Start by getting the default locale */
                    final RESTCallBack<RESTStringConstantV1> callback = new RESTCallBack<RESTStringConstantV1>() {
                        @Override
                        public void success(@NotNull final RESTStringConstantV1 retValue) {
                            checkArgument(retValue.getValue() != null, "The returned string constant should have a valid value.");
                            createNewImage(
                                    display.getBulkUploadDialog().getDescription().getText(),
                                    retValue.getValue(),
                                    0,
                                    display.getBulkUploadDialog().getFiles().getFiles(),
                                    new ArrayList<Integer>(),
                                    new ArrayList<String>());
                        }
                    };

                    FailOverRESTCall.performRESTCall(FailOverRESTCallDatabase.getStringConstant(ServiceConstants.DEFAULT_LOCALE_ID), callback, display);
                }
            }
        });
    }

    /**
     * A methods to recursively load a file from the disk, add it to a new image, and upload the image.
     *
     * @param description The common description to be added to each image
     * @param locale      The image locale
     * @param index       The index of the file we are uploading
     * @param files       The collection of file selected on the disk
     * @param ids         A list of the newly created image ids
     */
    private void createNewImage(@NotNull final String description, @NotNull final String locale, final int index, @NotNull final FileList files, @NotNull final List<Integer> ids, @NotNull final List<String> failedFiled) {
        if (index >= files.getLength()) {

            final StringBuilder idsQuery = new StringBuilder();
            for (final Integer id : ids) {
                if (!idsQuery.toString().isEmpty()) {
                    idsQuery.append(",");
                }
                idsQuery.append(id);
            }

            if (failedFiled.size() == 0) {
                Window.alert(PressGangCCMSUI.INSTANCE.ImagesUplodedSuccessfully() + " " + idsQuery.toString());
            } else {
                final StringBuilder failedNames = new StringBuilder();
                for (final String name : failedFiled) {
                    if (!failedNames.toString().isEmpty()) {
                        failedNames.append(",");
                    }
                    failedNames.append(name);
                }

                Window.alert(PressGangCCMSUI.INSTANCE.ImagesNotUplodedSuccessfully() + ": " + failedNames.toString() + "\n" +
                        PressGangCCMSUI.INSTANCE.ImagesUplodedSuccessfully() + idsQuery.toString());
            }


            eventBus.fireEvent(new ImagesFilteredResultsAndImageViewEvent(Constants.QUERY_PATH_SEGMENT_PREFIX + CommonFilterConstants.IMAGE_IDS_FILTER_VAR + "=" + idsQuery.toString(), false));
        } else {
            display.addWaitOperation();


            @NotNull final FileReader reader = new FileReader();

            reader.addErrorHandler(new ErrorHandler() {
                @Override
                public void onError(@NotNull final org.vectomatic.file.events.ErrorEvent event) {
                    display.removeWaitOperation();
                    failedFiled.add(files.getItem(index).getName());
                    createNewImage(description, locale, index + 1, files, ids, failedFiled);
                }
            });

            reader.addLoadEndHandler(new LoadEndHandler() {
                @Override
                public void onLoadEnd(@NotNull final LoadEndEvent event) {
                    try {
                        final String result = reader.getStringResult();
                        final byte[] buffer = GWTUtilities.getByteArray(result, 1);

                         /* When we have the default locale, create a new image */
                        final RESTLanguageImageV1 langImage = new RESTLanguageImageV1();
                        langImage.explicitSetLocale(locale);
                        langImage.explicitSetImageData(buffer);
                        langImage.explicitSetFilename(files.getItem(index).getName());

                        final RESTImageV1 newImage = new RESTImageV1();
                        newImage.explicitSetDescription(description);
                        newImage.explicitSetLanguageImages_OTM(new RESTLanguageImageCollectionV1());
                        newImage.getLanguageImages_OTM().addNewItem(langImage);

                        final RESTCallBack<RESTImageV1> callback = new RESTCallBack<RESTImageV1>() {
                            @Override
                            public void success(@NotNull final RESTImageV1 retValue) {
                                ids.add(retValue.getId());
                                createNewImage(description, locale, index + 1, files, ids, failedFiled);
                            }

                            @Override
                            public void failed() {
                                createNewImage(description, locale, index + 1, files, ids, failedFiled);
                            }
                        };

                        FailOverRESTCall.performRESTCall(FailOverRESTCallDatabase.createImage(newImage), callback, display);
                    } finally {
                        display.removeWaitOperation();
                    }
                }
            });

            reader.readAsBinaryString(files.getItem(index));
        }

    }

    @Override
    protected void initializeViews(@Nullable final List<BaseTemplateViewInterface> filter) {

        checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem() != null, "There should be a displayed collection item.");
        checkState(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem() != null, "The displayed collection item to reference a valid entity.");

        if (viewIsInFilter(filter, imageComponent.getDisplay())) {
            imageComponent.getDisplay().displayExtended(imageFilteredResultsComponent.getProviderData().getDisplayedItem().getItem(), false,
                    getUnassignedLocales().toArray(new String[0]));
        }

        bindImageUploadButtons();
    }
}
